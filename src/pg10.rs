/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl <T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) { }
}
impl <T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl <T> ::std::cmp::Eq for __BindgenUnionField<T> { }
pub const __llvm__: ::std::os::raw::c_uint = 1;
pub const __clang__: ::std::os::raw::c_uint = 1;
pub const __clang_major__: ::std::os::raw::c_uint = 3;
pub const __clang_minor__: ::std::os::raw::c_uint = 8;
pub const __clang_patchlevel__: ::std::os::raw::c_uint = 0;
pub const __clang_version__: &'static [u8; 31usize] =
    b"3.8.0 (tags/RELEASE_380/final)\x00";
pub const __GNUC_MINOR__: ::std::os::raw::c_uint = 2;
pub const __GNUC_PATCHLEVEL__: ::std::os::raw::c_uint = 1;
pub const __GNUC__: ::std::os::raw::c_uint = 4;
pub const __GXX_ABI_VERSION: ::std::os::raw::c_uint = 1002;
pub const __ATOMIC_RELAXED: ::std::os::raw::c_uint = 0;
pub const __ATOMIC_CONSUME: ::std::os::raw::c_uint = 1;
pub const __ATOMIC_ACQUIRE: ::std::os::raw::c_uint = 2;
pub const __ATOMIC_RELEASE: ::std::os::raw::c_uint = 3;
pub const __ATOMIC_ACQ_REL: ::std::os::raw::c_uint = 4;
pub const __ATOMIC_SEQ_CST: ::std::os::raw::c_uint = 5;
pub const __PRAGMA_REDEFINE_EXTNAME: ::std::os::raw::c_uint = 1;
pub const __VERSION__: &'static [u8; 54usize] =
    b"4.2.1 Compatible Clang 3.8.0 (tags/RELEASE_380/final)\x00";
pub const __CONSTANT_CFSTRINGS__: ::std::os::raw::c_uint = 1;
pub const __GXX_RTTI: ::std::os::raw::c_uint = 1;
pub const __ORDER_LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1234;
pub const __ORDER_BIG_ENDIAN__: ::std::os::raw::c_uint = 4321;
pub const __ORDER_PDP_ENDIAN__: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER__: ::std::os::raw::c_uint = 1234;
pub const __LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1;
pub const _LP64: ::std::os::raw::c_uint = 1;
pub const __LP64__: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT__: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX__: ::std::os::raw::c_uint = 127;
pub const __SHRT_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __LONG_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_LONG_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __WCHAR_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INTMAX_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_MAX__: ::std::os::raw::c_int = -1;
pub const __UINTMAX_MAX__: ::std::os::raw::c_int = -1;
pub const __PTRDIFF_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INTPTR_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __UINTPTR_MAX__: ::std::os::raw::c_int = -1;
pub const __SIZEOF_DOUBLE__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_FLOAT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_LONG_DOUBLE__: ::std::os::raw::c_uint = 16;
pub const __SIZEOF_LONG_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_POINTER__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SHORT__: ::std::os::raw::c_uint = 2;
pub const __SIZEOF_PTRDIFF_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SIZE_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_WCHAR_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_WINT_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT128__: ::std::os::raw::c_uint = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __PTRDIFF_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __SIZE_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __WCHAR_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __WINT_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __FLT_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __FLT_DIG__: ::std::os::raw::c_uint = 6;
pub const __FLT_DECIMAL_DIG__: ::std::os::raw::c_uint = 9;
pub const __FLT_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __FLT_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __FLT_MANT_DIG__: ::std::os::raw::c_uint = 24;
pub const __FLT_MAX_10_EXP__: ::std::os::raw::c_uint = 38;
pub const __FLT_MAX_EXP__: ::std::os::raw::c_uint = 128;
pub const __FLT_MIN_10_EXP__: ::std::os::raw::c_int = -37;
pub const __FLT_MIN_EXP__: ::std::os::raw::c_int = -125;
pub const __DBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __DBL_DIG__: ::std::os::raw::c_uint = 15;
pub const __DBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 17;
pub const __DBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __DBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __DBL_MANT_DIG__: ::std::os::raw::c_uint = 53;
pub const __DBL_MAX_10_EXP__: ::std::os::raw::c_uint = 308;
pub const __DBL_MAX_EXP__: ::std::os::raw::c_uint = 1024;
pub const __DBL_MIN_10_EXP__: ::std::os::raw::c_int = -307;
pub const __DBL_MIN_EXP__: ::std::os::raw::c_int = -1021;
pub const __LDBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __LDBL_DIG__: ::std::os::raw::c_uint = 18;
pub const __LDBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __LDBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __LDBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __LDBL_MANT_DIG__: ::std::os::raw::c_uint = 64;
pub const __LDBL_MAX_10_EXP__: ::std::os::raw::c_uint = 4932;
pub const __LDBL_MAX_EXP__: ::std::os::raw::c_uint = 16384;
pub const __LDBL_MIN_10_EXP__: ::std::os::raw::c_int = -4931;
pub const __LDBL_MIN_EXP__: ::std::os::raw::c_int = -16381;
pub const __POINTER_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __BIGGEST_ALIGNMENT__: ::std::os::raw::c_uint = 16;
pub const __WINT_UNSIGNED__: ::std::os::raw::c_uint = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT8_MAX__: ::std::os::raw::c_uint = 255;
pub const __INT8_MAX__: ::std::os::raw::c_uint = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __INT16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __INT32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINT64_MAX__: ::std::os::raw::c_int = -1;
pub const __INT64_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INT_LEAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_LEAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_LEAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_LEAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_LEAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_LEAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_LEAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_LEAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INT_FAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_FAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_FAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_FAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_FAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_FAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_FAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_FAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __FINITE_MATH_ONLY__: ::std::os::raw::c_uint = 0;
pub const __GNUC_STDC_INLINE__: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __NO_INLINE__: ::std::os::raw::c_uint = 1;
pub const __FLT_EVAL_METHOD__: ::std::os::raw::c_uint = 0;
pub const __FLT_RADIX__: ::std::os::raw::c_uint = 2;
pub const __DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __amd64__: ::std::os::raw::c_uint = 1;
pub const __amd64: ::std::os::raw::c_uint = 1;
pub const __x86_64: ::std::os::raw::c_uint = 1;
pub const __x86_64__: ::std::os::raw::c_uint = 1;
pub const __k8: ::std::os::raw::c_uint = 1;
pub const __k8__: ::std::os::raw::c_uint = 1;
pub const __tune_k8__: ::std::os::raw::c_uint = 1;
pub const __NO_MATH_INLINES: ::std::os::raw::c_uint = 1;
pub const __FXSR__: ::std::os::raw::c_uint = 1;
pub const __SSE2__: ::std::os::raw::c_uint = 1;
pub const __SSE2_MATH__: ::std::os::raw::c_uint = 1;
pub const __SSE__: ::std::os::raw::c_uint = 1;
pub const __SSE_MATH__: ::std::os::raw::c_uint = 1;
pub const __MMX__: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: ::std::os::raw::c_uint = 1;
pub const unix: ::std::os::raw::c_uint = 1;
pub const __unix: ::std::os::raw::c_uint = 1;
pub const __unix__: ::std::os::raw::c_uint = 1;
pub const linux: ::std::os::raw::c_uint = 1;
pub const __linux: ::std::os::raw::c_uint = 1;
pub const __linux__: ::std::os::raw::c_uint = 1;
pub const __gnu_linux__: ::std::os::raw::c_uint = 1;
pub const __ELF__: ::std::os::raw::c_uint = 1;
pub const __STDC__: ::std::os::raw::c_uint = 1;
pub const __STDC_HOSTED__: ::std::os::raw::c_uint = 1;
pub const __STDC_VERSION__: ::std::os::raw::c_uint = 201112;
pub const __STDC_UTF_16__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_32__: ::std::os::raw::c_uint = 1;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Copy)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) . __max_align_ll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __max_align_ll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) . __max_align_ld as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __max_align_ld ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(::std::mem::size_of::<lconv>() , 96usize , concat ! (
               "Size of: " , stringify ! ( lconv ) ));
    assert_eq! (::std::mem::align_of::<lconv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lconv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . decimal_point as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( decimal_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . thousands_sep as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( thousands_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . grouping as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( grouping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_curr_symbol as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_curr_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . currency_symbol as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( currency_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . mon_decimal_point as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( mon_decimal_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . mon_thousands_sep as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( mon_thousands_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . mon_grouping as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( mon_grouping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . positive_sign as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( positive_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . negative_sign as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( negative_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_frac_digits as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_frac_digits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . frac_digits as * const _ as
                usize } , 81usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( frac_digits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . p_cs_precedes as * const _ as
                usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( p_cs_precedes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . p_sep_by_space as * const _
                as usize } , 83usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( p_sep_by_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . n_cs_precedes as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( n_cs_precedes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . n_sep_by_space as * const _
                as usize } , 85usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( n_sep_by_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . p_sign_posn as * const _ as
                usize } , 86usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( p_sign_posn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . n_sign_posn as * const _ as
                usize } , 87usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( n_sign_posn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_p_cs_precedes as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_p_cs_precedes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_p_sep_by_space as * const
                _ as usize } , 89usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_p_sep_by_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_n_cs_precedes as * const
                _ as usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_n_cs_precedes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_n_sep_by_space as * const
                _ as usize } , 91usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_n_sep_by_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_p_sign_posn as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_p_sign_posn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lconv ) ) . int_n_sign_posn as * const _
                as usize } , 93usize , concat ! (
                "Alignment of field: " , stringify ! ( lconv ) , "::" ,
                stringify ! ( int_n_sign_posn ) ));
}
impl Clone for lconv {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setlocale(__category: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn newlocale(__category_mask: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char,
                     __base: __locale_t) -> __locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: __locale_t) -> __locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: __locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: __locale_t) -> __locale_t;
}
extern "C" {
    pub fn gettext(__msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dgettext(__domainname: *const ::std::os::raw::c_char,
                    __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __dgettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dcgettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid: *const ::std::os::raw::c_char,
                     __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __dcgettext(__domainname: *const ::std::os::raw::c_char,
                       __msgid: *const ::std::os::raw::c_char,
                       __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ngettext(__msgid1: *const ::std::os::raw::c_char,
                    __msgid2: *const ::std::os::raw::c_char,
                    __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dngettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid1: *const ::std::os::raw::c_char,
                     __msgid2: *const ::std::os::raw::c_char,
                     __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dcngettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid1: *const ::std::os::raw::c_char,
                      __msgid2: *const ::std::os::raw::c_char,
                      __n: ::std::os::raw::c_ulong,
                      __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn textdomain(__domainname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bindtextdomain(__domainname: *const ::std::os::raw::c_char,
                          __dirname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bind_textdomain_codeset(__domainname:
                                       *const ::std::os::raw::c_char,
                                   __codeset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type bool_ = ::std::os::raw::c_char;
pub type BoolPtr = *mut bool_;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct IntArray {
    pub indx: [::std::os::raw::c_int; 6usize],
}
#[test]
fn bindgen_test_layout_IntArray() {
    assert_eq!(::std::mem::size_of::<IntArray>() , 24usize , concat ! (
               "Size of: " , stringify ! ( IntArray ) ));
    assert_eq! (::std::mem::align_of::<IntArray>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( IntArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntArray ) ) . indx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IntArray ) , "::" ,
                stringify ! ( indx ) ));
}
impl Clone for IntArray {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varlena() {
    assert_eq!(::std::mem::size_of::<varlena>() , 4usize , concat ! (
               "Size of: " , stringify ! ( varlena ) ));
    assert_eq! (::std::mem::align_of::<varlena>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( varlena ) ));
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<int16>,
}
#[test]
fn bindgen_test_layout_int2vector() {
    assert_eq!(::std::mem::size_of::<int2vector>() , 24usize , concat ! (
               "Size of: " , stringify ! ( int2vector ) ));
    assert_eq! (::std::mem::align_of::<int2vector>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( int2vector ) ));
}
#[repr(C)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<Oid>,
}
#[test]
fn bindgen_test_layout_oidvector() {
    assert_eq!(::std::mem::size_of::<oidvector>() , 24usize , concat ! (
               "Size of: " , stringify ! ( oidvector ) ));
    assert_eq! (::std::mem::align_of::<oidvector>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( oidvector ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_nameData() {
    assert_eq!(::std::mem::size_of::<nameData>() , 64usize , concat ! (
               "Size of: " , stringify ! ( nameData ) ));
    assert_eq! (::std::mem::align_of::<nameData>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( nameData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nameData ) ) . data as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nameData ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for nameData {
    fn clone(&self) -> Self { *self }
}
pub type NameData = nameData;
pub type Name = *mut NameData;
pub const _ISupper: _bindgen_ty_1 = _bindgen_ty_1::_ISupper;
pub const _ISlower: _bindgen_ty_1 = _bindgen_ty_1::_ISlower;
pub const _ISalpha: _bindgen_ty_1 = _bindgen_ty_1::_ISalpha;
pub const _ISdigit: _bindgen_ty_1 = _bindgen_ty_1::_ISdigit;
pub const _ISxdigit: _bindgen_ty_1 = _bindgen_ty_1::_ISxdigit;
pub const _ISspace: _bindgen_ty_1 = _bindgen_ty_1::_ISspace;
pub const _ISprint: _bindgen_ty_1 = _bindgen_ty_1::_ISprint;
pub const _ISgraph: _bindgen_ty_1 = _bindgen_ty_1::_ISgraph;
pub const _ISblank: _bindgen_ty_1 = _bindgen_ty_1::_ISblank;
pub const _IScntrl: _bindgen_ty_1 = _bindgen_ty_1::_IScntrl;
pub const _ISpunct: _bindgen_ty_1 = _bindgen_ty_1::_ISpunct;
pub const _ISalnum: _bindgen_ty_1 = _bindgen_ty_1::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
pub type socklen_t = __socklen_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::std::mem::align_of::<sockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>() , 128usize , concat !
               ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_padding as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
}
impl Clone for sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
pub const MSG_OOB: _bindgen_ty_2 = _bindgen_ty_2::MSG_OOB;
pub const MSG_PEEK: _bindgen_ty_2 = _bindgen_ty_2::MSG_PEEK;
pub const MSG_DONTROUTE: _bindgen_ty_2 = _bindgen_ty_2::MSG_DONTROUTE;
pub const MSG_CTRUNC: _bindgen_ty_2 = _bindgen_ty_2::MSG_CTRUNC;
pub const MSG_PROXY: _bindgen_ty_2 = _bindgen_ty_2::MSG_PROXY;
pub const MSG_TRUNC: _bindgen_ty_2 = _bindgen_ty_2::MSG_TRUNC;
pub const MSG_DONTWAIT: _bindgen_ty_2 = _bindgen_ty_2::MSG_DONTWAIT;
pub const MSG_EOR: _bindgen_ty_2 = _bindgen_ty_2::MSG_EOR;
pub const MSG_WAITALL: _bindgen_ty_2 = _bindgen_ty_2::MSG_WAITALL;
pub const MSG_FIN: _bindgen_ty_2 = _bindgen_ty_2::MSG_FIN;
pub const MSG_SYN: _bindgen_ty_2 = _bindgen_ty_2::MSG_SYN;
pub const MSG_CONFIRM: _bindgen_ty_2 = _bindgen_ty_2::MSG_CONFIRM;
pub const MSG_RST: _bindgen_ty_2 = _bindgen_ty_2::MSG_RST;
pub const MSG_ERRQUEUE: _bindgen_ty_2 = _bindgen_ty_2::MSG_ERRQUEUE;
pub const MSG_NOSIGNAL: _bindgen_ty_2 = _bindgen_ty_2::MSG_NOSIGNAL;
pub const MSG_MORE: _bindgen_ty_2 = _bindgen_ty_2::MSG_MORE;
pub const MSG_WAITFORONE: _bindgen_ty_2 = _bindgen_ty_2::MSG_WAITFORONE;
pub const MSG_FASTOPEN: _bindgen_ty_2 = _bindgen_ty_2::MSG_FASTOPEN;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_2 = _bindgen_ty_2::MSG_CMSG_CLOEXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Copy)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::std::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::std::mem::align_of::<cmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr)
     -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_3 = _bindgen_ty_3::SCM_RIGHTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::std::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::std::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
pub const SHUT_RD: _bindgen_ty_4 = _bindgen_ty_4::SHUT_RD;
pub const SHUT_WR: _bindgen_ty_4 = _bindgen_ty_4::SHUT_WR;
pub const SHUT_RDWR: _bindgen_ty_4 = _bindgen_ty_4::SHUT_RDWR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
extern "C" {
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                   __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __flags: ::std::os::raw::c_int, __addr: *const sockaddr,
                  __addr_len: socklen_t) -> isize;
}
extern "C" {
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: usize,
                    __flags: ::std::os::raw::c_int, __addr: *mut sockaddr,
                    __addr_len: *mut socklen_t) -> isize;
}
extern "C" {
    pub fn sendmsg(__fd: ::std::os::raw::c_int, __message: *const msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( in_addr ) ));
    assert_eq! (::std::mem::align_of::<in_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_addr ) ) . s_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_addr ) , "::" ,
                stringify ! ( s_addr ) ));
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(::std::mem::size_of::<ip_opts>() , 44usize , concat ! (
               "Size of: " , stringify ! ( ip_opts ) ));
    assert_eq! (::std::mem::align_of::<ip_opts>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_dst as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_opts as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_opts ) ));
}
impl Clone for ip_opts {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::std::mem::size_of::<ip_mreqn>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreqn ) ));
    assert_eq! (::std::mem::align_of::<ip_mreqn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_address as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_ifindex as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_ifindex ) ));
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(::std::mem::size_of::<in_pktinfo>() , 12usize , concat ! (
               "Size of: " , stringify ! ( in_pktinfo ) ));
    assert_eq! (::std::mem::align_of::<in_pktinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_pktinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_ifindex as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_spec_dst as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_spec_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_addr ) ));
}
impl Clone for in_pktinfo {
    fn clone(&self) -> Self { *self }
}
pub const IPPROTO_IP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_IP;
pub const IPPROTO_ICMP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ICMP;
pub const IPPROTO_IGMP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_IGMP;
pub const IPPROTO_IPIP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_IPIP;
pub const IPPROTO_TCP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_TCP;
pub const IPPROTO_EGP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_EGP;
pub const IPPROTO_PUP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_PUP;
pub const IPPROTO_UDP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_UDP;
pub const IPPROTO_IDP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_IDP;
pub const IPPROTO_TP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_TP;
pub const IPPROTO_DCCP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_DCCP;
pub const IPPROTO_IPV6: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_IPV6;
pub const IPPROTO_RSVP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_RSVP;
pub const IPPROTO_GRE: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_GRE;
pub const IPPROTO_ESP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ESP;
pub const IPPROTO_AH: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_AH;
pub const IPPROTO_MTP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_MTP;
pub const IPPROTO_BEETPH: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_BEETPH;
pub const IPPROTO_ENCAP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ENCAP;
pub const IPPROTO_PIM: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_PIM;
pub const IPPROTO_COMP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_COMP;
pub const IPPROTO_SCTP: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_SCTP;
pub const IPPROTO_UDPLITE: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_UDPLITE;
pub const IPPROTO_MPLS: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_MPLS;
pub const IPPROTO_RAW: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_RAW;
pub const IPPROTO_MAX: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
pub const IPPROTO_HOPOPTS: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_HOPOPTS;
pub const IPPROTO_ROUTING: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_ROUTING;
pub const IPPROTO_FRAGMENT: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_FRAGMENT;
pub const IPPROTO_ICMPV6: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_ICMPV6;
pub const IPPROTO_NONE: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_NONE;
pub const IPPROTO_DSTOPTS: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_DSTOPTS;
pub const IPPROTO_MH: _bindgen_ty_6 = _bindgen_ty_6::IPPROTO_MH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_ECHO;
pub const IPPORT_DISCARD: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_DISCARD;
pub const IPPORT_SYSTAT: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_SYSTAT;
pub const IPPORT_DAYTIME: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_DAYTIME;
pub const IPPORT_NETSTAT: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_NETSTAT;
pub const IPPORT_FTP: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_FTP;
pub const IPPORT_TELNET: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_TELNET;
pub const IPPORT_SMTP: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_SMTP;
pub const IPPORT_TIMESERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_TIMESERVER;
pub const IPPORT_NAMESERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_NAMESERVER;
pub const IPPORT_WHOIS: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_WHOIS;
pub const IPPORT_MTP: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_MTP;
pub const IPPORT_TFTP: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_TFTP;
pub const IPPORT_RJE: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_RJE;
pub const IPPORT_FINGER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_FINGER;
pub const IPPORT_TTYLINK: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_TTYLINK;
pub const IPPORT_SUPDUP: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_SUPDUP;
pub const IPPORT_EXECSERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_EXECSERVER;
pub const IPPORT_LOGINSERVER: _bindgen_ty_7 =
    _bindgen_ty_7::IPPORT_LOGINSERVER;
pub const IPPORT_CMDSERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_CMDSERVER;
pub const IPPORT_EFSSERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_EFSSERVER;
pub const IPPORT_BIFFUDP: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_EFSSERVER;
pub const IPPORT_RESERVED: _bindgen_ty_7 = _bindgen_ty_7::IPPORT_RESERVED;
pub const IPPORT_USERRESERVED: _bindgen_ty_7 =
    _bindgen_ty_7::IPPORT_USERRESERVED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Copy)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr8
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr16
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr32
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr32 ) ));
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( in6_addr ) ));
    assert_eq! (::std::mem::align_of::<in6_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr ) ) . __in6_u as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr ) , "::" ,
                stringify ! ( __in6_u ) ));
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::std::mem::size_of::<sockaddr_in>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_family as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_addr as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_zero as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_zero ) ));
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::std::mem::size_of::<sockaddr_in6>() , 28usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in6>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_family as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_flowinfo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_flowinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_scope_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_scope_id ) ));
}
impl Clone for sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::std::mem::size_of::<ip_mreq>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_interface as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_interface ) ));
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::std::mem::size_of::<ip_mreq_source>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq_source>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_sourceaddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_sourceaddr ) ));
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::std::mem::size_of::<ipv6_mreq>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (::std::mem::align_of::<ipv6_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_interface as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_interface ) ));
}
impl Clone for ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::std::mem::size_of::<group_req>() , 136usize , concat ! (
               "Size of: " , stringify ! ( group_req ) ));
    assert_eq! (::std::mem::align_of::<group_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_interface as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_group as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_group ) ));
}
impl Clone for group_req {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::std::mem::size_of::<group_source_req>() , 264usize , concat !
               ( "Size of: " , stringify ! ( group_source_req ) ));
    assert_eq! (::std::mem::align_of::<group_source_req>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( group_source_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_group as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_source as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_source ) ));
}
impl Clone for group_source_req {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(::std::mem::size_of::<ip_msfilter>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ip_msfilter ) ));
    assert_eq! (::std::mem::align_of::<ip_msfilter>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_msfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_fmode as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_numsrc as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_slist as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_slist ) ));
}
impl Clone for ip_msfilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(::std::mem::size_of::<group_filter>() , 272usize , concat ! (
               "Size of: " , stringify ! ( group_filter ) ));
    assert_eq! (::std::mem::align_of::<group_filter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_group as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_fmode as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_numsrc as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_slist as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_slist ) ));
}
impl Clone for group_filter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut sockaddr_in) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut sockaddr_in6)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(::std::mem::size_of::<rpcent>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rpcent ) ));
    assert_eq! (::std::mem::align_of::<rpcent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rpcent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpcent ) ) . r_name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpcent ) , "::" ,
                stringify ! ( r_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpcent ) ) . r_aliases as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rpcent ) , "::" ,
                stringify ! ( r_aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpcent ) ) . r_number as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rpcent ) , "::" ,
                stringify ! ( r_number ) ));
}
impl Clone for rpcent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut rpcent,
                          __buffer: *mut ::std::os::raw::c_char,
                          __buflen: usize, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcbynumber_r(__number: ::std::os::raw::c_int,
                            __result_buf: *mut rpcent,
                            __buffer: *mut ::std::os::raw::c_char,
                            __buflen: usize, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcent_r(__result_buf: *mut rpcent,
                       __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                       __result: *mut *mut rpcent) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(::std::mem::size_of::<netent>() , 24usize , concat ! (
               "Size of: " , stringify ! ( netent ) ));
    assert_eq! (::std::mem::align_of::<netent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( netent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const netent ) ) . n_name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( netent ) , "::" ,
                stringify ! ( n_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const netent ) ) . n_aliases as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( netent ) , "::" ,
                stringify ! ( n_aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const netent ) ) . n_addrtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( netent ) , "::" ,
                stringify ! ( n_addrtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const netent ) ) . n_net as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( netent ) , "::" ,
                stringify ! ( n_net ) ));
}
impl Clone for netent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn herror(__str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(__err_num: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(::std::mem::size_of::<hostent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( hostent ) ));
    assert_eq! (::std::mem::align_of::<hostent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( hostent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hostent ) ) . h_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hostent ) , "::" ,
                stringify ! ( h_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hostent ) ) . h_aliases as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hostent ) , "::" ,
                stringify ! ( h_aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hostent ) ) . h_addrtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hostent ) , "::" ,
                stringify ! ( h_addrtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hostent ) ) . h_length as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( hostent ) , "::" ,
                stringify ! ( h_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hostent ) ) . h_addr_list as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( hostent ) , "::" ,
                stringify ! ( h_addr_list ) ));
}
impl Clone for hostent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(__addr: *const ::std::os::raw::c_void,
                         __len: __socklen_t, __type: ::std::os::raw::c_int)
     -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char)
     -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2(__name: *const ::std::os::raw::c_char,
                          __af: ::std::os::raw::c_int) -> *mut hostent;
}
extern "C" {
    pub fn gethostent_r(__result_buf: *mut hostent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                        __result: *mut *mut hostent,
                        __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr_r(__addr: *const ::std::os::raw::c_void,
                           __len: __socklen_t, __type: ::std::os::raw::c_int,
                           __result_buf: *mut hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname_r(__name: *const ::std::os::raw::c_char,
                           __result_buf: *mut hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(__name: *const ::std::os::raw::c_char,
                            __af: ::std::os::raw::c_int,
                            __result_buf: *mut hostent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: usize, __result: *mut *mut hostent,
                            __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::std::os::raw::c_int)
     -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent_r(__result_buf: *mut netent,
                       __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                       __result: *mut *mut netent,
                       __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr_r(__net: u32, __type: ::std::os::raw::c_int,
                          __result_buf: *mut netent,
                          __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                          __result: *mut *mut netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut netent,
                          __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                          __result: *mut *mut netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(::std::mem::size_of::<servent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( servent ) ));
    assert_eq! (::std::mem::align_of::<servent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( servent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const servent ) ) . s_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( servent ) , "::" ,
                stringify ! ( s_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const servent ) ) . s_aliases as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( servent ) , "::" ,
                stringify ! ( s_aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const servent ) ) . s_port as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( servent ) , "::" ,
                stringify ! ( s_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const servent ) ) . s_proto as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( servent ) , "::" ,
                stringify ! ( s_proto ) ));
}
impl Clone for servent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(__name: *const ::std::os::raw::c_char,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut servent;
}
extern "C" {
    pub fn getservbyport(__port: ::std::os::raw::c_int,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut servent;
}
extern "C" {
    pub fn getservent_r(__result_buf: *mut servent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                        __result: *mut *mut servent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyname_r(__name: *const ::std::os::raw::c_char,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut servent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyport_r(__port: ::std::os::raw::c_int,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut servent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(::std::mem::size_of::<protoent>() , 24usize , concat ! (
               "Size of: " , stringify ! ( protoent ) ));
    assert_eq! (::std::mem::align_of::<protoent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( protoent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protoent ) ) . p_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( protoent ) , "::" ,
                stringify ! ( p_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protoent ) ) . p_aliases as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( protoent ) , "::" ,
                stringify ! ( p_aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protoent ) ) . p_proto as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( protoent ) , "::" ,
                stringify ! ( p_proto ) ));
}
impl Clone for protoent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char)
     -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent_r(__result_buf: *mut protoent,
                         __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                         __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobyname_r(__name: *const ::std::os::raw::c_char,
                            __result_buf: *mut protoent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: usize, __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobynumber_r(__proto: ::std::os::raw::c_int,
                              __result_buf: *mut protoent,
                              __buf: *mut ::std::os::raw::c_char,
                              __buflen: usize, __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn getnetgrent(__hostp: *mut *mut ::std::os::raw::c_char,
                       __userp: *mut *mut ::std::os::raw::c_char,
                       __domainp: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn innetgr(__netgroup: *const ::std::os::raw::c_char,
                   __host: *const ::std::os::raw::c_char,
                   __user: *const ::std::os::raw::c_char,
                   __domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent_r(__hostp: *mut *mut ::std::os::raw::c_char,
                         __userp: *mut *mut ::std::os::raw::c_char,
                         __domainp: *mut *mut ::std::os::raw::c_char,
                         __buffer: *mut ::std::os::raw::c_char,
                         __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(__ahost: *mut *mut ::std::os::raw::c_char,
                __rport: ::std::os::raw::c_ushort,
                __locuser: *const ::std::os::raw::c_char,
                __remuser: *const ::std::os::raw::c_char,
                __cmd: *const ::std::os::raw::c_char,
                __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(__ahost: *mut *mut ::std::os::raw::c_char,
                   __rport: ::std::os::raw::c_ushort,
                   __locuser: *const ::std::os::raw::c_char,
                   __remuser: *const ::std::os::raw::c_char,
                   __cmd: *const ::std::os::raw::c_char,
                   __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec(__ahost: *mut *mut ::std::os::raw::c_char,
                 __rport: ::std::os::raw::c_int,
                 __name: *const ::std::os::raw::c_char,
                 __pass: *const ::std::os::raw::c_char,
                 __cmd: *const ::std::os::raw::c_char,
                 __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec_af(__ahost: *mut *mut ::std::os::raw::c_char,
                    __rport: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __pass: *const ::std::os::raw::c_char,
                    __cmd: *const ::std::os::raw::c_char,
                    __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(__rhost: *const ::std::os::raw::c_char,
                   __suser: ::std::os::raw::c_int,
                   __remuser: *const ::std::os::raw::c_char,
                   __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok_af(__rhost: *const ::std::os::raw::c_char,
                      __suser: ::std::os::raw::c_int,
                      __remuser: *const ::std::os::raw::c_char,
                      __locuser: *const ::std::os::raw::c_char,
                      __af: sa_family_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(__raddr: u32, __suser: ::std::os::raw::c_int,
                    __remuser: *const ::std::os::raw::c_char,
                    __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_af(__raddr: *const ::std::os::raw::c_void,
                       __suser: ::std::os::raw::c_int,
                       __remuser: *const ::std::os::raw::c_char,
                       __locuser: *const ::std::os::raw::c_char,
                       __af: sa_family_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(__alport: *mut ::std::os::raw::c_int,
                        __af: sa_family_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(::std::mem::size_of::<addrinfo>() , 48usize , concat ! (
               "Size of: " , stringify ! ( addrinfo ) ));
    assert_eq! (::std::mem::align_of::<addrinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( addrinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_family as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_socktype as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_socktype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_protocol as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_addrlen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_canonname as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_canonname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const addrinfo ) ) . ai_next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( addrinfo ) , "::" ,
                stringify ! ( ai_next ) ));
}
impl Clone for addrinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getaddrinfo(__name: *const ::std::os::raw::c_char,
                       __service: *const ::std::os::raw::c_char,
                       __req: *const addrinfo, __pai: *mut *mut addrinfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getnameinfo(__sa: *const sockaddr, __salen: socklen_t,
                       __host: *mut ::std::os::raw::c_char,
                       __hostlen: socklen_t,
                       __serv: *mut ::std::os::raw::c_char,
                       __servlen: socklen_t, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_passwd() {
    assert_eq!(::std::mem::size_of::<passwd>() , 48usize , concat ! (
               "Size of: " , stringify ! ( passwd ) ));
    assert_eq! (::std::mem::align_of::<passwd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_passwd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_uid as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_gid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_gecos as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_gecos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_dir as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const passwd ) ) . pw_shell as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( passwd ) , "::" ,
                stringify ! ( pw_shell ) ));
}
impl Clone for passwd {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setpwent();
}
extern "C" {
    pub fn endpwent();
}
extern "C" {
    pub fn getpwent() -> *mut passwd;
}
extern "C" {
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
}
extern "C" {
    pub fn putpwent(__p: *const passwd, __f: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
}
extern "C" {
    pub fn getpwnam(__name: *const ::std::os::raw::c_char) -> *mut passwd;
}
extern "C" {
    pub fn getpwent_r(__resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwuid_r(__uid: __uid_t, __resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwnam_r(__name: *const ::std::os::raw::c_char,
                      __resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpwent_r(__stream: *mut FILE, __resultbuf: *mut passwd,
                       __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                       __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
pub type pgsocket = ::std::os::raw::c_int;
extern "C" {
    pub fn pg_set_noblock(sock: pgsocket) -> bool_;
}
extern "C" {
    pub fn pg_set_block(sock: pgsocket) -> bool_;
}
extern "C" {
    pub fn has_drive_prefix(filename: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn first_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn last_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn first_path_var_separator(pathlist: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn join_path_components(ret_path: *mut ::std::os::raw::c_char,
                                head: *const ::std::os::raw::c_char,
                                tail: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn make_native_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cleanup_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn path_is_prefix_of_path(path1: *const ::std::os::raw::c_char,
                                  path2: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn make_absolute_path(path: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_progname(argv0: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_share_path(my_exec_path: *const ::std::os::raw::c_char,
                          ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_etc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_include_path(my_exec_path: *const ::std::os::raw::c_char,
                            ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_pkginclude_path(my_exec_path: *const ::std::os::raw::c_char,
                               ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_includeserver_path(my_exec_path: *const ::std::os::raw::c_char,
                                  ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_lib_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_pkglib_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_locale_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_doc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_html_path(my_exec_path: *const ::std::os::raw::c_char,
                         ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_man_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pgfnames(path: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn set_pglocale_pgservice(argv0: *const ::std::os::raw::c_char,
                                  app: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn find_my_exec(argv0: *const ::std::os::raw::c_char,
                        retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_other_exec(argv0: *const ::std::os::raw::c_char,
                           target: *const ::std::os::raw::c_char,
                           versionstr: *const ::std::os::raw::c_char,
                           retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
}
extern "C" {
    pub fn pg_strcasecmp(s1: *const ::std::os::raw::c_char,
                         s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_strncasecmp(s1: *const ::std::os::raw::c_char,
                          s2: *const ::std::os::raw::c_char, n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn simple_prompt(prompt: *const ::std::os::raw::c_char,
                         destination: *mut ::std::os::raw::c_char,
                         destlen: usize, echo: bool_);
}
extern "C" {
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: bool_)
     -> bool_;
}
extern "C" {
    pub fn pg_erand48(xseed: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pg_jrand48(xseed: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
}
extern "C" {
    pub fn fls(mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeereid(sock: ::std::os::raw::c_int, uid: *mut uid_t,
                      gid: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlcat(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn pqStrerror(errnum: ::std::os::raw::c_int,
                      strerrbuf: *mut ::std::os::raw::c_char, buflen: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut passwd,
                      buffer: *mut ::std::os::raw::c_char, buflen: usize,
                      result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pqGethostbyname(name: *const ::std::os::raw::c_char,
                           resultbuf: *mut hostent,
                           buffer: *mut ::std::os::raw::c_char, buflen: usize,
                           result: *mut *mut hostent,
                           herrno: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_qsort(base: *mut ::std::os::raw::c_void, nel: usize,
                    elsize: usize,
                    cmp:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn pg_qsort_strcmp(a: *const ::std::os::raw::c_void,
                           b: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type qsort_arg_comparator =
    ::std::option::Option<unsafe extern "C" fn(a:
                                                   *const ::std::os::raw::c_void,
                                               b:
                                                   *const ::std::os::raw::c_void,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn qsort_arg(base: *mut ::std::os::raw::c_void, nel: usize,
                     elsize: usize, cmp: qsort_arg_comparator,
                     arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pg_get_encoding_from_locale(ctype: *const ::std::os::raw::c_char,
                                       write_message: bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_net_ntop(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_void,
                         bits: ::std::os::raw::c_int,
                         dst: *mut ::std::os::raw::c_char, size: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_strong_random(buf: *mut ::std::os::raw::c_void, len: usize)
     -> bool_;
}
extern "C" {
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_mkdir_p(path: *mut ::std::os::raw::c_char,
                      omode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type pqsigfunc =
    ::std::option::Option<unsafe extern "C" fn(signo: ::std::os::raw::c_int)>;
extern "C" {
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc)
     -> pqsigfunc;
}
extern "C" {
    pub fn pqsignal_no_restart(signo: ::std::os::raw::c_int, func: pqsigfunc)
     -> pqsigfunc;
}
extern "C" {
    pub fn escape_single_quotes_ascii(src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Copy)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(::std::mem::size_of::<__jmp_buf_tag>() , 200usize , concat ! (
               "Size of: " , stringify ! ( __jmp_buf_tag ) ));
    assert_eq! (::std::mem::align_of::<__jmp_buf_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __jmp_buf_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __jmp_buf_tag ) ) . __jmpbuf as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __jmp_buf_tag ) , "::"
                , stringify ! ( __jmpbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __jmp_buf_tag ) ) . __mask_was_saved as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __jmp_buf_tag ) , "::"
                , stringify ! ( __mask_was_saved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __jmp_buf_tag ) ) . __saved_mask as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __jmp_buf_tag ) , "::"
                , stringify ! ( __saved_mask ) ));
}
impl Clone for __jmp_buf_tag {
    fn clone(&self) -> Self { *self }
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag,
                      __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn errstart(elevel: ::std::os::raw::c_int,
                    filename: *const ::std::os::raw::c_char,
                    lineno: ::std::os::raw::c_int,
                    funcname: *const ::std::os::raw::c_char,
                    domain: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errmsg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errmsg_plural(fmt_singular: *const ::std::os::raw::c_char,
                         fmt_plural: *const ::std::os::raw::c_char,
                         n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_log_plural(fmt_singular: *const ::std::os::raw::c_char,
                                fmt_plural: *const ::std::os::raw::c_char,
                                n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_plural(fmt_singular: *const ::std::os::raw::c_char,
                            fmt_plural: *const ::std::os::raw::c_char,
                            n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errhint(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errcontext_msg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errhidestmt(hide_stmt: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errhidecontext(hide_ctx: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errfunction(funcname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn internalerrquery(query: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn err_generic_string(field: ::std::os::raw::c_int,
                              str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geterrcode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geterrposition() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn elog_start(filename: *const ::std::os::raw::c_char,
                      lineno: ::std::os::raw::c_int,
                      funcname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn elog_finish(elevel: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn pre_format_elog_string(errnumber: ::std::os::raw::c_int,
                                  domain: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn format_elog_string(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                 *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ErrorContextCallback() {
    assert_eq!(::std::mem::size_of::<ErrorContextCallback>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( ErrorContextCallback )
               ));
    assert_eq! (::std::mem::align_of::<ErrorContextCallback>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ErrorContextCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorContextCallback ) ) . previous as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorContextCallback )
                , "::" , stringify ! ( previous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorContextCallback ) ) . callback as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorContextCallback )
                , "::" , stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorContextCallback ) ) . arg as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorContextCallback )
                , "::" , stringify ! ( arg ) ));
}
impl Clone for ErrorContextCallback {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "error_context_stack"]
    pub static mut error_context_stack: *mut ErrorContextCallback;
}
extern "C" {
    #[link_name = "PG_exception_stack"]
    pub static mut PG_exception_stack: *mut sigjmp_buf;
}
#[repr(C)]
#[derive(Copy)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool_,
    pub output_to_client: bool_,
    pub show_funcname: bool_,
    pub hide_stmt: bool_,
    pub hide_ctx: bool_,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub message_id: *const ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut MemoryContextData,
}
#[test]
fn bindgen_test_layout_ErrorData() {
    assert_eq!(::std::mem::size_of::<ErrorData>() , 184usize , concat ! (
               "Size of: " , stringify ! ( ErrorData ) ));
    assert_eq! (::std::mem::align_of::<ErrorData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ErrorData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . elevel as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( elevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . output_to_server as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( output_to_server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . output_to_client as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( output_to_client ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . show_funcname as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( show_funcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . hide_stmt as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( hide_stmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . hide_ctx as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( hide_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . filename as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . lineno as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( lineno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . funcname as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( funcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . domain as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . context_domain as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( context_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . sqlerrcode as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( sqlerrcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . message as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . detail as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . detail_log as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( detail_log ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . hint as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( hint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . context as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . message_id as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( message_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . schema_name as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( schema_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . table_name as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( table_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . column_name as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( column_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . datatype_name as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( datatype_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . constraint_name as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( constraint_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . cursorpos as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( cursorpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . internalpos as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( internalpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . internalquery as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( internalquery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . saved_errno as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( saved_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorData ) ) . assoc_context as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorData ) , "::" ,
                stringify ! ( assoc_context ) ));
}
impl Clone for ErrorData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn EmitErrorReport();
}
extern "C" {
    pub fn CopyErrorData() -> *mut ErrorData;
}
extern "C" {
    pub fn FreeErrorData(edata: *mut ErrorData);
}
extern "C" {
    pub fn FlushErrorState();
}
extern "C" {
    pub fn ReThrowError(edata: *mut ErrorData);
}
extern "C" {
    pub fn ThrowErrorData(edata: *mut ErrorData);
}
extern "C" {
    pub fn pg_re_throw();
}
extern "C" {
    pub fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
}
pub type emit_log_hook_type =
    ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
extern "C" {
    #[link_name = "emit_log_hook"]
    pub static mut emit_log_hook: emit_log_hook_type;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PGErrorVerbosity {
    PGERROR_TERSE = 0,
    PGERROR_DEFAULT = 1,
    PGERROR_VERBOSE = 2,
}
extern "C" {
    #[link_name = "Log_error_verbosity"]
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "Log_line_prefix"]
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "Log_destination"]
    pub static mut Log_destination: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "Log_destination_string"]
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "syslog_sequence_numbers"]
    pub static mut syslog_sequence_numbers: bool_;
}
extern "C" {
    #[link_name = "syslog_split_messages"]
    pub static mut syslog_split_messages: bool_;
}
extern "C" {
    pub fn DebugFileOpen();
}
extern "C" {
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn in_error_recursion_trouble() -> bool_;
}
extern "C" {
    pub fn set_syslog_parameters(ident: *const ::std::os::raw::c_char,
                                 facility: ::std::os::raw::c_int);
}
extern "C" {
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
pub type MemoryContext = *mut MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut MemoryContextCallback,
}
#[test]
fn bindgen_test_layout_MemoryContextCallback() {
    assert_eq!(::std::mem::size_of::<MemoryContextCallback>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( MemoryContextCallback )
               ));
    assert_eq! (::std::mem::align_of::<MemoryContextCallback>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( MemoryContextCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MemoryContextCallback ) ) . func as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MemoryContextCallback )
                , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MemoryContextCallback ) ) . arg as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MemoryContextCallback )
                , "::" , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MemoryContextCallback ) ) . next as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MemoryContextCallback )
                , "::" , stringify ! ( next ) ));
}
impl Clone for MemoryContextCallback {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "CurrentMemoryContext"]
    pub static mut CurrentMemoryContext: MemoryContext;
}
extern "C" {
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextAllocExtended(context: MemoryContext, size: Size,
                                      flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn palloc_extended(size: Size, flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn repalloc(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn repalloc_huge(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextRegisterResetCallback(context: MemoryContext,
                                              cb: *mut MemoryContextCallback);
}
extern "C" {
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pstrdup(in_: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pnstrdup(in_: *const ::std::os::raw::c_char, len: Size)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pchomp(in_: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn psprintf(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pvsnprintf(buf: *mut ::std::os::raw::c_char, len: usize,
                      fmt: *const ::std::os::raw::c_char,
                      args: *mut __va_list_tag) -> usize;
}
#[repr(C)]
#[derive(Copy)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
#[test]
fn bindgen_test_layout_varatt_external() {
    assert_eq!(::std::mem::size_of::<varatt_external>() , 16usize , concat ! (
               "Size of: " , stringify ! ( varatt_external ) ));
    assert_eq! (::std::mem::align_of::<varatt_external>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( varatt_external ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const varatt_external ) ) . va_rawsize as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( varatt_external ) ,
                "::" , stringify ! ( va_rawsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const varatt_external ) ) . va_extsize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( varatt_external ) ,
                "::" , stringify ! ( va_extsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const varatt_external ) ) . va_valueid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( varatt_external ) ,
                "::" , stringify ! ( va_valueid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const varatt_external ) ) . va_toastrelid as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( varatt_external ) ,
                "::" , stringify ! ( va_toastrelid ) ));
}
impl Clone for varatt_external {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
#[test]
fn bindgen_test_layout_varatt_indirect() {
    assert_eq!(::std::mem::size_of::<varatt_indirect>() , 8usize , concat ! (
               "Size of: " , stringify ! ( varatt_indirect ) ));
    assert_eq! (::std::mem::align_of::<varatt_indirect>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( varatt_indirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const varatt_indirect ) ) . pointer as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( varatt_indirect ) ,
                "::" , stringify ! ( pointer ) ));
}
impl Clone for varatt_indirect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExpandedObjectHeader {
    pub vl_len_: int32,
    pub eoh_methods: *const ExpandedObjectMethods,
    pub eoh_context: MemoryContext,
    pub eoh_rw_ptr: [::std::os::raw::c_char; 10usize],
    pub eoh_ro_ptr: [::std::os::raw::c_char; 10usize],
}
#[test]
fn bindgen_test_layout_ExpandedObjectHeader() {
    assert_eq!(::std::mem::size_of::<ExpandedObjectHeader>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( ExpandedObjectHeader )
               ));
    assert_eq! (::std::mem::align_of::<ExpandedObjectHeader>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ExpandedObjectHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectHeader ) ) . vl_len_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectHeader )
                , "::" , stringify ! ( vl_len_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectHeader ) ) . eoh_methods as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectHeader )
                , "::" , stringify ! ( eoh_methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectHeader ) ) . eoh_context as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectHeader )
                , "::" , stringify ! ( eoh_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectHeader ) ) . eoh_rw_ptr as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectHeader )
                , "::" , stringify ! ( eoh_rw_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectHeader ) ) . eoh_ro_ptr as
                * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectHeader )
                , "::" , stringify ! ( eoh_ro_ptr ) ));
}
impl Clone for ExpandedObjectHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
#[test]
fn bindgen_test_layout_varatt_expanded() {
    assert_eq!(::std::mem::size_of::<varatt_expanded>() , 8usize , concat ! (
               "Size of: " , stringify ! ( varatt_expanded ) ));
    assert_eq! (::std::mem::align_of::<varatt_expanded>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( varatt_expanded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const varatt_expanded ) ) . eohptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( varatt_expanded ) ,
                "::" , stringify ! ( eohptr ) ));
}
impl Clone for varatt_expanded {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vartag_external {
    VARTAG_INDIRECT = 1,
    VARTAG_EXPANDED_RO = 2,
    VARTAG_EXPANDED_RW = 3,
    VARTAG_ONDISK = 18,
}
#[repr(C)]
pub struct varattrib_4b {
    pub va_4byte: __BindgenUnionField<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<varattrib_4b__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_4b__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<varattrib_4b__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( varattrib_4b__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<varattrib_4b__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( varattrib_4b__bindgen_ty_1 )
                ));
}
#[repr(C)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_4b__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<varattrib_4b__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( varattrib_4b__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<varattrib_4b__bindgen_ty_2>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( varattrib_4b__bindgen_ty_2 )
                ));
}
#[test]
fn bindgen_test_layout_varattrib_4b() {
    assert_eq!(::std::mem::size_of::<varattrib_4b>() , 8usize , concat ! (
               "Size of: " , stringify ! ( varattrib_4b ) ));
    assert_eq! (::std::mem::align_of::<varattrib_4b>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( varattrib_4b ) ));
}
#[repr(C)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_1b() {
    assert_eq!(::std::mem::size_of::<varattrib_1b>() , 1usize , concat ! (
               "Size of: " , stringify ! ( varattrib_1b ) ));
    assert_eq! (::std::mem::align_of::<varattrib_1b>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( varattrib_1b ) ));
}
#[repr(C)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_1b_e() {
    assert_eq!(::std::mem::size_of::<varattrib_1b_e>() , 2usize , concat ! (
               "Size of: " , stringify ! ( varattrib_1b_e ) ));
    assert_eq! (::std::mem::align_of::<varattrib_1b_e>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( varattrib_1b_e ) ));
}
pub type Datum = usize;
pub type DatumPtr = *mut Datum;
extern "C" {
    pub fn ExceptionalCondition(conditionName: *const ::std::os::raw::c_char,
                                errorType: *const ::std::os::raw::c_char,
                                fileName: *const ::std::os::raw::c_char,
                                lineNumber: ::std::os::raw::c_int);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ScanDirection {
    BackwardScanDirection = -1,
    NoMovementScanDirection = 0,
    ForwardScanDirection = 1,
}
pub type AttrNumber = int16;
pub type StrategyNumber = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Node {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_Node() {
    assert_eq!(::std::mem::size_of::<Node>() , 4usize , concat ! (
               "Size of: " , stringify ! ( Node ) ));
    assert_eq! (::std::mem::align_of::<Node>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Node ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Node ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for Node {
    fn clone(&self) -> Self { *self }
}
pub type fmNodePtr = *mut Node;
#[repr(C)]
#[derive(Copy)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: *mut List,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: bool_,
    pub aggvariadic: bool_,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Aggref() {
    assert_eq!(::std::mem::size_of::<Aggref>() , 88usize , concat ! (
               "Size of: " , stringify ! ( Aggref ) ));
    assert_eq! (::std::mem::align_of::<Aggref>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Aggref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . xpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggfnoid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggfnoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggtype as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggcollid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . inputcollid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( inputcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggtranstype as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggtranstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggargtypes as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggargtypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggdirectargs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggdirectargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . args as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggorder as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggorder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggdistinct as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggdistinct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggfilter as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggstar as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggstar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggvariadic as * const _ as
                usize } , 73usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggvariadic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggkind as * const _ as
                usize } , 74usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . agglevelsup as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( agglevelsup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . aggsplit as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( aggsplit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Aggref ) ) . location as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( Aggref ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for Aggref {
    fn clone(&self) -> Self { *self }
}
pub type fmAggrefPtr = *mut Aggref;
pub type fmExprContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Copy)]
pub struct StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StringInfoData() {
    assert_eq!(::std::mem::size_of::<StringInfoData>() , 24usize , concat ! (
               "Size of: " , stringify ! ( StringInfoData ) ));
    assert_eq! (::std::mem::align_of::<StringInfoData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( StringInfoData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StringInfoData ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( StringInfoData ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StringInfoData ) ) . len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( StringInfoData ) , "::"
                , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StringInfoData ) ) . maxlen as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( StringInfoData ) , "::"
                , stringify ! ( maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StringInfoData ) ) . cursor as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( StringInfoData ) , "::"
                , stringify ! ( cursor ) ));
}
impl Clone for StringInfoData {
    fn clone(&self) -> Self { *self }
}
pub type fmStringInfo = *mut StringInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool_,
    pub nargs: ::std::os::raw::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [bool_; 100usize],
}
#[test]
fn bindgen_test_layout_FunctionCallInfoData() {
    assert_eq!(::std::mem::size_of::<FunctionCallInfoData>() , 936usize ,
               concat ! ( "Size of: " , stringify ! ( FunctionCallInfoData )
               ));
    assert_eq! (::std::mem::align_of::<FunctionCallInfoData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FunctionCallInfoData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . flinfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( flinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . context as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . resultinfo as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( resultinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . fncollation as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( fncollation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . isnull as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( isnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . nargs as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( nargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . arg as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionCallInfoData ) ) . argnull as *
                const _ as usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionCallInfoData )
                , "::" , stringify ! ( argnull ) ));
}
impl Clone for FunctionCallInfoData {
    fn clone(&self) -> Self { *self }
}
pub type FunctionCallInfo = *mut FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<unsafe extern "C" fn(fcinfo: FunctionCallInfo)
                              -> Datum>;
#[repr(C)]
#[derive(Copy)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool_,
    pub fn_retset: bool_,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
#[test]
fn bindgen_test_layout_FmgrInfo() {
    assert_eq!(::std::mem::size_of::<FmgrInfo>() , 48usize , concat ! (
               "Size of: " , stringify ! ( FmgrInfo ) ));
    assert_eq! (::std::mem::align_of::<FmgrInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FmgrInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_oid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_nargs as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_nargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_strict as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_strict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_retset as * const _ as
                usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_retset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_stats as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_extra as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_mcxt as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_mcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FmgrInfo ) ) . fn_expr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FmgrInfo ) , "::" ,
                stringify ! ( fn_expr ) ));
}
impl Clone for FmgrInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
}
extern "C" {
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext);
}
extern "C" {
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext);
}
extern "C" {
    pub fn pg_detoast_datum(datum: *mut varlena) -> *mut varlena;
}
extern "C" {
    pub fn pg_detoast_datum_copy(datum: *mut varlena) -> *mut varlena;
}
extern "C" {
    pub fn pg_detoast_datum_slice(datum: *mut varlena, first: int32,
                                  count: int32) -> *mut varlena;
}
extern "C" {
    pub fn pg_detoast_datum_packed(datum: *mut varlena) -> *mut varlena;
}
#[repr(C)]
#[derive(Copy)]
pub struct Pg_finfo_record {
    pub api_version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Pg_finfo_record() {
    assert_eq!(::std::mem::size_of::<Pg_finfo_record>() , 4usize , concat ! (
               "Size of: " , stringify ! ( Pg_finfo_record ) ));
    assert_eq! (::std::mem::align_of::<Pg_finfo_record>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( Pg_finfo_record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_finfo_record ) ) . api_version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_finfo_record ) ,
                "::" , stringify ! ( api_version ) ));
}
impl Clone for Pg_finfo_record {
    fn clone(&self) -> Self { *self }
}
pub type PGFInfoFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Copy)]
pub struct Pg_magic_struct {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Pg_magic_struct() {
    assert_eq!(::std::mem::size_of::<Pg_magic_struct>() , 28usize , concat ! (
               "Size of: " , stringify ! ( Pg_magic_struct ) ));
    assert_eq! (::std::mem::align_of::<Pg_magic_struct>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( Pg_magic_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . version as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . funcmaxargs as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( funcmaxargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . indexmaxkeys as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( indexmaxkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . namedatalen as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( namedatalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . float4byval as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( float4byval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Pg_magic_struct ) ) . float8byval as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Pg_magic_struct ) ,
                "::" , stringify ! ( float8byval ) ));
}
impl Clone for Pg_magic_struct {
    fn clone(&self) -> Self { *self }
}
pub type PGModuleMagicFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const Pg_magic_struct>;
extern "C" {
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
}
extern "C" {
    pub fn CallerFInfoFunctionCall1(func: PGFunction, flinfo: *mut FmgrInfo,
                                    collation: Oid, arg1: Datum) -> Datum;
}
extern "C" {
    pub fn CallerFInfoFunctionCall2(func: PGFunction, flinfo: *mut FmgrInfo,
                                    collation: Oid, arg1: Datum, arg2: Datum)
     -> Datum;
}
extern "C" {
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
}
extern "C" {
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
}
extern "C" {
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
}
extern "C" {
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
}
extern "C" {
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo,
                             str: *mut ::std::os::raw::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn OidInputFunctionCall(functionId: Oid,
                                str: *mut ::std::os::raw::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
}
extern "C" {
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
}
extern "C" {
    pub fn fetch_finfo_record(filehandle: *mut ::std::os::raw::c_void,
                              funcname: *const ::std::os::raw::c_char)
     -> *const Pg_finfo_record;
}
extern "C" {
    pub fn clear_external_function_hash(filehandle:
                                            *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char)
     -> Oid;
}
extern "C" {
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
}
extern "C" {
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo,
                               argnum: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn get_call_expr_argtype(expr: fmNodePtr,
                                 argnum: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn get_call_expr_arg_stable(expr: fmNodePtr,
                                    argnum: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> bool_;
}
extern "C" {
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> bool_;
}
extern "C" {
    #[link_name = "Dynamic_library_path"]
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn load_external_function(filename: *const ::std::os::raw::c_char,
                                  funcname: *const ::std::os::raw::c_char,
                                  signalNotFound: bool_,
                                  filehandle:
                                      *mut *mut ::std::os::raw::c_void)
     -> PGFunction;
}
extern "C" {
    pub fn lookup_external_function(filehandle: *mut ::std::os::raw::c_void,
                                    funcname: *const ::std::os::raw::c_char)
     -> PGFunction;
}
extern "C" {
    pub fn load_file(filename: *const ::std::os::raw::c_char,
                     restricted: bool_);
}
extern "C" {
    pub fn find_rendezvous_variable(varName: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EstimateLibraryStateSpace() -> Size;
}
extern "C" {
    pub fn SerializeLibraryState(maxsize: Size,
                                 start_address: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn RestoreLibraryState(start_address: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
}
extern "C" {
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
}
extern "C" {
    pub fn AggRegisterCallback(fcinfo: FunctionCallInfo,
                               func: fmExprContextCallbackFunction,
                               arg: Datum);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FmgrHookEventType { FHET_START = 0, FHET_END = 1, FHET_ABORT = 2, }
pub type needs_fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(fn_oid: Oid) -> bool_>;
pub type fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(event: FmgrHookEventType,
                                               flinfo: *mut FmgrInfo,
                                               arg: *mut Datum)>;
extern "C" {
    #[link_name = "needs_fmgr_hook"]
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
}
extern "C" {
    #[link_name = "fmgr_hook"]
    pub static mut fmgr_hook: fmgr_hook_type;
}
extern "C" {
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
#[test]
fn bindgen_test_layout_ScanKeyData() {
    assert_eq!(::std::mem::size_of::<ScanKeyData>() , 72usize , concat ! (
               "Size of: " , stringify ! ( ScanKeyData ) ));
    assert_eq! (::std::mem::align_of::<ScanKeyData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ScanKeyData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_attno as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_attno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_strategy as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_subtype as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_subtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_collation as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanKeyData ) ) . sk_argument as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanKeyData ) , "::" ,
                stringify ! ( sk_argument ) ));
}
impl Clone for ScanKeyData {
    fn clone(&self) -> Self { *self }
}
pub type ScanKey = *mut ScanKeyData;
extern "C" {
    pub fn ScanKeyInit(entry: ScanKey, attributeNumber: AttrNumber,
                       strategy: StrategyNumber, procedure: RegProcedure,
                       argument: Datum);
}
extern "C" {
    pub fn ScanKeyEntryInitialize(entry: ScanKey,
                                  flags: ::std::os::raw::c_int,
                                  attributeNumber: AttrNumber,
                                  strategy: StrategyNumber, subtype: Oid,
                                  collation: Oid, procedure: RegProcedure,
                                  argument: Datum);
}
extern "C" {
    pub fn ScanKeyEntryInitializeWithInfo(entry: ScanKey,
                                          flags: ::std::os::raw::c_int,
                                          attributeNumber: AttrNumber,
                                          strategy: StrategyNumber,
                                          subtype: Oid, collation: Oid,
                                          finfo: *mut FmgrInfo,
                                          argument: Datum);
}
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
#[test]
fn bindgen_test_layout_BlockIdData() {
    assert_eq!(::std::mem::size_of::<BlockIdData>() , 4usize , concat ! (
               "Size of: " , stringify ! ( BlockIdData ) ));
    assert_eq! (::std::mem::align_of::<BlockIdData>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( BlockIdData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockIdData ) ) . bi_hi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockIdData ) , "::" ,
                stringify ! ( bi_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockIdData ) ) . bi_lo as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockIdData ) , "::" ,
                stringify ! ( bi_lo ) ));
}
impl Clone for BlockIdData {
    fn clone(&self) -> Self { *self }
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Copy)]
pub struct ItemIdData {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_ItemIdData() {
    assert_eq!(::std::mem::size_of::<ItemIdData>() , 4usize , concat ! (
               "Size of: " , stringify ! ( ItemIdData ) ));
    assert_eq! (::std::mem::align_of::<ItemIdData>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ItemIdData ) ));
}
impl Clone for ItemIdData {
    fn clone(&self) -> Self { *self }
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32767u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32767u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn lp_flags(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 98304u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 98304u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn lp_len(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294836224u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294836224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(lp_off: ::std::os::raw::c_uint,
                          lp_flags: ::std::os::raw::c_uint,
                          lp_len: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((lp_off as u32 as u32) << 0usize) & (32767u64 as u32))
              } | ((lp_flags as u32 as u32) << 15usize) & (98304u64 as u32))
         } | ((lp_len as u32 as u32) << 17usize) & (4294836224u64 as u32))
    }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed)]
#[derive(Copy)]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
#[test]
fn bindgen_test_layout_ItemPointerData() {
    assert_eq!(::std::mem::size_of::<ItemPointerData>() , 6usize , concat ! (
               "Size of: " , stringify ! ( ItemPointerData ) ));
    assert_eq! (::std::mem::align_of::<ItemPointerData>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( ItemPointerData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ItemPointerData ) ) . ip_blkid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ItemPointerData ) ,
                "::" , stringify ! ( ip_blkid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ItemPointerData ) ) . ip_posid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ItemPointerData ) ,
                "::" , stringify ! ( ip_posid ) ));
}
impl Clone for ItemPointerData {
    fn clone(&self) -> Self { *self }
}
pub type ItemPointer = *mut ItemPointerData;
extern "C" {
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> bool_;
}
extern "C" {
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
}
#[repr(C)]
#[derive(Copy)]
pub struct pg_atomic_flag {
    pub value: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pg_atomic_flag() {
    assert_eq!(::std::mem::size_of::<pg_atomic_flag>() , 1usize , concat ! (
               "Size of: " , stringify ! ( pg_atomic_flag ) ));
    assert_eq! (::std::mem::align_of::<pg_atomic_flag>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pg_atomic_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_atomic_flag ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_atomic_flag ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for pg_atomic_flag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[test]
fn bindgen_test_layout_pg_atomic_uint32() {
    assert_eq!(::std::mem::size_of::<pg_atomic_uint32>() , 4usize , concat ! (
               "Size of: " , stringify ! ( pg_atomic_uint32 ) ));
    assert_eq! (::std::mem::align_of::<pg_atomic_uint32>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( pg_atomic_uint32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_atomic_uint32 ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_atomic_uint32 ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for pg_atomic_uint32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
#[test]
fn bindgen_test_layout_pg_atomic_uint64() {
    assert_eq!(::std::mem::size_of::<pg_atomic_uint64>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pg_atomic_uint64 ) ));
    assert_eq! (::std::mem::align_of::<pg_atomic_uint64>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pg_atomic_uint64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_atomic_uint64 ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_atomic_uint64 ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for pg_atomic_uint64 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "dynamic_shared_memory_type"]
    pub static mut dynamic_shared_memory_type: ::std::os::raw::c_int;
}
pub type dsm_handle = uint32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dsm_op {
    DSM_OP_CREATE = 0,
    DSM_OP_ATTACH = 1,
    DSM_OP_DETACH = 2,
    DSM_OP_RESIZE = 3,
    DSM_OP_DESTROY = 4,
}
extern "C" {
    pub fn dsm_impl_op(op: dsm_op, handle: dsm_handle, request_size: Size,
                       impl_private: *mut *mut ::std::os::raw::c_void,
                       mapped_address: *mut *mut ::std::os::raw::c_void,
                       mapped_size: *mut Size, elevel: ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn dsm_impl_can_resize() -> bool_;
}
extern "C" {
    pub fn dsm_impl_pin_segment(handle: dsm_handle,
                                impl_private: *mut ::std::os::raw::c_void,
                                impl_private_pm_handle:
                                    *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dsm_impl_unpin_segment(handle: dsm_handle,
                                  impl_private:
                                      *mut *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsm_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGShmemHeader {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dsm_cleanup_using_control_segment(old_control_handle: dsm_handle);
}
extern "C" {
    pub fn dsm_postmaster_startup(arg1: *mut PGShmemHeader);
}
extern "C" {
    pub fn dsm_backend_shutdown();
}
extern "C" {
    pub fn dsm_detach_all();
}
extern "C" {
    pub fn dsm_create(size: Size, flags: ::std::os::raw::c_int)
     -> *mut dsm_segment;
}
extern "C" {
    pub fn dsm_attach(h: dsm_handle) -> *mut dsm_segment;
}
extern "C" {
    pub fn dsm_resize(seg: *mut dsm_segment, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsm_remap(seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsm_detach(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_pin_mapping(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_unpin_mapping(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_pin_segment(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_unpin_segment(h: dsm_handle);
}
extern "C" {
    pub fn dsm_find_mapping(h: dsm_handle) -> *mut dsm_segment;
}
extern "C" {
    pub fn dsm_segment_address(seg: *mut dsm_segment)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsm_segment_map_length(seg: *mut dsm_segment) -> Size;
}
extern "C" {
    pub fn dsm_segment_handle(seg: *mut dsm_segment) -> dsm_handle;
}
pub type on_dsm_detach_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dsm_segment,
                                               arg: Datum)>;
extern "C" {
    pub fn on_dsm_detach(seg: *mut dsm_segment,
                         function: on_dsm_detach_callback, arg: Datum);
}
extern "C" {
    pub fn cancel_on_dsm_detach(seg: *mut dsm_segment,
                                function: on_dsm_detach_callback, arg: Datum);
}
extern "C" {
    pub fn reset_on_dsm_detach();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_area {
    _unused: [u8; 0],
}
pub type dsa_pointer = uint64;
pub type dsa_pointer_atomic = pg_atomic_uint64;
pub type dsa_handle = dsm_handle;
extern "C" {
    pub fn dsa_startup();
}
extern "C" {
    pub fn dsa_create(tranche_id: ::std::os::raw::c_int) -> *mut dsa_area;
}
extern "C" {
    pub fn dsa_create_in_place(place: *mut ::std::os::raw::c_void, size: Size,
                               tranche_id: ::std::os::raw::c_int,
                               segment: *mut dsm_segment) -> *mut dsa_area;
}
extern "C" {
    pub fn dsa_attach(handle: dsa_handle) -> *mut dsa_area;
}
extern "C" {
    pub fn dsa_attach_in_place(place: *mut ::std::os::raw::c_void,
                               segment: *mut dsm_segment) -> *mut dsa_area;
}
extern "C" {
    pub fn dsa_release_in_place(place: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dsa_on_dsm_detach_release_in_place(arg1: *mut dsm_segment,
                                              arg2: Datum);
}
extern "C" {
    pub fn dsa_on_shmem_exit_release_in_place(arg1: ::std::os::raw::c_int,
                                              arg2: Datum);
}
extern "C" {
    pub fn dsa_pin_mapping(area: *mut dsa_area);
}
extern "C" {
    pub fn dsa_detach(area: *mut dsa_area);
}
extern "C" {
    pub fn dsa_pin(area: *mut dsa_area);
}
extern "C" {
    pub fn dsa_unpin(area: *mut dsa_area);
}
extern "C" {
    pub fn dsa_set_size_limit(area: *mut dsa_area, limit: Size);
}
extern "C" {
    pub fn dsa_minimum_size() -> Size;
}
extern "C" {
    pub fn dsa_get_handle(area: *mut dsa_area) -> dsa_handle;
}
extern "C" {
    pub fn dsa_allocate_extended(area: *mut dsa_area, size: Size,
                                 flags: ::std::os::raw::c_int) -> dsa_pointer;
}
extern "C" {
    pub fn dsa_free(area: *mut dsa_area, dp: dsa_pointer);
}
extern "C" {
    pub fn dsa_get_address(area: *mut dsa_area, dp: dsa_pointer)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsa_trim(area: *mut dsa_area);
}
extern "C" {
    pub fn dsa_dump(area: *mut dsa_area);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIDBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMSharedIterator {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool_,
    pub offsets: __IncompleteArrayField<OffsetNumber>,
}
#[test]
fn bindgen_test_layout_TBMIterateResult() {
    assert_eq!(::std::mem::size_of::<TBMIterateResult>() , 12usize , concat !
               ( "Size of: " , stringify ! ( TBMIterateResult ) ));
    assert_eq! (::std::mem::align_of::<TBMIterateResult>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TBMIterateResult ) ));
}
extern "C" {
    pub fn tbm_create(maxbytes: ::std::os::raw::c_long, dsa: *mut dsa_area)
     -> *mut TIDBitmap;
}
extern "C" {
    pub fn tbm_free(tbm: *mut TIDBitmap);
}
extern "C" {
    pub fn tbm_free_shared_area(dsa: *mut dsa_area, dp: dsa_pointer);
}
extern "C" {
    pub fn tbm_add_tuples(tbm: *mut TIDBitmap, tids: ItemPointer,
                          ntids: ::std::os::raw::c_int, recheck: bool_);
}
extern "C" {
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber);
}
extern "C" {
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap);
}
extern "C" {
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap);
}
extern "C" {
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> bool_;
}
extern "C" {
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
}
extern "C" {
    pub fn tbm_prepare_shared_iterate(tbm: *mut TIDBitmap) -> dsa_pointer;
}
extern "C" {
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
}
extern "C" {
    pub fn tbm_shared_iterate(iterator: *mut TBMSharedIterator)
     -> *mut TBMIterateResult;
}
extern "C" {
    pub fn tbm_end_iterate(iterator: *mut TBMIterator);
}
extern "C" {
    pub fn tbm_end_shared_iterate(iterator: *mut TBMSharedIterator);
}
extern "C" {
    pub fn tbm_attach_shared_iterate(dsa: *mut dsa_area, dp: dsa_pointer)
     -> *mut TBMSharedIterator;
}
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
#[test]
fn bindgen_test_layout_xl_standby_lock() {
    assert_eq!(::std::mem::size_of::<xl_standby_lock>() , 12usize , concat ! (
               "Size of: " , stringify ! ( xl_standby_lock ) ));
    assert_eq! (::std::mem::align_of::<xl_standby_lock>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( xl_standby_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xl_standby_lock ) ) . xid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xl_standby_lock ) ,
                "::" , stringify ! ( xid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xl_standby_lock ) ) . dbOid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xl_standby_lock ) ,
                "::" , stringify ! ( dbOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xl_standby_lock ) ) . relOid as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xl_standby_lock ) ,
                "::" , stringify ! ( relOid ) ));
}
impl Clone for xl_standby_lock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: bool_,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: bool_,
    pub atthasdef: bool_,
    pub attidentity: ::std::os::raw::c_char,
    pub attisdropped: bool_,
    pub attislocal: bool_,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
#[test]
fn bindgen_test_layout_FormData_pg_attribute() {
    assert_eq!(::std::mem::size_of::<FormData_pg_attribute>() , 108usize ,
               concat ! ( "Size of: " , stringify ! ( FormData_pg_attribute )
               ));
    assert_eq! (::std::mem::align_of::<FormData_pg_attribute>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( FormData_pg_attribute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attrelid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attrelid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attname as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . atttypid as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( atttypid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attstattarget
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attstattarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attlen as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attnum as *
                const _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attndims as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attndims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attcacheoff
                as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attcacheoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . atttypmod as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( atttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attbyval as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attbyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attstorage as
                * const _ as usize } , 93usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attstorage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attalign as *
                const _ as usize } , 94usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attnotnull as
                * const _ as usize } , 95usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attnotnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . atthasdef as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( atthasdef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attidentity
                as * const _ as usize } , 97usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attidentity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attisdropped
                as * const _ as usize } , 98usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attisdropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attislocal as
                * const _ as usize } , 99usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attislocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attinhcount
                as * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attinhcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_attribute ) ) . attcollation
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_attribute )
                , "::" , stringify ! ( attcollation ) ));
}
impl Clone for FormData_pg_attribute {
    fn clone(&self) -> Self { *self }
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NodeTag {
    T_Invalid = 0,
    T_IndexInfo = 1,
    T_ExprContext = 2,
    T_ProjectionInfo = 3,
    T_JunkFilter = 4,
    T_ResultRelInfo = 5,
    T_EState = 6,
    T_TupleTableSlot = 7,
    T_Plan = 8,
    T_Result = 9,
    T_ProjectSet = 10,
    T_ModifyTable = 11,
    T_Append = 12,
    T_MergeAppend = 13,
    T_RecursiveUnion = 14,
    T_BitmapAnd = 15,
    T_BitmapOr = 16,
    T_Scan = 17,
    T_SeqScan = 18,
    T_SampleScan = 19,
    T_IndexScan = 20,
    T_IndexOnlyScan = 21,
    T_BitmapIndexScan = 22,
    T_BitmapHeapScan = 23,
    T_TidScan = 24,
    T_SubqueryScan = 25,
    T_FunctionScan = 26,
    T_ValuesScan = 27,
    T_TableFuncScan = 28,
    T_CteScan = 29,
    T_NamedTuplestoreScan = 30,
    T_WorkTableScan = 31,
    T_ForeignScan = 32,
    T_CustomScan = 33,
    T_Join = 34,
    T_NestLoop = 35,
    T_MergeJoin = 36,
    T_HashJoin = 37,
    T_Material = 38,
    T_Sort = 39,
    T_Group = 40,
    T_Agg = 41,
    T_WindowAgg = 42,
    T_Unique = 43,
    T_Gather = 44,
    T_GatherMerge = 45,
    T_Hash = 46,
    T_SetOp = 47,
    T_LockRows = 48,
    T_Limit = 49,
    T_NestLoopParam = 50,
    T_PlanRowMark = 51,
    T_PlanInvalItem = 52,
    T_PlanState = 53,
    T_ResultState = 54,
    T_ProjectSetState = 55,
    T_ModifyTableState = 56,
    T_AppendState = 57,
    T_MergeAppendState = 58,
    T_RecursiveUnionState = 59,
    T_BitmapAndState = 60,
    T_BitmapOrState = 61,
    T_ScanState = 62,
    T_SeqScanState = 63,
    T_SampleScanState = 64,
    T_IndexScanState = 65,
    T_IndexOnlyScanState = 66,
    T_BitmapIndexScanState = 67,
    T_BitmapHeapScanState = 68,
    T_TidScanState = 69,
    T_SubqueryScanState = 70,
    T_FunctionScanState = 71,
    T_TableFuncScanState = 72,
    T_ValuesScanState = 73,
    T_CteScanState = 74,
    T_NamedTuplestoreScanState = 75,
    T_WorkTableScanState = 76,
    T_ForeignScanState = 77,
    T_CustomScanState = 78,
    T_JoinState = 79,
    T_NestLoopState = 80,
    T_MergeJoinState = 81,
    T_HashJoinState = 82,
    T_MaterialState = 83,
    T_SortState = 84,
    T_GroupState = 85,
    T_AggState = 86,
    T_WindowAggState = 87,
    T_UniqueState = 88,
    T_GatherState = 89,
    T_GatherMergeState = 90,
    T_HashState = 91,
    T_SetOpState = 92,
    T_LockRowsState = 93,
    T_LimitState = 94,
    T_Alias = 95,
    T_RangeVar = 96,
    T_TableFunc = 97,
    T_Expr = 98,
    T_Var = 99,
    T_Const = 100,
    T_Param = 101,
    T_Aggref = 102,
    T_GroupingFunc = 103,
    T_WindowFunc = 104,
    T_ArrayRef = 105,
    T_FuncExpr = 106,
    T_NamedArgExpr = 107,
    T_OpExpr = 108,
    T_DistinctExpr = 109,
    T_NullIfExpr = 110,
    T_ScalarArrayOpExpr = 111,
    T_BoolExpr = 112,
    T_SubLink = 113,
    T_SubPlan = 114,
    T_AlternativeSubPlan = 115,
    T_FieldSelect = 116,
    T_FieldStore = 117,
    T_RelabelType = 118,
    T_CoerceViaIO = 119,
    T_ArrayCoerceExpr = 120,
    T_ConvertRowtypeExpr = 121,
    T_CollateExpr = 122,
    T_CaseExpr = 123,
    T_CaseWhen = 124,
    T_CaseTestExpr = 125,
    T_ArrayExpr = 126,
    T_RowExpr = 127,
    T_RowCompareExpr = 128,
    T_CoalesceExpr = 129,
    T_MinMaxExpr = 130,
    T_SQLValueFunction = 131,
    T_XmlExpr = 132,
    T_NullTest = 133,
    T_BooleanTest = 134,
    T_CoerceToDomain = 135,
    T_CoerceToDomainValue = 136,
    T_SetToDefault = 137,
    T_CurrentOfExpr = 138,
    T_NextValueExpr = 139,
    T_InferenceElem = 140,
    T_TargetEntry = 141,
    T_RangeTblRef = 142,
    T_JoinExpr = 143,
    T_FromExpr = 144,
    T_OnConflictExpr = 145,
    T_IntoClause = 146,
    T_ExprState = 147,
    T_AggrefExprState = 148,
    T_WindowFuncExprState = 149,
    T_SetExprState = 150,
    T_SubPlanState = 151,
    T_AlternativeSubPlanState = 152,
    T_DomainConstraintState = 153,
    T_PlannerInfo = 154,
    T_PlannerGlobal = 155,
    T_RelOptInfo = 156,
    T_IndexOptInfo = 157,
    T_ForeignKeyOptInfo = 158,
    T_ParamPathInfo = 159,
    T_Path = 160,
    T_IndexPath = 161,
    T_BitmapHeapPath = 162,
    T_BitmapAndPath = 163,
    T_BitmapOrPath = 164,
    T_TidPath = 165,
    T_SubqueryScanPath = 166,
    T_ForeignPath = 167,
    T_CustomPath = 168,
    T_NestPath = 169,
    T_MergePath = 170,
    T_HashPath = 171,
    T_AppendPath = 172,
    T_MergeAppendPath = 173,
    T_ResultPath = 174,
    T_MaterialPath = 175,
    T_UniquePath = 176,
    T_GatherPath = 177,
    T_GatherMergePath = 178,
    T_ProjectionPath = 179,
    T_ProjectSetPath = 180,
    T_SortPath = 181,
    T_GroupPath = 182,
    T_UpperUniquePath = 183,
    T_AggPath = 184,
    T_GroupingSetsPath = 185,
    T_MinMaxAggPath = 186,
    T_WindowAggPath = 187,
    T_SetOpPath = 188,
    T_RecursiveUnionPath = 189,
    T_LockRowsPath = 190,
    T_ModifyTablePath = 191,
    T_LimitPath = 192,
    T_EquivalenceClass = 193,
    T_EquivalenceMember = 194,
    T_PathKey = 195,
    T_PathTarget = 196,
    T_RestrictInfo = 197,
    T_PlaceHolderVar = 198,
    T_SpecialJoinInfo = 199,
    T_AppendRelInfo = 200,
    T_PartitionedChildRelInfo = 201,
    T_PlaceHolderInfo = 202,
    T_MinMaxAggInfo = 203,
    T_PlannerParamItem = 204,
    T_RollupData = 205,
    T_GroupingSetData = 206,
    T_StatisticExtInfo = 207,
    T_MemoryContext = 208,
    T_AllocSetContext = 209,
    T_SlabContext = 210,
    T_Value = 211,
    T_Integer = 212,
    T_Float = 213,
    T_String = 214,
    T_BitString = 215,
    T_Null = 216,
    T_List = 217,
    T_IntList = 218,
    T_OidList = 219,
    T_ExtensibleNode = 220,
    T_RawStmt = 221,
    T_Query = 222,
    T_PlannedStmt = 223,
    T_InsertStmt = 224,
    T_DeleteStmt = 225,
    T_UpdateStmt = 226,
    T_SelectStmt = 227,
    T_AlterTableStmt = 228,
    T_AlterTableCmd = 229,
    T_AlterDomainStmt = 230,
    T_SetOperationStmt = 231,
    T_GrantStmt = 232,
    T_GrantRoleStmt = 233,
    T_AlterDefaultPrivilegesStmt = 234,
    T_ClosePortalStmt = 235,
    T_ClusterStmt = 236,
    T_CopyStmt = 237,
    T_CreateStmt = 238,
    T_DefineStmt = 239,
    T_DropStmt = 240,
    T_TruncateStmt = 241,
    T_CommentStmt = 242,
    T_FetchStmt = 243,
    T_IndexStmt = 244,
    T_CreateFunctionStmt = 245,
    T_AlterFunctionStmt = 246,
    T_DoStmt = 247,
    T_RenameStmt = 248,
    T_RuleStmt = 249,
    T_NotifyStmt = 250,
    T_ListenStmt = 251,
    T_UnlistenStmt = 252,
    T_TransactionStmt = 253,
    T_ViewStmt = 254,
    T_LoadStmt = 255,
    T_CreateDomainStmt = 256,
    T_CreatedbStmt = 257,
    T_DropdbStmt = 258,
    T_VacuumStmt = 259,
    T_ExplainStmt = 260,
    T_CreateTableAsStmt = 261,
    T_CreateSeqStmt = 262,
    T_AlterSeqStmt = 263,
    T_VariableSetStmt = 264,
    T_VariableShowStmt = 265,
    T_DiscardStmt = 266,
    T_CreateTrigStmt = 267,
    T_CreatePLangStmt = 268,
    T_CreateRoleStmt = 269,
    T_AlterRoleStmt = 270,
    T_DropRoleStmt = 271,
    T_LockStmt = 272,
    T_ConstraintsSetStmt = 273,
    T_ReindexStmt = 274,
    T_CheckPointStmt = 275,
    T_CreateSchemaStmt = 276,
    T_AlterDatabaseStmt = 277,
    T_AlterDatabaseSetStmt = 278,
    T_AlterRoleSetStmt = 279,
    T_CreateConversionStmt = 280,
    T_CreateCastStmt = 281,
    T_CreateOpClassStmt = 282,
    T_CreateOpFamilyStmt = 283,
    T_AlterOpFamilyStmt = 284,
    T_PrepareStmt = 285,
    T_ExecuteStmt = 286,
    T_DeallocateStmt = 287,
    T_DeclareCursorStmt = 288,
    T_CreateTableSpaceStmt = 289,
    T_DropTableSpaceStmt = 290,
    T_AlterObjectDependsStmt = 291,
    T_AlterObjectSchemaStmt = 292,
    T_AlterOwnerStmt = 293,
    T_AlterOperatorStmt = 294,
    T_DropOwnedStmt = 295,
    T_ReassignOwnedStmt = 296,
    T_CompositeTypeStmt = 297,
    T_CreateEnumStmt = 298,
    T_CreateRangeStmt = 299,
    T_AlterEnumStmt = 300,
    T_AlterTSDictionaryStmt = 301,
    T_AlterTSConfigurationStmt = 302,
    T_CreateFdwStmt = 303,
    T_AlterFdwStmt = 304,
    T_CreateForeignServerStmt = 305,
    T_AlterForeignServerStmt = 306,
    T_CreateUserMappingStmt = 307,
    T_AlterUserMappingStmt = 308,
    T_DropUserMappingStmt = 309,
    T_AlterTableSpaceOptionsStmt = 310,
    T_AlterTableMoveAllStmt = 311,
    T_SecLabelStmt = 312,
    T_CreateForeignTableStmt = 313,
    T_ImportForeignSchemaStmt = 314,
    T_CreateExtensionStmt = 315,
    T_AlterExtensionStmt = 316,
    T_AlterExtensionContentsStmt = 317,
    T_CreateEventTrigStmt = 318,
    T_AlterEventTrigStmt = 319,
    T_RefreshMatViewStmt = 320,
    T_ReplicaIdentityStmt = 321,
    T_AlterSystemStmt = 322,
    T_CreatePolicyStmt = 323,
    T_AlterPolicyStmt = 324,
    T_CreateTransformStmt = 325,
    T_CreateAmStmt = 326,
    T_CreatePublicationStmt = 327,
    T_AlterPublicationStmt = 328,
    T_CreateSubscriptionStmt = 329,
    T_AlterSubscriptionStmt = 330,
    T_DropSubscriptionStmt = 331,
    T_CreateStatsStmt = 332,
    T_AlterCollationStmt = 333,
    T_A_Expr = 334,
    T_ColumnRef = 335,
    T_ParamRef = 336,
    T_A_Const = 337,
    T_FuncCall = 338,
    T_A_Star = 339,
    T_A_Indices = 340,
    T_A_Indirection = 341,
    T_A_ArrayExpr = 342,
    T_ResTarget = 343,
    T_MultiAssignRef = 344,
    T_TypeCast = 345,
    T_CollateClause = 346,
    T_SortBy = 347,
    T_WindowDef = 348,
    T_RangeSubselect = 349,
    T_RangeFunction = 350,
    T_RangeTableSample = 351,
    T_RangeTableFunc = 352,
    T_RangeTableFuncCol = 353,
    T_TypeName = 354,
    T_ColumnDef = 355,
    T_IndexElem = 356,
    T_Constraint = 357,
    T_DefElem = 358,
    T_RangeTblEntry = 359,
    T_RangeTblFunction = 360,
    T_TableSampleClause = 361,
    T_WithCheckOption = 362,
    T_SortGroupClause = 363,
    T_GroupingSet = 364,
    T_WindowClause = 365,
    T_ObjectWithArgs = 366,
    T_AccessPriv = 367,
    T_CreateOpClassItem = 368,
    T_TableLikeClause = 369,
    T_FunctionParameter = 370,
    T_LockingClause = 371,
    T_RowMarkClause = 372,
    T_XmlSerialize = 373,
    T_WithClause = 374,
    T_InferClause = 375,
    T_OnConflictClause = 376,
    T_CommonTableExpr = 377,
    T_RoleSpec = 378,
    T_TriggerTransition = 379,
    T_PartitionElem = 380,
    T_PartitionSpec = 381,
    T_PartitionBoundSpec = 382,
    T_PartitionRangeDatum = 383,
    T_PartitionCmd = 384,
    T_IdentifySystemCmd = 385,
    T_BaseBackupCmd = 386,
    T_CreateReplicationSlotCmd = 387,
    T_DropReplicationSlotCmd = 388,
    T_StartReplicationCmd = 389,
    T_TimeLineHistoryCmd = 390,
    T_SQLCmd = 391,
    T_TriggerData = 392,
    T_EventTriggerData = 393,
    T_ReturnSetInfo = 394,
    T_WindowObjectData = 395,
    T_TIDBitmap = 396,
    T_InlineCodeBlock = 397,
    T_FdwRoutine = 398,
    T_IndexAmRoutine = 399,
    T_TsmRoutine = 400,
    T_ForeignKeyCacheInfo = 401,
}
#[repr(C)]
pub struct Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: __IncompleteArrayField<bitmapword>,
}
#[test]
fn bindgen_test_layout_Bitmapset() {
    assert_eq!(::std::mem::size_of::<Bitmapset>() , 4usize , concat ! (
               "Size of: " , stringify ! ( Bitmapset ) ));
    assert_eq! (::std::mem::align_of::<Bitmapset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Bitmapset ) ));
}
extern "C" {
    pub fn outNode(str: *mut StringInfoData,
                   obj: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn outToken(str: *mut StringInfoData,
                    s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn outBitmapset(str: *mut StringInfoData, bms: *const Bitmapset);
}
extern "C" {
    pub fn outDatum(str: *mut StringInfoData, value: usize,
                    typlen: ::std::os::raw::c_int, typbyval: bool_);
}
extern "C" {
    pub fn nodeToString(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bmsToString(bms: *const Bitmapset) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringToNode(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn readBitmapset() -> *mut Bitmapset;
}
extern "C" {
    pub fn readDatum(typbyval: bool_) -> usize;
}
extern "C" {
    pub fn readBoolCols(numCols: ::std::os::raw::c_int) -> *mut bool_;
}
extern "C" {
    pub fn readIntCols(numCols: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn readOidCols(numCols: ::std::os::raw::c_int) -> *mut Oid;
}
extern "C" {
    pub fn readAttrNumberCols(numCols: ::std::os::raw::c_int) -> *mut int16;
}
extern "C" {
    pub fn copyObjectImpl(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn equal(a: *const ::std::os::raw::c_void,
                 b: *const ::std::os::raw::c_void) -> bool_;
}
pub type Selectivity = f64;
pub type Cost = f64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CmdType {
    CMD_UNKNOWN = 0,
    CMD_SELECT = 1,
    CMD_UPDATE = 2,
    CMD_INSERT = 3,
    CMD_DELETE = 4,
    CMD_UTILITY = 5,
    CMD_NOTHING = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JoinType {
    JOIN_INNER = 0,
    JOIN_LEFT = 1,
    JOIN_FULL = 2,
    JOIN_RIGHT = 3,
    JOIN_SEMI = 4,
    JOIN_ANTI = 5,
    JOIN_UNIQUE_OUTER = 6,
    JOIN_UNIQUE_INNER = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AggStrategy {
    AGG_PLAIN = 0,
    AGG_SORTED = 1,
    AGG_HASHED = 2,
    AGG_MIXED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AggSplit {
    AGGSPLIT_SIMPLE = 0,
    AGGSPLIT_INITIAL_SERIAL = 6,
    AGGSPLIT_FINAL_DESERIAL = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetOpCmd {
    SETOPCMD_INTERSECT = 0,
    SETOPCMD_INTERSECT_ALL = 1,
    SETOPCMD_EXCEPT = 2,
    SETOPCMD_EXCEPT_ALL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetOpStrategy { SETOP_SORTED = 0, SETOP_HASHED = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OnConflictAction {
    ONCONFLICT_NONE = 0,
    ONCONFLICT_NOTHING = 1,
    ONCONFLICT_UPDATE = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct ListCell {
    pub data: ListCell__bindgen_ty_1,
    pub next: *mut ListCell,
}
#[repr(C)]
#[derive(Copy)]
pub union ListCell__bindgen_ty_1 {
    pub ptr_value: *mut ::std::os::raw::c_void,
    pub int_value: ::std::os::raw::c_int,
    pub oid_value: Oid,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ListCell__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ListCell__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ListCell__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ListCell__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ListCell__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListCell__bindgen_ty_1 ) ) . ptr_value as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ListCell__bindgen_ty_1
                ) , "::" , stringify ! ( ptr_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListCell__bindgen_ty_1 ) ) . int_value as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ListCell__bindgen_ty_1
                ) , "::" , stringify ! ( int_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListCell__bindgen_ty_1 ) ) . oid_value as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ListCell__bindgen_ty_1
                ) , "::" , stringify ! ( oid_value ) ));
}
impl Clone for ListCell__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ListCell() {
    assert_eq!(::std::mem::size_of::<ListCell>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ListCell ) ));
    assert_eq! (::std::mem::align_of::<ListCell>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ListCell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListCell ) ) . data as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ListCell ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListCell ) ) . next as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ListCell ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for ListCell {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
#[test]
fn bindgen_test_layout_List() {
    assert_eq!(::std::mem::size_of::<List>() , 24usize , concat ! (
               "Size of: " , stringify ! ( List ) ));
    assert_eq! (::std::mem::align_of::<List>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( List ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const List ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( List ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const List ) ) . length as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( List ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const List ) ) . head as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( List ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const List ) ) . tail as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( List ) , "::" ,
                stringify ! ( tail ) ));
}
impl Clone for List {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
}
extern "C" {
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::std::os::raw::c_void) -> *mut ListCell;
}
extern "C" {
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::std::os::raw::c_int) -> *mut ListCell;
}
extern "C" {
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
}
extern "C" {
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
}
extern "C" {
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int)
     -> *mut List;
}
extern "C" {
    pub fn list_nth_cell(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ListCell;
}
extern "C" {
    pub fn list_nth(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn list_nth_int(list: *const List, n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn list_nth_oid(list: *const List, n: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn list_member(list: *const List,
                       datum: *const ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn list_member_ptr(list: *const List,
                           datum: *const ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn list_member_oid(list: *const List, datum: Oid) -> bool_;
}
extern "C" {
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn list_delete_ptr(list: *mut List,
                           datum: *mut ::std::os::raw::c_void) -> *mut List;
}
extern "C" {
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
}
extern "C" {
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    pub fn list_delete_first(list: *mut List) -> *mut List;
}
extern "C" {
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
}
extern "C" {
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_intersection_int(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_append_unique(list: *mut List,
                              datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn list_append_unique_ptr(list: *mut List,
                                  datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn list_append_unique_int(list: *mut List,
                                  datum: ::std::os::raw::c_int) -> *mut List;
}
extern "C" {
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_free(list: *mut List);
}
extern "C" {
    pub fn list_free_deep(list: *mut List);
}
extern "C" {
    pub fn list_copy(list: *const List) -> *mut List;
}
extern "C" {
    pub fn list_copy_tail(list: *const List, nskip: ::std::os::raw::c_int)
     -> *mut List;
}
#[repr(C)]
#[derive(Copy)]
pub struct attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_attrDefault() {
    assert_eq!(::std::mem::size_of::<attrDefault>() , 16usize , concat ! (
               "Size of: " , stringify ! ( attrDefault ) ));
    assert_eq! (::std::mem::align_of::<attrDefault>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( attrDefault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const attrDefault ) ) . adnum as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( attrDefault ) , "::" ,
                stringify ! ( adnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const attrDefault ) ) . adbin as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( attrDefault ) , "::" ,
                stringify ! ( adbin ) ));
}
impl Clone for attrDefault {
    fn clone(&self) -> Self { *self }
}
pub type AttrDefault = attrDefault;
#[repr(C)]
#[derive(Copy)]
pub struct constrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: bool_,
    pub ccnoinherit: bool_,
}
#[test]
fn bindgen_test_layout_constrCheck() {
    assert_eq!(::std::mem::size_of::<constrCheck>() , 24usize , concat ! (
               "Size of: " , stringify ! ( constrCheck ) ));
    assert_eq! (::std::mem::align_of::<constrCheck>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( constrCheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constrCheck ) ) . ccname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( constrCheck ) , "::" ,
                stringify ! ( ccname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constrCheck ) ) . ccbin as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( constrCheck ) , "::" ,
                stringify ! ( ccbin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constrCheck ) ) . ccvalid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( constrCheck ) , "::" ,
                stringify ! ( ccvalid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constrCheck ) ) . ccnoinherit as * const
                _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( constrCheck ) , "::" ,
                stringify ! ( ccnoinherit ) ));
}
impl Clone for constrCheck {
    fn clone(&self) -> Self { *self }
}
pub type ConstrCheck = constrCheck;
#[repr(C)]
#[derive(Copy)]
pub struct tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool_,
}
#[test]
fn bindgen_test_layout_tupleConstr() {
    assert_eq!(::std::mem::size_of::<tupleConstr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( tupleConstr ) ));
    assert_eq! (::std::mem::align_of::<tupleConstr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tupleConstr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleConstr ) ) . defval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleConstr ) , "::" ,
                stringify ! ( defval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleConstr ) ) . check as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleConstr ) , "::" ,
                stringify ! ( check ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleConstr ) ) . num_defval as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleConstr ) , "::" ,
                stringify ! ( num_defval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleConstr ) ) . num_check as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleConstr ) , "::" ,
                stringify ! ( num_check ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleConstr ) ) . has_not_null as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleConstr ) , "::" ,
                stringify ! ( has_not_null ) ));
}
impl Clone for tupleConstr {
    fn clone(&self) -> Self { *self }
}
pub type TupleConstr = tupleConstr;
#[repr(C)]
#[derive(Copy)]
pub struct tupleDesc {
    pub natts: ::std::os::raw::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: bool_,
    pub tdrefcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tupleDesc() {
    assert_eq!(::std::mem::size_of::<tupleDesc>() , 40usize , concat ! (
               "Size of: " , stringify ! ( tupleDesc ) ));
    assert_eq! (::std::mem::align_of::<tupleDesc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tupleDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . natts as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( natts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . attrs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( attrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . constr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( constr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . tdtypeid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( tdtypeid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . tdtypmod as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( tdtypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . tdhasoid as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( tdhasoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tupleDesc ) ) . tdrefcount as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tupleDesc ) , "::" ,
                stringify ! ( tdrefcount ) ));
}
impl Clone for tupleDesc {
    fn clone(&self) -> Self { *self }
}
pub type TupleDesc = *mut tupleDesc;
extern "C" {
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int,
                                   hasoid: bool_) -> TupleDesc;
}
extern "C" {
    pub fn CreateTupleDesc(natts: ::std::os::raw::c_int, hasoid: bool_,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
}
extern "C" {
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    pub fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber,
                              src: TupleDesc, srcAttno: AttrNumber);
}
extern "C" {
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
}
extern "C" {
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
}
extern "C" {
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
}
extern "C" {
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool_;
}
extern "C" {
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::std::os::raw::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TupleDescInitBuiltinEntry(desc: TupleDesc,
                                     attributeNumber: AttrNumber,
                                     attributeName:
                                         *const ::std::os::raw::c_char,
                                     oidtypeid: Oid, typmod: int32,
                                     attdim: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid);
}
extern "C" {
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
}
extern "C" {
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
}
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BMS_Comparison {
    BMS_EQUAL = 0,
    BMS_SUBSET1 = 1,
    BMS_SUBSET2 = 2,
    BMS_DIFFERENT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BMS_Membership {
    BMS_EMPTY_SET = 0,
    BMS_SINGLETON = 1,
    BMS_MULTIPLE = 2,
}
extern "C" {
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_free(a: *mut Bitmapset);
}
extern "C" {
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
}
extern "C" {
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset)
     -> bool_;
}
extern "C" {
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_overlap_list(a: *const Bitmapset, b: *const List) -> bool_;
}
extern "C" {
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> bool_;
}
extern "C" {
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_get_singleton_member(a: *const Bitmapset,
                                    member: *mut ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
}
extern "C" {
    pub fn bms_is_empty(a: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_first_member(a: *mut Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_next_member(a: *const Bitmapset,
                           prevbit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
}
#[repr(C)]
#[derive(Copy)]
pub struct RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut SMgrRelationData,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: bool_,
    pub rd_isnailed: bool_,
    pub rd_isvalid: bool_,
    pub rd_indexvalid: ::std::os::raw::c_char,
    pub rd_statvalid: bool_,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_rsdesc: *mut RowSecurityDesc,
    pub rd_fkeylist: *mut List,
    pub rd_fkeyvalid: bool_,
    pub rd_partkeycxt: MemoryContext,
    pub rd_partkey: *mut PartitionKeyData,
    pub rd_pdcxt: MemoryContext,
    pub rd_partdesc: *mut PartitionDescData,
    pub rd_partcheck: *mut List,
    pub rd_indexlist: *mut List,
    pub rd_oidindex: Oid,
    pub rd_pkindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_statlist: *mut List,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_pkattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_pubactions: *mut PublicationActions,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut HeapTupleData,
    pub rd_amhandler: Oid,
    pub rd_indexcxt: MemoryContext,
    pub rd_amroutine: *mut IndexAmRoutine,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut PgStat_TableStatus,
}
#[test]
fn bindgen_test_layout_RelationData() {
    assert_eq!(::std::mem::size_of::<RelationData>() , 408usize , concat ! (
               "Size of: " , stringify ! ( RelationData ) ));
    assert_eq! (::std::mem::align_of::<RelationData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RelationData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_smgr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_smgr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_refcnt as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_backend as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_backend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_islocaltemp as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_islocaltemp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_isnailed as * const
                _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_isnailed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_isvalid as * const
                _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_isvalid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indexvalid as *
                const _ as usize } , 35usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indexvalid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_statvalid as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_statvalid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_createSubid as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_createSubid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_newRelfilenodeSubid
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_newRelfilenodeSubid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_rel as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_rel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_att as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_att ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_id as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_lockInfo as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_lockInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_rules as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_rulescxt as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_rulescxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . trigdesc as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( trigdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_rsdesc as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_rsdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_fkeylist as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_fkeylist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_fkeyvalid as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_fkeyvalid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_partkeycxt as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_partkeycxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_partkey as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_partkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_pdcxt as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_pdcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_partdesc as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_partdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_partcheck as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_partcheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indexlist as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indexlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_oidindex as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_oidindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_pkindex as * const
                _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_pkindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_replidindex as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_replidindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_statlist as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_statlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indexattr as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indexattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_keyattr as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_keyattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_pkattr as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_pkattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_idattr as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_idattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_pubactions as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_pubactions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_options as * const
                _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_index as * const _
                as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indextuple as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indextuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_amhandler as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_amhandler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indexcxt as * const
                _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indexcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_amroutine as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_amroutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_opfamily as * const
                _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_opfamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_opcintype as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_opcintype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_support as * const
                _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_support ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_supportinfo as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_supportinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indoption as *
                const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indoption ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indexprs as * const
                _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indpred as * const
                _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indpred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_exclops as * const
                _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_exclops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_exclprocs as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_exclprocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_exclstrats as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_exclstrats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_amcache as * const
                _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_amcache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_indcollation as *
                const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_indcollation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_fdwroutine as *
                const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_fdwroutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . rd_toastoid as * const
                _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( rd_toastoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelationData ) ) . pgstat_info as * const
                _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( RelationData ) , "::" ,
                stringify ! ( pgstat_info ) ));
}
impl Clone for RelationData {
    fn clone(&self) -> Self { *self }
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
extern "C" {
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
}
extern "C" {
    pub fn RelationClose(relation: Relation);
}
extern "C" {
    pub fn RelationGetFKeyList(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetStatExtList(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
}
extern "C" {
    pub fn RelationGetPrimaryKeyIndex(relation: Relation) -> Oid;
}
extern "C" {
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
}
extern "C" {
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IndexAttrBitmapKind {
    INDEX_ATTR_BITMAP_ALL = 0,
    INDEX_ATTR_BITMAP_KEY = 1,
    INDEX_ATTR_BITMAP_PRIMARY_KEY = 2,
    INDEX_ATTR_BITMAP_IDENTITY_KEY = 3,
}
extern "C" {
    pub fn RelationGetIndexAttrBitmap(relation: Relation,
                                      keyAttrs: IndexAttrBitmapKind)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16);
}
extern "C" {
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid);
}
extern "C" {
    pub fn RelationInitIndexAccessInfo(relation: Relation);
}
#[repr(C)]
#[derive(Copy)]
pub struct PublicationActions {
    pub pubinsert: bool_,
    pub pubupdate: bool_,
    pub pubdelete: bool_,
}
#[test]
fn bindgen_test_layout_PublicationActions() {
    assert_eq!(::std::mem::size_of::<PublicationActions>() , 3usize , concat !
               ( "Size of: " , stringify ! ( PublicationActions ) ));
    assert_eq! (::std::mem::align_of::<PublicationActions>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( PublicationActions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PublicationActions ) ) . pubinsert as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PublicationActions ) ,
                "::" , stringify ! ( pubinsert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PublicationActions ) ) . pubupdate as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( PublicationActions ) ,
                "::" , stringify ! ( pubupdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PublicationActions ) ) . pubdelete as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( PublicationActions ) ,
                "::" , stringify ! ( pubdelete ) ));
}
impl Clone for PublicationActions {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetRelationPublicationActions(relation: Relation)
     -> *mut PublicationActions;
}
extern "C" {
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errtablecolname(rel: Relation,
                           colname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errtableconstraint(rel: Relation,
                              conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RelationCacheInitialize();
}
extern "C" {
    pub fn RelationCacheInitializePhase2();
}
extern "C" {
    pub fn RelationCacheInitializePhase3();
}
extern "C" {
    pub fn RelationBuildLocalRelation(relname: *const ::std::os::raw::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: bool_,
                                      mapped_relation: bool_,
                                      relpersistence: ::std::os::raw::c_char,
                                      relkind: ::std::os::raw::c_char)
     -> Relation;
}
extern "C" {
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     persistence: ::std::os::raw::c_char,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId);
}
extern "C" {
    pub fn RelationForgetRelation(rid: Oid);
}
extern "C" {
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
}
extern "C" {
    pub fn RelationCacheInvalidate();
}
extern "C" {
    pub fn RelationCloseSmgrByOid(relationId: Oid);
}
extern "C" {
    pub fn AtEOXact_RelationCache(isCommit: bool_);
}
extern "C" {
    pub fn AtEOSubXact_RelationCache(isCommit: bool_,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId);
}
extern "C" {
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool_;
}
extern "C" {
    pub fn RelationCacheInitFilePreInvalidate();
}
extern "C" {
    pub fn RelationCacheInitFilePostInvalidate();
}
extern "C" {
    pub fn RelationCacheInitFileRemove();
}
extern "C" {
    #[link_name = "criticalRelcachesBuilt"]
    pub static mut criticalRelcachesBuilt: bool_;
}
extern "C" {
    #[link_name = "criticalSharedRelcachesBuilt"]
    pub static mut criticalSharedRelcachesBuilt: bool_;
}
#[repr(C)]
pub struct HeapTupleHeaderData {
    pub t_choice: HeapTupleHeaderData__bindgen_ty_1,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[repr(C)]
#[derive(Copy)]
pub union HeapTupleHeaderData__bindgen_ty_1 {
    pub t_heap: HeapTupleFields,
    pub t_datum: DatumTupleFields,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_HeapTupleHeaderData__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<HeapTupleHeaderData__bindgen_ty_1>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( HeapTupleHeaderData__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<HeapTupleHeaderData__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                HeapTupleHeaderData__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleHeaderData__bindgen_ty_1 ) ) .
                t_heap as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                HeapTupleHeaderData__bindgen_ty_1 ) , "::" , stringify ! (
                t_heap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleHeaderData__bindgen_ty_1 ) ) .
                t_datum as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                HeapTupleHeaderData__bindgen_ty_1 ) , "::" , stringify ! (
                t_datum ) ));
}
impl Clone for HeapTupleHeaderData__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_HeapTupleHeaderData() {
    assert_eq!(::std::mem::size_of::<HeapTupleHeaderData>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( HeapTupleHeaderData ) ));
    assert_eq! (::std::mem::align_of::<HeapTupleHeaderData>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( HeapTupleHeaderData ) ));
}
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
#[repr(C)]
pub struct MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::std::os::raw::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[test]
fn bindgen_test_layout_MinimalTupleData() {
    assert_eq!(::std::mem::size_of::<MinimalTupleData>() , 16usize , concat !
               ( "Size of: " , stringify ! ( MinimalTupleData ) ));
    assert_eq! (::std::mem::align_of::<MinimalTupleData>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( MinimalTupleData ) ));
}
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Copy)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
#[test]
fn bindgen_test_layout_HeapTupleData() {
    assert_eq!(::std::mem::size_of::<HeapTupleData>() , 24usize , concat ! (
               "Size of: " , stringify ! ( HeapTupleData ) ));
    assert_eq! (::std::mem::align_of::<HeapTupleData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HeapTupleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleData ) ) . t_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleData ) , "::"
                , stringify ! ( t_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleData ) ) . t_self as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleData ) , "::"
                , stringify ! ( t_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleData ) ) . t_tableOid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleData ) , "::"
                , stringify ! ( t_tableOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleData ) ) . t_data as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleData ) , "::"
                , stringify ! ( t_data ) ));
}
impl Clone for HeapTupleData {
    fn clone(&self) -> Self { *self }
}
pub type HeapTuple = *mut HeapTupleData;
extern "C" {
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
}
extern "C" {
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
}
extern "C" {
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut bool_);
}
extern "C" {
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
}
#[repr(C)]
#[derive(Copy)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(::std::mem::size_of::<flock>() , 32usize , concat ! (
               "Size of: " , stringify ! ( flock ) ));
    assert_eq! (::std::mem::align_of::<flock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( flock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_type as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_whence as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_whence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_start as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_len as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_pid as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_pid ) ));
}
impl Clone for flock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(::std::mem::size_of::<stat>() , 144usize , concat ! (
               "Size of: " , stringify ! ( stat ) ));
    assert_eq! (::std::mem::align_of::<stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ino as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_nlink as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mode as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_uid as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_gid as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __pad0 as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_rdev as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_size as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blksize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_atim as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_atim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mtim as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ctim as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __glibc_reserved as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __glibc_reserved ) ));
}
impl Clone for stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn fcntl(__fd: ::std::os::raw::c_int,
                 __cmd: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(__file: *const ::std::os::raw::c_char,
                __oflag: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(__fd: ::std::os::raw::c_int,
                  __file: *const ::std::os::raw::c_char,
                  __oflag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(__fd: ::std::os::raw::c_int, __offset: off_t,
                         __len: off_t, __advise: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: ::std::os::raw::c_int, __offset: off_t,
                           __len: off_t) -> ::std::os::raw::c_int;
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[test]
fn bindgen_test_layout_Interval() {
    assert_eq!(::std::mem::size_of::<Interval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Interval ) ));
    assert_eq! (::std::mem::align_of::<Interval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Interval ) ) . time as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Interval ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Interval ) ) . day as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Interval ) , "::" ,
                stringify ! ( day ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Interval ) ) . month as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Interval ) , "::" ,
                stringify ! ( month ) ));
}
impl Clone for Interval {
    fn clone(&self) -> Self { *self }
}
pub type StringInfo = *mut StringInfoData;
extern "C" {
    pub fn makeStringInfo() -> StringInfo;
}
extern "C" {
    pub fn initStringInfo(str: StringInfo);
}
extern "C" {
    pub fn resetStringInfo(str: StringInfo);
}
extern "C" {
    pub fn appendStringInfo(str: StringInfo,
                            fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn appendStringInfoVA(str: StringInfo,
                              fmt: *const ::std::os::raw::c_char,
                              args: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn appendStringInfoString(str: StringInfo,
                                  s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn appendStringInfoChar(str: StringInfo, ch: ::std::os::raw::c_char);
}
extern "C" {
    pub fn appendStringInfoSpaces(str: StringInfo,
                                  count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::std::os::raw::c_char,
                                  datalen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn enlargeStringInfo(str: StringInfo, needed: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy)]
pub struct pairingheap_node {
    pub first_child: *mut pairingheap_node,
    pub next_sibling: *mut pairingheap_node,
    pub prev_or_parent: *mut pairingheap_node,
}
#[test]
fn bindgen_test_layout_pairingheap_node() {
    assert_eq!(::std::mem::size_of::<pairingheap_node>() , 24usize , concat !
               ( "Size of: " , stringify ! ( pairingheap_node ) ));
    assert_eq! (::std::mem::align_of::<pairingheap_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pairingheap_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pairingheap_node ) ) . first_child as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pairingheap_node ) ,
                "::" , stringify ! ( first_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pairingheap_node ) ) . next_sibling as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pairingheap_node ) ,
                "::" , stringify ! ( next_sibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pairingheap_node ) ) . prev_or_parent as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pairingheap_node ) ,
                "::" , stringify ! ( prev_or_parent ) ));
}
impl Clone for pairingheap_node {
    fn clone(&self) -> Self { *self }
}
pub type pairingheap_comparator =
    ::std::option::Option<unsafe extern "C" fn(a: *const pairingheap_node,
                                               b: *const pairingheap_node,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::std::os::raw::c_void,
    pub ph_root: *mut pairingheap_node,
}
#[test]
fn bindgen_test_layout_pairingheap() {
    assert_eq!(::std::mem::size_of::<pairingheap>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pairingheap ) ));
    assert_eq! (::std::mem::align_of::<pairingheap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pairingheap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pairingheap ) ) . ph_compare as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pairingheap ) , "::" ,
                stringify ! ( ph_compare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pairingheap ) ) . ph_arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pairingheap ) , "::" ,
                stringify ! ( ph_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pairingheap ) ) . ph_root as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pairingheap ) , "::" ,
                stringify ! ( ph_root ) ));
}
impl Clone for pairingheap {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn pairingheap_allocate(compare: pairingheap_comparator,
                                arg: *mut ::std::os::raw::c_void)
     -> *mut pairingheap;
}
extern "C" {
    pub fn pairingheap_free(heap: *mut pairingheap);
}
extern "C" {
    pub fn pairingheap_add(heap: *mut pairingheap,
                           node: *mut pairingheap_node);
}
extern "C" {
    pub fn pairingheap_first(heap: *mut pairingheap) -> *mut pairingheap_node;
}
extern "C" {
    pub fn pairingheap_remove_first(heap: *mut pairingheap)
     -> *mut pairingheap_node;
}
extern "C" {
    pub fn pairingheap_remove(heap: *mut pairingheap,
                              node: *mut pairingheap_node);
}
pub type Buffer = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferAccessStrategyData {
    _unused: [u8; 0],
}
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
#[repr(C)]
#[derive(Copy)]
pub struct SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: bool_,
    pub takenDuringRecovery: bool_,
    pub copied: bool_,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: TimestampTz,
    pub lsn: XLogRecPtr,
}
#[test]
fn bindgen_test_layout_SnapshotData() {
    assert_eq!(::std::mem::size_of::<SnapshotData>() , 104usize , concat ! (
               "Size of: " , stringify ! ( SnapshotData ) ));
    assert_eq! (::std::mem::align_of::<SnapshotData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SnapshotData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . satisfies as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( satisfies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . xmin as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . xmax as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( xmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . xip as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( xip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . xcnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( xcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . subxip as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( subxip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . subxcnt as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( subxcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . suboverflowed as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( suboverflowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . takenDuringRecovery as
                * const _ as usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( takenDuringRecovery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . copied as * const _ as
                usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( copied ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . curcid as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( curcid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . speculativeToken as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( speculativeToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . active_count as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( active_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . regd_count as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( regd_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . ph_node as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( ph_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . whenTaken as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( whenTaken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SnapshotData ) ) . lsn as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( SnapshotData ) , "::" ,
                stringify ! ( lsn ) ));
}
impl Clone for SnapshotData {
    fn clone(&self) -> Self { *self }
}
pub type Snapshot = *mut SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<unsafe extern "C" fn(htup: HeapTuple,
                                               snapshot: Snapshot,
                                               buffer: Buffer) -> bool_>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HTSU_Result {
    HeapTupleMayBeUpdated = 0,
    HeapTupleInvisible = 1,
    HeapTupleSelfUpdated = 2,
    HeapTupleUpdated = 3,
    HeapTupleBeingUpdated = 4,
    HeapTupleWouldBlock = 5,
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_KeyAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut ExprState,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_UniqueOps: *mut Oid,
    pub ii_UniqueProcs: *mut Oid,
    pub ii_UniqueStrats: *mut uint16,
    pub ii_Unique: bool_,
    pub ii_ReadyForInserts: bool_,
    pub ii_Concurrent: bool_,
    pub ii_BrokenHotChain: bool_,
    pub ii_AmCache: *mut ::std::os::raw::c_void,
    pub ii_Context: MemoryContext,
}
#[test]
fn bindgen_test_layout_IndexInfo() {
    assert_eq!(::std::mem::size_of::<IndexInfo>() , 176usize , concat ! (
               "Size of: " , stringify ! ( IndexInfo ) ));
    assert_eq! (::std::mem::align_of::<IndexInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_NumIndexAttrs as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_NumIndexAttrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_KeyAttrNumbers as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_KeyAttrNumbers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_Expressions as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_Expressions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_ExpressionsState as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_ExpressionsState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_Predicate as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_Predicate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_PredicateState as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_PredicateState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_ExclusionOps as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_ExclusionOps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_ExclusionProcs as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_ExclusionProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_ExclusionStrats as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_ExclusionStrats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_UniqueOps as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_UniqueOps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_UniqueProcs as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_UniqueProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_UniqueStrats as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_UniqueStrats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_Unique as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_Unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_ReadyForInserts as *
                const _ as usize } , 153usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_ReadyForInserts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_Concurrent as * const
                _ as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_Concurrent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_BrokenHotChain as *
                const _ as usize } , 155usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_BrokenHotChain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_AmCache as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_AmCache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexInfo ) ) . ii_Context as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexInfo ) , "::" ,
                stringify ! ( ii_Context ) ));
}
impl Clone for IndexInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[test]
fn bindgen_test_layout_IndexBuildResult() {
    assert_eq!(::std::mem::size_of::<IndexBuildResult>() , 16usize , concat !
               ( "Size of: " , stringify ! ( IndexBuildResult ) ));
    assert_eq! (::std::mem::align_of::<IndexBuildResult>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( IndexBuildResult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBuildResult ) ) . heap_tuples as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBuildResult ) ,
                "::" , stringify ! ( heap_tuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBuildResult ) ) . index_tuples as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBuildResult ) ,
                "::" , stringify ! ( index_tuples ) ));
}
impl Clone for IndexBuildResult {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub analyze_only: bool_,
    pub estimated_count: bool_,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
#[test]
fn bindgen_test_layout_IndexVacuumInfo() {
    assert_eq!(::std::mem::size_of::<IndexVacuumInfo>() , 32usize , concat ! (
               "Size of: " , stringify ! ( IndexVacuumInfo ) ));
    assert_eq! (::std::mem::align_of::<IndexVacuumInfo>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( IndexVacuumInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexVacuumInfo ) ) . index as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexVacuumInfo ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexVacuumInfo ) ) . analyze_only as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexVacuumInfo ) ,
                "::" , stringify ! ( analyze_only ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexVacuumInfo ) ) . estimated_count as
                * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexVacuumInfo ) ,
                "::" , stringify ! ( estimated_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexVacuumInfo ) ) . message_level as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexVacuumInfo ) ,
                "::" , stringify ! ( message_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexVacuumInfo ) ) . num_heap_tuples as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexVacuumInfo ) ,
                "::" , stringify ! ( num_heap_tuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexVacuumInfo ) ) . strategy as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexVacuumInfo ) ,
                "::" , stringify ! ( strategy ) ));
}
impl Clone for IndexVacuumInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: bool_,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
#[test]
fn bindgen_test_layout_IndexBulkDeleteResult() {
    assert_eq!(::std::mem::size_of::<IndexBulkDeleteResult>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( IndexBulkDeleteResult )
               ));
    assert_eq! (::std::mem::align_of::<IndexBulkDeleteResult>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( IndexBulkDeleteResult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) . num_pages as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( num_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) . pages_removed
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( pages_removed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) .
                estimated_count as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( estimated_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) .
                num_index_tuples as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( num_index_tuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) .
                tuples_removed as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( tuples_removed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) . pages_deleted
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( pages_deleted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexBulkDeleteResult ) ) . pages_free as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexBulkDeleteResult )
                , "::" , stringify ! ( pages_free ) ));
}
impl Clone for IndexBulkDeleteResult {
    fn clone(&self) -> Self { *self }
}
pub type IndexBulkDeleteCallback =
    ::std::option::Option<unsafe extern "C" fn(itemptr: ItemPointer,
                                               state:
                                                   *mut ::std::os::raw::c_void)
                              -> bool_>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanDescData {
    _unused: [u8; 0],
}
pub type IndexScanDesc = *mut IndexScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysScanDescData {
    _unused: [u8; 0],
}
pub type SysScanDesc = *mut SysScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelIndexScanDescData {
    _unused: [u8; 0],
}
pub type ParallelIndexScanDesc = *mut ParallelIndexScanDescData;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IndexUniqueCheck {
    UNIQUE_CHECK_NO = 0,
    UNIQUE_CHECK_YES = 1,
    UNIQUE_CHECK_PARTIAL = 2,
    UNIQUE_CHECK_EXISTING = 3,
}
extern "C" {
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn index_close(relation: Relation, lockmode: LOCKMODE);
}
extern "C" {
    pub fn index_insert(indexRelation: Relation, values: *mut Datum,
                        isnull: *mut bool_, heap_t_ctid: ItemPointer,
                        heapRelation: Relation, checkUnique: IndexUniqueCheck,
                        indexInfo: *mut IndexInfo) -> bool_;
}
extern "C" {
    pub fn index_beginscan(heapRelation: Relation, indexRelation: Relation,
                           snapshot: Snapshot, nkeys: ::std::os::raw::c_int,
                           norderbys: ::std::os::raw::c_int) -> IndexScanDesc;
}
extern "C" {
    pub fn index_beginscan_bitmap(indexRelation: Relation, snapshot: Snapshot,
                                  nkeys: ::std::os::raw::c_int)
     -> IndexScanDesc;
}
extern "C" {
    pub fn index_rescan(scan: IndexScanDesc, keys: ScanKey,
                        nkeys: ::std::os::raw::c_int, orderbys: ScanKey,
                        norderbys: ::std::os::raw::c_int);
}
extern "C" {
    pub fn index_endscan(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_markpos(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_restrpos(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_parallelscan_estimate(indexrel: Relation, snapshot: Snapshot)
     -> Size;
}
extern "C" {
    pub fn index_parallelscan_initialize(heaprel: Relation,
                                         indexrel: Relation,
                                         snapshot: Snapshot,
                                         target: ParallelIndexScanDesc);
}
extern "C" {
    pub fn index_parallelrescan(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_beginscan_parallel(heaprel: Relation, indexrel: Relation,
                                    nkeys: ::std::os::raw::c_int,
                                    norderbys: ::std::os::raw::c_int,
                                    pscan: ParallelIndexScanDesc)
     -> IndexScanDesc;
}
extern "C" {
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection)
     -> ItemPointer;
}
extern "C" {
    pub fn index_fetch_heap(scan: IndexScanDesc) -> HeapTuple;
}
extern "C" {
    pub fn index_getnext(scan: IndexScanDesc, direction: ScanDirection)
     -> HeapTuple;
}
extern "C" {
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap)
     -> int64;
}
extern "C" {
    pub fn index_bulk_delete(info: *mut IndexVacuumInfo,
                             stats: *mut IndexBulkDeleteResult,
                             callback: IndexBulkDeleteCallback,
                             callback_state: *mut ::std::os::raw::c_void)
     -> *mut IndexBulkDeleteResult;
}
extern "C" {
    pub fn index_vacuum_cleanup(info: *mut IndexVacuumInfo,
                                stats: *mut IndexBulkDeleteResult)
     -> *mut IndexBulkDeleteResult;
}
extern "C" {
    pub fn index_can_return(indexRelation: Relation,
                            attno: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber,
                           procnum: uint16) -> RegProcedure;
}
extern "C" {
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber,
                             procnum: uint16) -> *mut FmgrInfo;
}
extern "C" {
    pub fn RelationGetIndexScan(indexRelation: Relation,
                                nkeys: ::std::os::raw::c_int,
                                norderbys: ::std::os::raw::c_int)
     -> IndexScanDesc;
}
extern "C" {
    pub fn IndexScanEnd(scan: IndexScanDesc);
}
extern "C" {
    pub fn BuildIndexValueDescription(indexRelation: Relation,
                                      values: *mut Datum, isnull: *mut bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn systable_beginscan(heapRelation: Relation, indexId: Oid,
                              indexOK: bool_, snapshot: Snapshot,
                              nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> SysScanDesc;
}
extern "C" {
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
}
extern "C" {
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple)
     -> bool_;
}
extern "C" {
    pub fn systable_endscan(sysscan: SysScanDesc);
}
extern "C" {
    pub fn systable_beginscan_ordered(heapRelation: Relation,
                                      indexRelation: Relation,
                                      snapshot: Snapshot,
                                      nkeys: ::std::os::raw::c_int,
                                      key: ScanKey) -> SysScanDesc;
}
extern "C" {
    pub fn systable_getnext_ordered(sysscan: SysScanDesc,
                                    direction: ScanDirection) -> HeapTuple;
}
extern "C" {
    pub fn systable_endscan_ordered(sysscan: SysScanDesc);
}
#[repr(C)]
#[derive(Copy)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: *mut Query,
    pub glob: *mut PlannerGlobal,
    pub query_level: Index,
    pub parent_root: *mut PlannerInfo,
    pub plan_params: *mut List,
    pub outer_params: *mut Bitmapset,
    pub simple_rel_array: *mut *mut RelOptInfo,
    pub simple_rel_array_size: ::std::os::raw::c_int,
    pub simple_rte_array: *mut *mut RangeTblEntry,
    pub all_baserels: Relids,
    pub nullable_baserels: Relids,
    pub join_rel_list: *mut List,
    pub join_rel_hash: *mut HTAB,
    pub join_rel_level: *mut *mut List,
    pub join_cur_level: ::std::os::raw::c_int,
    pub init_plans: *mut List,
    pub cte_plan_ids: *mut List,
    pub multiexpr_params: *mut List,
    pub eq_classes: *mut List,
    pub canon_pathkeys: *mut List,
    pub left_join_clauses: *mut List,
    pub right_join_clauses: *mut List,
    pub full_join_clauses: *mut List,
    pub join_info_list: *mut List,
    pub append_rel_list: *mut List,
    pub pcinfo_list: *mut List,
    pub rowMarks: *mut List,
    pub placeholder_list: *mut List,
    pub fkey_list: *mut List,
    pub query_pathkeys: *mut List,
    pub group_pathkeys: *mut List,
    pub window_pathkeys: *mut List,
    pub distinct_pathkeys: *mut List,
    pub sort_pathkeys: *mut List,
    pub initial_rels: *mut List,
    pub upper_rels: [*mut List; 6usize],
    pub upper_targets: [*mut PathTarget; 6usize],
    pub processed_tlist: *mut List,
    pub grouping_map: *mut AttrNumber,
    pub minmax_aggs: *mut List,
    pub planner_cxt: MemoryContext,
    pub total_table_pages: f64,
    pub tuple_fraction: f64,
    pub limit_tuples: f64,
    pub qual_security_level: Index,
    pub hasInheritedTarget: bool_,
    pub hasJoinRTEs: bool_,
    pub hasLateralRTEs: bool_,
    pub hasDeletedRTEs: bool_,
    pub hasHavingQual: bool_,
    pub hasPseudoConstantQuals: bool_,
    pub hasRecursion: bool_,
    pub wt_param_id: ::std::os::raw::c_int,
    pub non_recursive_path: *mut Path,
    pub curOuterRels: Relids,
    pub curOuterParams: *mut List,
    pub join_search_private: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PlannerInfo() {
    assert_eq!(::std::mem::size_of::<PlannerInfo>() , 488usize , concat ! (
               "Size of: " , stringify ! ( PlannerInfo ) ));
    assert_eq! (::std::mem::align_of::<PlannerInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PlannerInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . parse as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( parse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . glob as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( glob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . query_level as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( query_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . parent_root as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( parent_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . plan_params as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( plan_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . outer_params as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( outer_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . simple_rel_array as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( simple_rel_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . simple_rel_array_size
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( simple_rel_array_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . simple_rte_array as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( simple_rte_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . all_baserels as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( all_baserels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . nullable_baserels as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( nullable_baserels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . join_rel_list as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( join_rel_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . join_rel_hash as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( join_rel_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . join_rel_level as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( join_rel_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . join_cur_level as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( join_cur_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . init_plans as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( init_plans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . cte_plan_ids as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( cte_plan_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . multiexpr_params as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( multiexpr_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . eq_classes as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( eq_classes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . canon_pathkeys as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( canon_pathkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . left_join_clauses as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( left_join_clauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . right_join_clauses as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( right_join_clauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . full_join_clauses as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( full_join_clauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . join_info_list as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( join_info_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . append_rel_list as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( append_rel_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . pcinfo_list as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( pcinfo_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . rowMarks as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . placeholder_list as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( placeholder_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . fkey_list as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( fkey_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . query_pathkeys as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( query_pathkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . group_pathkeys as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( group_pathkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . window_pathkeys as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( window_pathkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . distinct_pathkeys as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( distinct_pathkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . sort_pathkeys as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( sort_pathkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . initial_rels as * const
                _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( initial_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . upper_rels as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( upper_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . upper_targets as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( upper_targets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . processed_tlist as *
                const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( processed_tlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . grouping_map as * const
                _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( grouping_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . minmax_aggs as * const
                _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( minmax_aggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . planner_cxt as * const
                _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( planner_cxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . total_table_pages as *
                const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( total_table_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . tuple_fraction as *
                const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( tuple_fraction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . limit_tuples as * const
                _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( limit_tuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . qual_security_level as
                * const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( qual_security_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasInheritedTarget as *
                const _ as usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasInheritedTarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasJoinRTEs as * const
                _ as usize } , 445usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasJoinRTEs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasLateralRTEs as *
                const _ as usize } , 446usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasLateralRTEs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasDeletedRTEs as *
                const _ as usize } , 447usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasDeletedRTEs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasHavingQual as *
                const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasHavingQual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasPseudoConstantQuals
                as * const _ as usize } , 449usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasPseudoConstantQuals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . hasRecursion as * const
                _ as usize } , 450usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( hasRecursion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . wt_param_id as * const
                _ as usize } , 452usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( wt_param_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . non_recursive_path as *
                const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( non_recursive_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . curOuterRels as * const
                _ as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( curOuterRels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . curOuterParams as *
                const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( curOuterParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerInfo ) ) . join_search_private as
                * const _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerInfo ) , "::" ,
                stringify ! ( join_search_private ) ));
}
impl Clone for PlannerInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: *mut IndexOptInfo,
    pub indexclauses: *mut List,
    pub indexquals: *mut List,
    pub indexqualcols: *mut List,
    pub indexorderbys: *mut List,
    pub indexorderbycols: *mut List,
    pub indexscandir: ScanDirection,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
#[test]
fn bindgen_test_layout_IndexPath() {
    assert_eq!(::std::mem::size_of::<IndexPath>() , 144usize , concat ! (
               "Size of: " , stringify ! ( IndexPath ) ));
    assert_eq! (::std::mem::align_of::<IndexPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexinfo as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexclauses as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexclauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexquals as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexquals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexqualcols as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexqualcols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexorderbys as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexorderbys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexorderbycols as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexorderbycols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexscandir as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexscandir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indextotalcost as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indextotalcost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexPath ) ) . indexselectivity as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexPath ) , "::" ,
                stringify ! ( indexselectivity ) ));
}
impl Clone for IndexPath {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IndexAMProperty {
    AMPROP_UNKNOWN = 0,
    AMPROP_ASC = 1,
    AMPROP_DESC = 2,
    AMPROP_NULLS_FIRST = 3,
    AMPROP_NULLS_LAST = 4,
    AMPROP_ORDERABLE = 5,
    AMPROP_DISTANCE_ORDERABLE = 6,
    AMPROP_RETURNABLE = 7,
    AMPROP_SEARCH_ARRAY = 8,
    AMPROP_SEARCH_NULLS = 9,
    AMPROP_CLUSTERABLE = 10,
    AMPROP_INDEX_SCAN = 11,
    AMPROP_BITMAP_SCAN = 12,
    AMPROP_BACKWARD_SCAN = 13,
    AMPROP_CAN_ORDER = 14,
    AMPROP_CAN_UNIQUE = 15,
    AMPROP_CAN_MULTI_COL = 16,
    AMPROP_CAN_EXCLUDE = 17,
}
pub type ambuild_function =
    ::std::option::Option<unsafe extern "C" fn(heapRelation: Relation,
                                               indexRelation: Relation,
                                               indexInfo: *mut IndexInfo)
                              -> *mut IndexBuildResult>;
pub type ambuildempty_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation)>;
pub type aminsert_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation,
                                               values: *mut Datum,
                                               isnull: *mut bool_,
                                               heap_tid: ItemPointer,
                                               heapRelation: Relation,
                                               checkUnique: IndexUniqueCheck,
                                               indexInfo: *mut IndexInfo)
                              -> bool_>;
pub type ambulkdelete_function =
    ::std::option::Option<unsafe extern "C" fn(info: *mut IndexVacuumInfo,
                                               stats:
                                                   *mut IndexBulkDeleteResult,
                                               callback:
                                                   IndexBulkDeleteCallback,
                                               callback_state:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut IndexBulkDeleteResult>;
pub type amvacuumcleanup_function =
    ::std::option::Option<unsafe extern "C" fn(info: *mut IndexVacuumInfo,
                                               stats:
                                                   *mut IndexBulkDeleteResult)
                              -> *mut IndexBulkDeleteResult>;
pub type amcanreturn_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation,
                                               attno: ::std::os::raw::c_int)
                              -> bool_>;
pub type amcostestimate_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               path: *mut IndexPath,
                                               loop_count: f64,
                                               indexStartupCost: *mut Cost,
                                               indexTotalCost: *mut Cost,
                                               indexSelectivity:
                                                   *mut Selectivity,
                                               indexCorrelation: *mut f64,
                                               indexPages: *mut f64)>;
pub type amoptions_function =
    ::std::option::Option<unsafe extern "C" fn(reloptions: Datum,
                                               validate: bool_)
                              -> *mut bytea>;
pub type amproperty_function =
    ::std::option::Option<unsafe extern "C" fn(index_oid: Oid,
                                               attno: ::std::os::raw::c_int,
                                               prop: IndexAMProperty,
                                               propname:
                                                   *const ::std::os::raw::c_char,
                                               res: *mut bool_,
                                               isnull: *mut bool_) -> bool_>;
pub type amvalidate_function =
    ::std::option::Option<unsafe extern "C" fn(opclassoid: Oid) -> bool_>;
pub type ambeginscan_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation,
                                               nkeys: ::std::os::raw::c_int,
                                               norderbys:
                                                   ::std::os::raw::c_int)
                              -> IndexScanDesc>;
pub type amrescan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc,
                                               keys: ScanKey,
                                               nkeys: ::std::os::raw::c_int,
                                               orderbys: ScanKey,
                                               norderbys:
                                                   ::std::os::raw::c_int)>;
pub type amgettuple_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc,
                                               direction: ScanDirection)
                              -> bool_>;
pub type amgetbitmap_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc,
                                               tbm: *mut TIDBitmap) -> int64>;
pub type amendscan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type ammarkpos_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amrestrpos_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amestimateparallelscan_function =
    ::std::option::Option<unsafe extern "C" fn() -> Size>;
pub type aminitparallelscan_function =
    ::std::option::Option<unsafe extern "C" fn(target:
                                                   *mut ::std::os::raw::c_void)>;
pub type amparallelrescan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
#[repr(C)]
#[derive(Copy)]
pub struct IndexAmRoutine {
    pub type_: NodeTag,
    pub amstrategies: uint16,
    pub amsupport: uint16,
    pub amcanorder: bool_,
    pub amcanorderbyop: bool_,
    pub amcanbackward: bool_,
    pub amcanunique: bool_,
    pub amcanmulticol: bool_,
    pub amoptionalkey: bool_,
    pub amsearcharray: bool_,
    pub amsearchnulls: bool_,
    pub amstorage: bool_,
    pub amclusterable: bool_,
    pub ampredlocks: bool_,
    pub amcanparallel: bool_,
    pub amkeytype: Oid,
    pub ambuild: ambuild_function,
    pub ambuildempty: ambuildempty_function,
    pub aminsert: aminsert_function,
    pub ambulkdelete: ambulkdelete_function,
    pub amvacuumcleanup: amvacuumcleanup_function,
    pub amcanreturn: amcanreturn_function,
    pub amcostestimate: amcostestimate_function,
    pub amoptions: amoptions_function,
    pub amproperty: amproperty_function,
    pub amvalidate: amvalidate_function,
    pub ambeginscan: ambeginscan_function,
    pub amrescan: amrescan_function,
    pub amgettuple: amgettuple_function,
    pub amgetbitmap: amgetbitmap_function,
    pub amendscan: amendscan_function,
    pub ammarkpos: ammarkpos_function,
    pub amrestrpos: amrestrpos_function,
    pub amestimateparallelscan: amestimateparallelscan_function,
    pub aminitparallelscan: aminitparallelscan_function,
    pub amparallelrescan: amparallelrescan_function,
}
#[test]
fn bindgen_test_layout_IndexAmRoutine() {
    assert_eq!(::std::mem::size_of::<IndexAmRoutine>() , 184usize , concat ! (
               "Size of: " , stringify ! ( IndexAmRoutine ) ));
    assert_eq! (::std::mem::align_of::<IndexAmRoutine>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexAmRoutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amstrategies as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amstrategies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amsupport as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amsupport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanorder as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanorder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanorderbyop as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanorderbyop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanbackward as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanbackward ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanunique as *
                const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanunique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanmulticol as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanmulticol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amoptionalkey as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amoptionalkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amsearcharray as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amsearcharray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amsearchnulls as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amsearchnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amstorage as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amstorage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amclusterable as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amclusterable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . ampredlocks as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( ampredlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanparallel as *
                const _ as usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanparallel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amkeytype as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amkeytype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . ambuild as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( ambuild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . ambuildempty as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( ambuildempty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . aminsert as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( aminsert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . ambulkdelete as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( ambulkdelete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amvacuumcleanup as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amvacuumcleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcanreturn as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcanreturn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amcostestimate as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amcostestimate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amoptions as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amoptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amproperty as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amproperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amvalidate as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amvalidate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . ambeginscan as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( ambeginscan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amrescan as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amrescan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amgettuple as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amgettuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amgetbitmap as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amgetbitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amendscan as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amendscan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . ammarkpos as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( ammarkpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amrestrpos as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amrestrpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) .
                amestimateparallelscan as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amestimateparallelscan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . aminitparallelscan
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( aminitparallelscan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAmRoutine ) ) . amparallelrescan as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexAmRoutine ) , "::"
                , stringify ! ( amparallelrescan ) ));
}
impl Clone for IndexAmRoutine {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetIndexAmRoutine(amhandler: Oid) -> *mut IndexAmRoutine;
}
extern "C" {
    pub fn GetIndexAmRoutineByAmId(amoid: Oid, noerror: bool_)
     -> *mut IndexAmRoutine;
}
pub type BackendId = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "MyBackendId"]
    pub static mut MyBackendId: BackendId;
}
extern "C" {
    #[link_name = "ParallelMasterBackendId"]
    pub static mut ParallelMasterBackendId: BackendId;
}
#[repr(C)]
#[derive(Copy)]
pub struct proclist_node {
    pub next: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_proclist_node() {
    assert_eq!(::std::mem::size_of::<proclist_node>() , 8usize , concat ! (
               "Size of: " , stringify ! ( proclist_node ) ));
    assert_eq! (::std::mem::align_of::<proclist_node>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( proclist_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist_node ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist_node ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist_node ) ) . prev as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist_node ) , "::"
                , stringify ! ( prev ) ));
}
impl Clone for proclist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct proclist_head {
    pub head: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_proclist_head() {
    assert_eq!(::std::mem::size_of::<proclist_head>() , 8usize , concat ! (
               "Size of: " , stringify ! ( proclist_head ) ));
    assert_eq! (::std::mem::align_of::<proclist_head>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( proclist_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist_head ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist_head ) , "::"
                , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist_head ) ) . tail as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist_head ) , "::"
                , stringify ! ( tail ) ));
}
impl Clone for proclist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct proclist_mutable_iter {
    pub cur: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_proclist_mutable_iter() {
    assert_eq!(::std::mem::size_of::<proclist_mutable_iter>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( proclist_mutable_iter )
               ));
    assert_eq! (::std::mem::align_of::<proclist_mutable_iter>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( proclist_mutable_iter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist_mutable_iter ) ) . cur as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist_mutable_iter )
                , "::" , stringify ! ( cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist_mutable_iter ) ) . next as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist_mutable_iter )
                , "::" , stringify ! ( next ) ));
}
impl Clone for proclist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
pub type slock_t = ::std::os::raw::c_uchar;
extern "C" {
    #[link_name = "dummy_spinlock"]
    pub static mut dummy_spinlock: slock_t;
}
extern "C" {
    pub fn s_lock(lock: *mut slock_t, file: *const ::std::os::raw::c_char,
                  line: ::std::os::raw::c_int,
                  func: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
}
extern "C" {
    pub fn update_spins_per_delay(shared_spins_per_delay:
                                      ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct SpinDelayStatus {
    pub spins: ::std::os::raw::c_int,
    pub delays: ::std::os::raw::c_int,
    pub cur_delay: ::std::os::raw::c_int,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SpinDelayStatus() {
    assert_eq!(::std::mem::size_of::<SpinDelayStatus>() , 40usize , concat ! (
               "Size of: " , stringify ! ( SpinDelayStatus ) ));
    assert_eq! (::std::mem::align_of::<SpinDelayStatus>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SpinDelayStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpinDelayStatus ) ) . spins as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SpinDelayStatus ) ,
                "::" , stringify ! ( spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpinDelayStatus ) ) . delays as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SpinDelayStatus ) ,
                "::" , stringify ! ( delays ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpinDelayStatus ) ) . cur_delay as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SpinDelayStatus ) ,
                "::" , stringify ! ( cur_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpinDelayStatus ) ) . file as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SpinDelayStatus ) ,
                "::" , stringify ! ( file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpinDelayStatus ) ) . line as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SpinDelayStatus ) ,
                "::" , stringify ! ( line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpinDelayStatus ) ) . func as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SpinDelayStatus ) ,
                "::" , stringify ! ( func ) ));
}
impl Clone for SpinDelayStatus {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn perform_spin_delay(status: *mut SpinDelayStatus);
}
extern "C" {
    pub fn finish_spin_delay(status: *mut SpinDelayStatus);
}
#[repr(C)]
#[derive(Copy)]
pub struct PGPROC {
    pub links: SHM_QUEUE,
    pub procgloballist: *mut *mut PGPROC,
    pub sem: PGSemaphore,
    pub waitStatus: ::std::os::raw::c_int,
    pub procLatch: Latch,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub pgprocno: ::std::os::raw::c_int,
    pub backendId: BackendId,
    pub databaseId: Oid,
    pub roleId: Oid,
    pub isBackgroundWorker: bool_,
    pub recoveryConflictPending: bool_,
    pub lwWaiting: bool_,
    pub lwWaitMode: uint8,
    pub lwWaitLink: proclist_node,
    pub cvWaitLink: proclist_node,
    pub waitLock: *mut LOCK,
    pub waitProcLock: *mut PROCLOCK,
    pub waitLockMode: LOCKMODE,
    pub heldLocks: LOCKMASK,
    pub waitLSN: XLogRecPtr,
    pub syncRepState: ::std::os::raw::c_int,
    pub syncRepLinks: SHM_QUEUE,
    pub myProcLocks: [SHM_QUEUE; 16usize],
    pub subxids: XidCache,
    pub procArrayGroupMember: bool_,
    pub procArrayGroupNext: pg_atomic_uint32,
    pub procArrayGroupMemberXid: TransactionId,
    pub wait_event_info: uint32,
    pub backendLock: LWLock,
    pub fpLockBits: uint64,
    pub fpRelId: [Oid; 16usize],
    pub fpVXIDLock: bool_,
    pub fpLocalTransactionId: LocalTransactionId,
    pub lockGroupLeader: *mut PGPROC,
    pub lockGroupMembers: dlist_head,
    pub lockGroupLink: dlist_node,
}
#[test]
fn bindgen_test_layout_PGPROC() {
    assert_eq!(::std::mem::size_of::<PGPROC>() , 816usize , concat ! (
               "Size of: " , stringify ! ( PGPROC ) ));
    assert_eq! (::std::mem::align_of::<PGPROC>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PGPROC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . links as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . procgloballist as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( procgloballist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . sem as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( sem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . waitStatus as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( waitStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . procLatch as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( procLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lxid as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lxid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . pid as * const _ as usize }
                , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . pgprocno as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( pgprocno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . backendId as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( backendId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . databaseId as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( databaseId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . roleId as * const _ as usize
                } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( roleId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . isBackgroundWorker as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( isBackgroundWorker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . recoveryConflictPending as *
                const _ as usize } , 73usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( recoveryConflictPending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lwWaiting as * const _ as
                usize } , 74usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lwWaiting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lwWaitMode as * const _ as
                usize } , 75usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lwWaitMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lwWaitLink as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lwWaitLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . cvWaitLink as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( cvWaitLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . waitLock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( waitLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . waitProcLock as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( waitProcLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . waitLockMode as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( waitLockMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . heldLocks as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( heldLocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . waitLSN as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( waitLSN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . syncRepState as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( syncRepState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . syncRepLinks as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( syncRepLinks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . myProcLocks as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( myProcLocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . subxids as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( subxids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . procArrayGroupMember as *
                const _ as usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( procArrayGroupMember ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . procArrayGroupNext as *
                const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( procArrayGroupNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . procArrayGroupMemberXid as *
                const _ as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( procArrayGroupMemberXid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . wait_event_info as * const _
                as usize } , 676usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( wait_event_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . backendLock as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( backendLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . fpLockBits as * const _ as
                usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( fpLockBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . fpRelId as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( fpRelId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . fpVXIDLock as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( fpVXIDLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . fpLocalTransactionId as *
                const _ as usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( fpLocalTransactionId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lockGroupLeader as * const _
                as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lockGroupLeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lockGroupMembers as * const
                _ as usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lockGroupMembers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGPROC ) ) . lockGroupLink as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( PGPROC ) , "::" ,
                stringify ! ( lockGroupLink ) ));
}
impl Clone for PGPROC {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LWLock {
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: proclist_head,
}
#[test]
fn bindgen_test_layout_LWLock() {
    assert_eq!(::std::mem::size_of::<LWLock>() , 16usize , concat ! (
               "Size of: " , stringify ! ( LWLock ) ));
    assert_eq! (::std::mem::align_of::<LWLock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( LWLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLock ) ) . tranche as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLock ) , "::" ,
                stringify ! ( tranche ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLock ) ) . state as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLock ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLock ) ) . waiters as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLock ) , "::" ,
                stringify ! ( waiters ) ));
}
impl Clone for LWLock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union LWLockPadded {
    pub lock: LWLock,
    pub pad: [::std::os::raw::c_char; 128usize],
    _bindgen_union_align: [u32; 32usize],
}
#[test]
fn bindgen_test_layout_LWLockPadded() {
    assert_eq!(::std::mem::size_of::<LWLockPadded>() , 128usize , concat ! (
               "Size of: " , stringify ! ( LWLockPadded ) ));
    assert_eq! (::std::mem::align_of::<LWLockPadded>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( LWLockPadded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLockPadded ) ) . lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLockPadded ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLockPadded ) ) . pad as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLockPadded ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for LWLockPadded {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union LWLockMinimallyPadded {
    pub lock: LWLock,
    pub pad: [::std::os::raw::c_char; 32usize],
    _bindgen_union_align: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_LWLockMinimallyPadded() {
    assert_eq!(::std::mem::size_of::<LWLockMinimallyPadded>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( LWLockMinimallyPadded )
               ));
    assert_eq! (::std::mem::align_of::<LWLockMinimallyPadded>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( LWLockMinimallyPadded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLockMinimallyPadded ) ) . lock as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLockMinimallyPadded )
                , "::" , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LWLockMinimallyPadded ) ) . pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LWLockMinimallyPadded )
                , "::" , stringify ! ( pad ) ));
}
impl Clone for LWLockMinimallyPadded {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "MainLWLockArray"]
    pub static mut MainLWLockArray: *mut LWLockPadded;
}
extern "C" {
    #[link_name = "MainLWLockNames"]
    pub static mut MainLWLockNames: [*mut ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct NamedLWLockTranche {
    pub trancheId: ::std::os::raw::c_int,
    pub trancheName: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NamedLWLockTranche() {
    assert_eq!(::std::mem::size_of::<NamedLWLockTranche>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( NamedLWLockTranche ) ));
    assert_eq! (::std::mem::align_of::<NamedLWLockTranche>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( NamedLWLockTranche ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedLWLockTranche ) ) . trancheId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedLWLockTranche ) ,
                "::" , stringify ! ( trancheId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedLWLockTranche ) ) . trancheName as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedLWLockTranche ) ,
                "::" , stringify ! ( trancheName ) ));
}
impl Clone for NamedLWLockTranche {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "NamedLWLockTrancheArray"]
    pub static mut NamedLWLockTrancheArray: *mut NamedLWLockTranche;
}
extern "C" {
    #[link_name = "NamedLWLockTrancheRequests"]
    pub static mut NamedLWLockTrancheRequests: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LWLockMode {
    LW_EXCLUSIVE = 0,
    LW_SHARED = 1,
    LW_WAIT_UNTIL_FREE = 2,
}
extern "C" {
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> bool_;
}
extern "C" {
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode)
     -> bool_;
}
extern "C" {
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> bool_;
}
extern "C" {
    pub fn LWLockRelease(lock: *mut LWLock);
}
extern "C" {
    pub fn LWLockReleaseClearVar(lock: *mut LWLock, valptr: *mut uint64,
                                 val: uint64);
}
extern "C" {
    pub fn LWLockReleaseAll();
}
extern "C" {
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> bool_;
}
extern "C" {
    pub fn LWLockHeldByMeInMode(lock: *mut LWLock, mode: LWLockMode) -> bool_;
}
extern "C" {
    pub fn LWLockWaitForVar(lock: *mut LWLock, valptr: *mut uint64,
                            oldval: uint64, newval: *mut uint64) -> bool_;
}
extern "C" {
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64,
                           value: uint64);
}
extern "C" {
    pub fn LWLockShmemSize() -> Size;
}
extern "C" {
    pub fn CreateLWLocks();
}
extern "C" {
    pub fn InitLWLockAccess();
}
extern "C" {
    pub fn GetLWLockIdentifier(classId: uint32, eventId: uint16)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn RequestNamedLWLockTranche(tranche_name:
                                         *const ::std::os::raw::c_char,
                                     num_lwlocks: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetNamedLWLockTranche(tranche_name: *const ::std::os::raw::c_char)
     -> *mut LWLockPadded;
}
extern "C" {
    pub fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LWLockRegisterTranche(tranche_id: ::std::os::raw::c_int,
                                 tranche_name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn LWLockInitialize(lock: *mut LWLock,
                            tranche_id: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BuiltinTrancheIds {
    LWTRANCHE_CLOG_BUFFERS = 46,
    LWTRANCHE_COMMITTS_BUFFERS = 47,
    LWTRANCHE_SUBTRANS_BUFFERS = 48,
    LWTRANCHE_MXACTOFFSET_BUFFERS = 49,
    LWTRANCHE_MXACTMEMBER_BUFFERS = 50,
    LWTRANCHE_ASYNC_BUFFERS = 51,
    LWTRANCHE_OLDSERXID_BUFFERS = 52,
    LWTRANCHE_WAL_INSERT = 53,
    LWTRANCHE_BUFFER_CONTENT = 54,
    LWTRANCHE_BUFFER_IO_IN_PROGRESS = 55,
    LWTRANCHE_REPLICATION_ORIGIN = 56,
    LWTRANCHE_REPLICATION_SLOT_IO_IN_PROGRESS = 57,
    LWTRANCHE_PROC = 58,
    LWTRANCHE_BUFFER_MAPPING = 59,
    LWTRANCHE_LOCK_MANAGER = 60,
    LWTRANCHE_PREDICATE_LOCK_MANAGER = 61,
    LWTRANCHE_PARALLEL_QUERY_DSA = 62,
    LWTRANCHE_TBM = 63,
    LWTRANCHE_FIRST_USER_DEFINED = 64,
}
pub type LWLockId = *mut LWLock;
pub type HashValueFunc =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size) -> uint32>;
pub type HashCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> ::std::os::raw::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(dest:
                                                   *mut ::std::os::raw::c_void,
                                               src:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> *mut ::std::os::raw::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(request: Size)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Copy)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
#[test]
fn bindgen_test_layout_HASHELEMENT() {
    assert_eq!(::std::mem::size_of::<HASHELEMENT>() , 16usize , concat ! (
               "Size of: " , stringify ! ( HASHELEMENT ) ));
    assert_eq! (::std::mem::align_of::<HASHELEMENT>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HASHELEMENT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHELEMENT ) ) . link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHELEMENT ) , "::" ,
                stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHELEMENT ) ) . hashvalue as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHELEMENT ) , "::" ,
                stringify ! ( hashvalue ) ));
}
impl Clone for HASHELEMENT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHHDR {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTAB {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
#[test]
fn bindgen_test_layout_HASHCTL() {
    assert_eq!(::std::mem::size_of::<HASHCTL>() , 104usize , concat ! (
               "Size of: " , stringify ! ( HASHCTL ) ));
    assert_eq! (::std::mem::align_of::<HASHCTL>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HASHCTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . num_partitions as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( num_partitions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . ssize as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( ssize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . dsize as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( dsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . max_dsize as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( max_dsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . ffactor as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( ffactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . keysize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( keysize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . entrysize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( entrysize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . hash as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . match_ as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( match_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . keycopy as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( keycopy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . alloc as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . hcxt as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( hcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASHCTL ) ) . hctl as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( HASHCTL ) , "::" ,
                stringify ! ( hctl ) ));
}
impl Clone for HASHCTL {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HASHACTION {
    HASH_FIND = 0,
    HASH_ENTER = 1,
    HASH_REMOVE = 2,
    HASH_ENTER_NULL = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct HASH_SEQ_STATUS {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
#[test]
fn bindgen_test_layout_HASH_SEQ_STATUS() {
    assert_eq!(::std::mem::size_of::<HASH_SEQ_STATUS>() , 24usize , concat ! (
               "Size of: " , stringify ! ( HASH_SEQ_STATUS ) ));
    assert_eq! (::std::mem::align_of::<HASH_SEQ_STATUS>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( HASH_SEQ_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASH_SEQ_STATUS ) ) . hashp as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HASH_SEQ_STATUS ) ,
                "::" , stringify ! ( hashp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASH_SEQ_STATUS ) ) . curBucket as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HASH_SEQ_STATUS ) ,
                "::" , stringify ! ( curBucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HASH_SEQ_STATUS ) ) . curEntry as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( HASH_SEQ_STATUS ) ,
                "::" , stringify ! ( curEntry ) ));
}
impl Clone for HASH_SEQ_STATUS {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn hash_create(tabname: *const ::std::os::raw::c_char,
                       nelem: ::std::os::raw::c_long, info: *mut HASHCTL,
                       flags: ::std::os::raw::c_int) -> *mut HTAB;
}
extern "C" {
    pub fn hash_destroy(hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_stats(where_: *const ::std::os::raw::c_char,
                      hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_search(hashp: *mut HTAB,
                       keyPtr: *const ::std::os::raw::c_void,
                       action: HASHACTION, foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_hash_value(hashp: *mut HTAB,
                          keyPtr: *const ::std::os::raw::c_void) -> uint32;
}
extern "C" {
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::std::os::raw::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::std::os::raw::c_void,
                                newKeyPtr: *const ::std::os::raw::c_void)
     -> bool_;
}
extern "C" {
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
}
extern "C" {
    pub fn hash_freeze(hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long,
                              entrysize: Size) -> Size;
}
extern "C" {
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hash_get_shared_size(info: *mut HASHCTL,
                                flags: ::std::os::raw::c_int) -> Size;
}
extern "C" {
    pub fn AtEOXact_HashTables(isCommit: bool_);
}
extern "C" {
    pub fn AtEOSubXact_HashTables(isCommit: bool_,
                                  nestDepth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn string_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn tag_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn uint32_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn bitmap_match(key1: *const ::std::os::raw::c_void,
                        key2: *const ::std::os::raw::c_void, keysize: Size)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct SHM_QUEUE {
    pub prev: *mut SHM_QUEUE,
    pub next: *mut SHM_QUEUE,
}
#[test]
fn bindgen_test_layout_SHM_QUEUE() {
    assert_eq!(::std::mem::size_of::<SHM_QUEUE>() , 16usize , concat ! (
               "Size of: " , stringify ! ( SHM_QUEUE ) ));
    assert_eq! (::std::mem::align_of::<SHM_QUEUE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SHM_QUEUE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SHM_QUEUE ) ) . prev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SHM_QUEUE ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SHM_QUEUE ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SHM_QUEUE ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for SHM_QUEUE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitShmemAccess(seghdr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn InitShmemAllocation();
}
extern "C" {
    pub fn ShmemAlloc(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ShmemAllocNoError(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ShmemAllocUnlocked(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ShmemAddrIsValid(addr: *const ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn InitShmemIndex();
}
extern "C" {
    pub fn ShmemInitHash(name: *const ::std::os::raw::c_char,
                         init_size: ::std::os::raw::c_long,
                         max_size: ::std::os::raw::c_long,
                         infoP: *mut HASHCTL,
                         hash_flags: ::std::os::raw::c_int) -> *mut HTAB;
}
extern "C" {
    pub fn ShmemInitStruct(name: *const ::std::os::raw::c_char, size: Size,
                           foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn add_size(s1: Size, s2: Size) -> Size;
}
extern "C" {
    pub fn mul_size(s1: Size, s2: Size) -> Size;
}
extern "C" {
    pub fn RequestAddinShmemSpace(size: Size);
}
#[repr(C)]
#[derive(Copy)]
pub struct ShmemIndexEnt {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
}
#[test]
fn bindgen_test_layout_ShmemIndexEnt() {
    assert_eq!(::std::mem::size_of::<ShmemIndexEnt>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ShmemIndexEnt ) ));
    assert_eq! (::std::mem::align_of::<ShmemIndexEnt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ShmemIndexEnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ShmemIndexEnt ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ShmemIndexEnt ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ShmemIndexEnt ) ) . location as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ShmemIndexEnt ) , "::"
                , stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ShmemIndexEnt ) ) . size as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ShmemIndexEnt ) , "::"
                , stringify ! ( size ) ));
}
impl Clone for ShmemIndexEnt {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
}
extern "C" {
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
}
extern "C" {
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> bool_;
}
extern "C" {
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> bool_;
}
#[repr(C)]
#[derive(Copy)]
pub struct PROC_QUEUE {
    pub links: SHM_QUEUE,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROC_QUEUE() {
    assert_eq!(::std::mem::size_of::<PROC_QUEUE>() , 24usize , concat ! (
               "Size of: " , stringify ! ( PROC_QUEUE ) ));
    assert_eq! (::std::mem::align_of::<PROC_QUEUE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PROC_QUEUE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_QUEUE ) ) . links as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_QUEUE ) , "::" ,
                stringify ! ( links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_QUEUE ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_QUEUE ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for PROC_QUEUE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "max_locks_per_xact"]
    pub static mut max_locks_per_xact: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct VirtualTransactionId {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
#[test]
fn bindgen_test_layout_VirtualTransactionId() {
    assert_eq!(::std::mem::size_of::<VirtualTransactionId>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( VirtualTransactionId ) ));
    assert_eq! (::std::mem::align_of::<VirtualTransactionId>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VirtualTransactionId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VirtualTransactionId ) ) . backendId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VirtualTransactionId )
                , "::" , stringify ! ( backendId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VirtualTransactionId ) ) .
                localTransactionId as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( VirtualTransactionId )
                , "::" , stringify ! ( localTransactionId ) ));
}
impl Clone for VirtualTransactionId {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockMethodData {
    pub numLockModes: ::std::os::raw::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::std::os::raw::c_char,
    pub trace_flag: *const bool_,
}
#[test]
fn bindgen_test_layout_LockMethodData() {
    assert_eq!(::std::mem::size_of::<LockMethodData>() , 32usize , concat ! (
               "Size of: " , stringify ! ( LockMethodData ) ));
    assert_eq! (::std::mem::align_of::<LockMethodData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockMethodData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockMethodData ) ) . numLockModes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockMethodData ) , "::"
                , stringify ! ( numLockModes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockMethodData ) ) . conflictTab as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LockMethodData ) , "::"
                , stringify ! ( conflictTab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockMethodData ) ) . lockModeNames as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LockMethodData ) , "::"
                , stringify ! ( lockModeNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockMethodData ) ) . trace_flag as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( LockMethodData ) , "::"
                , stringify ! ( trace_flag ) ));
}
impl Clone for LockMethodData {
    fn clone(&self) -> Self { *self }
}
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockTagType {
    LOCKTAG_RELATION = 0,
    LOCKTAG_RELATION_EXTEND = 1,
    LOCKTAG_PAGE = 2,
    LOCKTAG_TUPLE = 3,
    LOCKTAG_TRANSACTION = 4,
    LOCKTAG_VIRTUALTRANSACTION = 5,
    LOCKTAG_SPECULATIVE_TOKEN = 6,
    LOCKTAG_OBJECT = 7,
    LOCKTAG_USERLOCK = 8,
    LOCKTAG_ADVISORY = 9,
}
extern "C" {
    #[link_name = "LockTagTypeNames"]
    pub static mut LockTagTypeNames: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
#[test]
fn bindgen_test_layout_LOCKTAG() {
    assert_eq!(::std::mem::size_of::<LOCKTAG>() , 16usize , concat ! (
               "Size of: " , stringify ! ( LOCKTAG ) ));
    assert_eq! (::std::mem::align_of::<LOCKTAG>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( LOCKTAG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCKTAG ) ) . locktag_field1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCKTAG ) , "::" ,
                stringify ! ( locktag_field1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCKTAG ) ) . locktag_field2 as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCKTAG ) , "::" ,
                stringify ! ( locktag_field2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCKTAG ) ) . locktag_field3 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCKTAG ) , "::" ,
                stringify ! ( locktag_field3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCKTAG ) ) . locktag_field4 as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCKTAG ) , "::" ,
                stringify ! ( locktag_field4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCKTAG ) ) . locktag_type as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCKTAG ) , "::" ,
                stringify ! ( locktag_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCKTAG ) ) . locktag_lockmethodid as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCKTAG ) , "::" ,
                stringify ! ( locktag_lockmethodid ) ));
}
impl Clone for LOCKTAG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: SHM_QUEUE,
    pub waitProcs: PROC_QUEUE,
    pub requested: [::std::os::raw::c_int; 10usize],
    pub nRequested: ::std::os::raw::c_int,
    pub granted: [::std::os::raw::c_int; 10usize],
    pub nGranted: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LOCK() {
    assert_eq!(::std::mem::size_of::<LOCK>() , 152usize , concat ! (
               "Size of: " , stringify ! ( LOCK ) ));
    assert_eq! (::std::mem::align_of::<LOCK>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LOCK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . tag as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . grantMask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( grantMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . waitMask as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( waitMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . procLocks as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( procLocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . waitProcs as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( waitProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . requested as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( requested ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . nRequested as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( nRequested ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . granted as * const _ as usize
                } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( granted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCK ) ) . nGranted as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCK ) , "::" ,
                stringify ! ( nGranted ) ));
}
impl Clone for LOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
#[test]
fn bindgen_test_layout_PROCLOCKTAG() {
    assert_eq!(::std::mem::size_of::<PROCLOCKTAG>() , 16usize , concat ! (
               "Size of: " , stringify ! ( PROCLOCKTAG ) ));
    assert_eq! (::std::mem::align_of::<PROCLOCKTAG>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PROCLOCKTAG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCKTAG ) ) . myLock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCKTAG ) , "::" ,
                stringify ! ( myLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCKTAG ) ) . myProc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCKTAG ) , "::" ,
                stringify ! ( myProc ) ));
}
impl Clone for PROCLOCKTAG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub groupLeader: *mut PGPROC,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: SHM_QUEUE,
    pub procLink: SHM_QUEUE,
}
#[test]
fn bindgen_test_layout_PROCLOCK() {
    assert_eq!(::std::mem::size_of::<PROCLOCK>() , 64usize , concat ! (
               "Size of: " , stringify ! ( PROCLOCK ) ));
    assert_eq! (::std::mem::align_of::<PROCLOCK>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PROCLOCK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCK ) ) . tag as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCK ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCK ) ) . groupLeader as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCK ) , "::" ,
                stringify ! ( groupLeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCK ) ) . holdMask as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCK ) , "::" ,
                stringify ! ( holdMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCK ) ) . releaseMask as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCK ) , "::" ,
                stringify ! ( releaseMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCK ) ) . lockLink as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCK ) , "::" ,
                stringify ! ( lockLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROCLOCK ) ) . procLink as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PROCLOCK ) , "::" ,
                stringify ! ( procLink ) ));
}
impl Clone for PROCLOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
#[test]
fn bindgen_test_layout_LOCALLOCKTAG() {
    assert_eq!(::std::mem::size_of::<LOCALLOCKTAG>() , 20usize , concat ! (
               "Size of: " , stringify ! ( LOCALLOCKTAG ) ));
    assert_eq! (::std::mem::align_of::<LOCALLOCKTAG>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( LOCALLOCKTAG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCKTAG ) ) . lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCKTAG ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCKTAG ) ) . mode as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCKTAG ) , "::" ,
                stringify ! ( mode ) ));
}
impl Clone for LOCALLOCKTAG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LOCALLOCKOWNER {
    pub owner: *mut ResourceOwnerData,
    pub nLocks: int64,
}
#[test]
fn bindgen_test_layout_LOCALLOCKOWNER() {
    assert_eq!(::std::mem::size_of::<LOCALLOCKOWNER>() , 16usize , concat ! (
               "Size of: " , stringify ! ( LOCALLOCKOWNER ) ));
    assert_eq! (::std::mem::align_of::<LOCALLOCKOWNER>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LOCALLOCKOWNER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCKOWNER ) ) . owner as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCKOWNER ) , "::"
                , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCKOWNER ) ) . nLocks as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCKOWNER ) , "::"
                , stringify ! ( nLocks ) ));
}
impl Clone for LOCALLOCKOWNER {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub hashcode: uint32,
    pub nLocks: int64,
    pub numLockOwners: ::std::os::raw::c_int,
    pub maxLockOwners: ::std::os::raw::c_int,
    pub holdsStrongLockCount: bool_,
    pub lockOwners: *mut LOCALLOCKOWNER,
}
#[test]
fn bindgen_test_layout_LOCALLOCK() {
    assert_eq!(::std::mem::size_of::<LOCALLOCK>() , 80usize , concat ! (
               "Size of: " , stringify ! ( LOCALLOCK ) ));
    assert_eq! (::std::mem::align_of::<LOCALLOCK>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LOCALLOCK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . tag as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . lock as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . proclock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( proclock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . hashcode as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( hashcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . nLocks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( nLocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . numLockOwners as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( numLockOwners ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . maxLockOwners as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( maxLockOwners ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . holdsStrongLockCount as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( holdsStrongLockCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LOCALLOCK ) ) . lockOwners as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( LOCALLOCK ) , "::" ,
                stringify ! ( lockOwners ) ));
}
impl Clone for LOCALLOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub leaderPid: ::std::os::raw::c_int,
    pub fastpath: bool_,
}
#[test]
fn bindgen_test_layout_LockInstanceData() {
    assert_eq!(::std::mem::size_of::<LockInstanceData>() , 44usize , concat !
               ( "Size of: " , stringify ! ( LockInstanceData ) ));
    assert_eq! (::std::mem::align_of::<LockInstanceData>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( LockInstanceData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . locktag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( locktag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . holdMask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( holdMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . waitLockMode as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( waitLockMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . backend as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( backend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . lxid as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( lxid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . pid as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . leaderPid as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( leaderPid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInstanceData ) ) . fastpath as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInstanceData ) ,
                "::" , stringify ! ( fastpath ) ));
}
impl Clone for LockInstanceData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockData {
    pub nelements: ::std::os::raw::c_int,
    pub locks: *mut LockInstanceData,
}
#[test]
fn bindgen_test_layout_LockData() {
    assert_eq!(::std::mem::size_of::<LockData>() , 16usize , concat ! (
               "Size of: " , stringify ! ( LockData ) ));
    assert_eq! (::std::mem::align_of::<LockData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockData ) ) . nelements as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockData ) , "::" ,
                stringify ! ( nelements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockData ) ) . locks as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LockData ) , "::" ,
                stringify ! ( locks ) ));
}
impl Clone for LockData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BlockedProcData {
    pub pid: ::std::os::raw::c_int,
    pub first_lock: ::std::os::raw::c_int,
    pub num_locks: ::std::os::raw::c_int,
    pub first_waiter: ::std::os::raw::c_int,
    pub num_waiters: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BlockedProcData() {
    assert_eq!(::std::mem::size_of::<BlockedProcData>() , 20usize , concat ! (
               "Size of: " , stringify ! ( BlockedProcData ) ));
    assert_eq! (::std::mem::align_of::<BlockedProcData>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( BlockedProcData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcData ) ) . pid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcData ) ,
                "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcData ) ) . first_lock as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcData ) ,
                "::" , stringify ! ( first_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcData ) ) . num_locks as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcData ) ,
                "::" , stringify ! ( num_locks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcData ) ) . first_waiter as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcData ) ,
                "::" , stringify ! ( first_waiter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcData ) ) . num_waiters as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcData ) ,
                "::" , stringify ! ( num_waiters ) ));
}
impl Clone for BlockedProcData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BlockedProcsData {
    pub procs: *mut BlockedProcData,
    pub locks: *mut LockInstanceData,
    pub waiter_pids: *mut ::std::os::raw::c_int,
    pub nprocs: ::std::os::raw::c_int,
    pub maxprocs: ::std::os::raw::c_int,
    pub nlocks: ::std::os::raw::c_int,
    pub maxlocks: ::std::os::raw::c_int,
    pub npids: ::std::os::raw::c_int,
    pub maxpids: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BlockedProcsData() {
    assert_eq!(::std::mem::size_of::<BlockedProcsData>() , 48usize , concat !
               ( "Size of: " , stringify ! ( BlockedProcsData ) ));
    assert_eq! (::std::mem::align_of::<BlockedProcsData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( BlockedProcsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . procs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( procs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . locks as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( locks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . waiter_pids as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( waiter_pids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . nprocs as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( nprocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . maxprocs as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( maxprocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . nlocks as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( nlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . maxlocks as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( maxlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . npids as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( npids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BlockedProcsData ) ) . maxpids as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( BlockedProcsData ) ,
                "::" , stringify ! ( maxpids ) ));
}
impl Clone for BlockedProcsData {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockAcquireResult {
    LOCKACQUIRE_NOT_AVAIL = 0,
    LOCKACQUIRE_OK = 1,
    LOCKACQUIRE_ALREADY_HELD = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DeadLockState {
    DS_NOT_YET_CHECKED = 0,
    DS_NO_DEADLOCK = 1,
    DS_SOFT_DEADLOCK = 2,
    DS_HARD_DEADLOCK = 3,
    DS_BLOCKED_BY_AUTOVACUUM = 4,
}
extern "C" {
    pub fn InitLocks();
}
extern "C" {
    pub fn GetLocksMethodTable(lock: *const LOCK) -> LockMethod;
}
extern "C" {
    pub fn GetLockTagsMethodTable(locktag: *const LOCKTAG) -> LockMethod;
}
extern "C" {
    pub fn LockTagHashCode(locktag: *const LOCKTAG) -> uint32;
}
extern "C" {
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> bool_;
}
extern "C" {
    pub fn LockAcquire(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: bool_, dontWait: bool_)
     -> LockAcquireResult;
}
extern "C" {
    pub fn LockAcquireExtended(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                               sessionLock: bool_, dontWait: bool_,
                               report_memory_error: bool_)
     -> LockAcquireResult;
}
extern "C" {
    pub fn AbortStrongLockAcquire();
}
extern "C" {
    pub fn LockRelease(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: bool_) -> bool_;
}
extern "C" {
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: bool_);
}
extern "C" {
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID);
}
extern "C" {
    pub fn LockReleaseCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                   nlocks: ::std::os::raw::c_int);
}
extern "C" {
    pub fn LockReassignCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                    nlocks: ::std::os::raw::c_int);
}
extern "C" {
    pub fn LockHasWaiters(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                          sessionLock: bool_) -> bool_;
}
extern "C" {
    pub fn GetLockConflicts(locktag: *const LOCKTAG, lockmode: LOCKMODE)
     -> *mut VirtualTransactionId;
}
extern "C" {
    pub fn AtPrepare_Locks();
}
extern "C" {
    pub fn PostPrepare_Locks(xid: TransactionId);
}
extern "C" {
    pub fn LockCheckConflicts(lockMethodTable: LockMethod, lockmode: LOCKMODE,
                              lock: *mut LOCK, proclock: *mut PROCLOCK)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GrantLock(lock: *mut LOCK, proclock: *mut PROCLOCK,
                     lockmode: LOCKMODE);
}
extern "C" {
    pub fn GrantAwaitedLock();
}
extern "C" {
    pub fn RemoveFromWaitQueue(proc_: *mut PGPROC, hashcode: uint32);
}
extern "C" {
    pub fn LockShmemSize() -> Size;
}
extern "C" {
    pub fn GetLockStatusData() -> *mut LockData;
}
extern "C" {
    pub fn GetBlockerStatusData(blocked_pid: ::std::os::raw::c_int)
     -> *mut BlockedProcsData;
}
extern "C" {
    pub fn GetRunningTransactionLocks(nlocks: *mut ::std::os::raw::c_int)
     -> *mut xl_standby_lock;
}
extern "C" {
    pub fn GetLockmodeName(lockmethodid: LOCKMETHODID, mode: LOCKMODE)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lock_twophase_recover(xid: TransactionId, info: uint16,
                                 recdata: *mut ::std::os::raw::c_void,
                                 len: uint32);
}
extern "C" {
    pub fn lock_twophase_postcommit(xid: TransactionId, info: uint16,
                                    recdata: *mut ::std::os::raw::c_void,
                                    len: uint32);
}
extern "C" {
    pub fn lock_twophase_postabort(xid: TransactionId, info: uint16,
                                   recdata: *mut ::std::os::raw::c_void,
                                   len: uint32);
}
extern "C" {
    pub fn lock_twophase_standby_recover(xid: TransactionId, info: uint16,
                                         recdata: *mut ::std::os::raw::c_void,
                                         len: uint32);
}
extern "C" {
    pub fn DeadLockCheck(proc_: *mut PGPROC) -> DeadLockState;
}
extern "C" {
    pub fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
}
extern "C" {
    pub fn DeadLockReport();
}
extern "C" {
    pub fn RememberSimpleDeadLock(proc1: *mut PGPROC, lockmode: LOCKMODE,
                                  lock: *mut LOCK, proc2: *mut PGPROC);
}
extern "C" {
    pub fn InitDeadLockChecking();
}
extern "C" {
    pub fn LockWaiterCount(locktag: *const LOCKTAG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId);
}
extern "C" {
    pub fn VirtualXactLockTableCleanup();
}
extern "C" {
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: bool_) -> bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum relopt_type {
    RELOPT_TYPE_BOOL = 0,
    RELOPT_TYPE_INT = 1,
    RELOPT_TYPE_REAL = 2,
    RELOPT_TYPE_STRING = 3,
}
pub const relopt_kind_RELOPT_KIND_LAST_DEFAULT: relopt_kind =
    relopt_kind::RELOPT_KIND_PARTITIONED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum relopt_kind {
    RELOPT_KIND_HEAP = 1,
    RELOPT_KIND_TOAST = 2,
    RELOPT_KIND_BTREE = 4,
    RELOPT_KIND_HASH = 8,
    RELOPT_KIND_GIN = 16,
    RELOPT_KIND_GIST = 32,
    RELOPT_KIND_ATTRIBUTE = 64,
    RELOPT_KIND_TABLESPACE = 128,
    RELOPT_KIND_SPGIST = 256,
    RELOPT_KIND_VIEW = 512,
    RELOPT_KIND_BRIN = 1024,
    RELOPT_KIND_PARTITIONED = 2048,
    RELOPT_KIND_MAX = 1073741824,
}
#[repr(C)]
#[derive(Copy)]
pub struct relopt_gen {
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub kinds: bits32,
    pub lockmode: LOCKMODE,
    pub namelen: ::std::os::raw::c_int,
    pub type_: relopt_type,
}
#[test]
fn bindgen_test_layout_relopt_gen() {
    assert_eq!(::std::mem::size_of::<relopt_gen>() , 32usize , concat ! (
               "Size of: " , stringify ! ( relopt_gen ) ));
    assert_eq! (::std::mem::align_of::<relopt_gen>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( relopt_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_gen ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_gen ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_gen ) ) . desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_gen ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_gen ) ) . kinds as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_gen ) , "::" ,
                stringify ! ( kinds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_gen ) ) . lockmode as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_gen ) , "::" ,
                stringify ! ( lockmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_gen ) ) . namelen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_gen ) , "::" ,
                stringify ! ( namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_gen ) ) . type_ as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_gen ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for relopt_gen {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct relopt_value {
    pub gen: *mut relopt_gen,
    pub isset: bool_,
    pub values: relopt_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union relopt_value__bindgen_ty_1 {
    pub bool_val: bool_,
    pub int_val: ::std::os::raw::c_int,
    pub real_val: f64,
    pub string_val: *mut ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_relopt_value__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<relopt_value__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( relopt_value__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<relopt_value__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( relopt_value__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value__bindgen_ty_1 ) ) . bool_val
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                relopt_value__bindgen_ty_1 ) , "::" , stringify ! ( bool_val )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value__bindgen_ty_1 ) ) . int_val
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                relopt_value__bindgen_ty_1 ) , "::" , stringify ! ( int_val )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value__bindgen_ty_1 ) ) . real_val
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                relopt_value__bindgen_ty_1 ) , "::" , stringify ! ( real_val )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value__bindgen_ty_1 ) ) .
                string_val as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                relopt_value__bindgen_ty_1 ) , "::" , stringify ! ( string_val
                ) ));
}
impl Clone for relopt_value__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_relopt_value() {
    assert_eq!(::std::mem::size_of::<relopt_value>() , 24usize , concat ! (
               "Size of: " , stringify ! ( relopt_value ) ));
    assert_eq! (::std::mem::align_of::<relopt_value>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( relopt_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_value ) , "::" ,
                stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value ) ) . isset as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_value ) , "::" ,
                stringify ! ( isset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_value ) ) . values as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_value ) , "::" ,
                stringify ! ( values ) ));
}
impl Clone for relopt_value {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool_,
}
#[test]
fn bindgen_test_layout_relopt_bool() {
    assert_eq!(::std::mem::size_of::<relopt_bool>() , 40usize , concat ! (
               "Size of: " , stringify ! ( relopt_bool ) ));
    assert_eq! (::std::mem::align_of::<relopt_bool>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( relopt_bool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_bool ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_bool ) , "::" ,
                stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_bool ) ) . default_val as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_bool ) , "::" ,
                stringify ! ( default_val ) ));
}
impl Clone for relopt_bool {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_relopt_int() {
    assert_eq!(::std::mem::size_of::<relopt_int>() , 48usize , concat ! (
               "Size of: " , stringify ! ( relopt_int ) ));
    assert_eq! (::std::mem::align_of::<relopt_int>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( relopt_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_int ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_int ) , "::" ,
                stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_int ) ) . default_val as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_int ) , "::" ,
                stringify ! ( default_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_int ) ) . min as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_int ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_int ) ) . max as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_int ) , "::" ,
                stringify ! ( max ) ));
}
impl Clone for relopt_int {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
#[test]
fn bindgen_test_layout_relopt_real() {
    assert_eq!(::std::mem::size_of::<relopt_real>() , 56usize , concat ! (
               "Size of: " , stringify ! ( relopt_real ) ));
    assert_eq! (::std::mem::align_of::<relopt_real>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( relopt_real ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_real ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_real ) , "::" ,
                stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_real ) ) . default_val as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_real ) , "::" ,
                stringify ! ( default_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_real ) ) . min as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_real ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_real ) ) . max as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_real ) , "::" ,
                stringify ! ( max ) ));
}
impl Clone for relopt_real {
    fn clone(&self) -> Self { *self }
}
pub type validate_string_relopt =
    ::std::option::Option<unsafe extern "C" fn(value:
                                                   *mut ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Copy)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::std::os::raw::c_int,
    pub default_isnull: bool_,
    pub validate_cb: validate_string_relopt,
    pub default_val: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_relopt_string() {
    assert_eq!(::std::mem::size_of::<relopt_string>() , 56usize , concat ! (
               "Size of: " , stringify ! ( relopt_string ) ));
    assert_eq! (::std::mem::align_of::<relopt_string>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( relopt_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_string ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_string ) , "::"
                , stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_string ) ) . default_len as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_string ) , "::"
                , stringify ! ( default_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_string ) ) . default_isnull as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_string ) , "::"
                , stringify ! ( default_isnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_string ) ) . validate_cb as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_string ) , "::"
                , stringify ! ( validate_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_string ) ) . default_val as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_string ) , "::"
                , stringify ! ( default_val ) ));
}
impl Clone for relopt_string {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct relopt_parse_elt {
    pub optname: *const ::std::os::raw::c_char,
    pub opttype: relopt_type,
    pub offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_relopt_parse_elt() {
    assert_eq!(::std::mem::size_of::<relopt_parse_elt>() , 16usize , concat !
               ( "Size of: " , stringify ! ( relopt_parse_elt ) ));
    assert_eq! (::std::mem::align_of::<relopt_parse_elt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( relopt_parse_elt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_parse_elt ) ) . optname as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_parse_elt ) ,
                "::" , stringify ! ( optname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_parse_elt ) ) . opttype as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_parse_elt ) ,
                "::" , stringify ! ( opttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const relopt_parse_elt ) ) . offset as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( relopt_parse_elt ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for relopt_parse_elt {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn add_reloption_kind() -> relopt_kind;
}
extern "C" {
    pub fn add_bool_reloption(kinds: bits32,
                              name: *mut ::std::os::raw::c_char,
                              desc: *mut ::std::os::raw::c_char,
                              default_val: bool_);
}
extern "C" {
    pub fn add_int_reloption(kinds: bits32, name: *mut ::std::os::raw::c_char,
                             desc: *mut ::std::os::raw::c_char,
                             default_val: ::std::os::raw::c_int,
                             min_val: ::std::os::raw::c_int,
                             max_val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn add_real_reloption(kinds: bits32,
                              name: *mut ::std::os::raw::c_char,
                              desc: *mut ::std::os::raw::c_char,
                              default_val: f64, min_val: f64, max_val: f64);
}
extern "C" {
    pub fn add_string_reloption(kinds: bits32,
                                name: *mut ::std::os::raw::c_char,
                                desc: *mut ::std::os::raw::c_char,
                                default_val: *mut ::std::os::raw::c_char,
                                validator: validate_string_relopt);
}
extern "C" {
    pub fn transformRelOptions(oldOptions: Datum, defList: *mut List,
                               namspace: *mut ::std::os::raw::c_char,
                               validnsps: *mut *mut ::std::os::raw::c_char,
                               ignoreOids: bool_, isReset: bool_) -> Datum;
}
extern "C" {
    pub fn untransformRelOptions(options: Datum) -> *mut List;
}
extern "C" {
    pub fn extractRelOptions(tuple: HeapTuple, tupdesc: TupleDesc,
                             amoptions: amoptions_function) -> *mut bytea;
}
extern "C" {
    pub fn parseRelOptions(options: Datum, validate: bool_, kind: relopt_kind,
                           numrelopts: *mut ::std::os::raw::c_int)
     -> *mut relopt_value;
}
extern "C" {
    pub fn allocateReloptStruct(base: Size, options: *mut relopt_value,
                                numoptions: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn fillRelOptions(rdopts: *mut ::std::os::raw::c_void, basesize: Size,
                          options: *mut relopt_value,
                          numoptions: ::std::os::raw::c_int, validate: bool_,
                          elems: *const relopt_parse_elt,
                          nelems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn default_reloptions(reloptions: Datum, validate: bool_,
                              kind: relopt_kind) -> *mut bytea;
}
extern "C" {
    pub fn heap_reloptions(relkind: ::std::os::raw::c_char, reloptions: Datum,
                           validate: bool_) -> *mut bytea;
}
extern "C" {
    pub fn view_reloptions(reloptions: Datum, validate: bool_) -> *mut bytea;
}
extern "C" {
    pub fn index_reloptions(amoptions: amoptions_function, reloptions: Datum,
                            validate: bool_) -> *mut bytea;
}
extern "C" {
    pub fn attribute_reloptions(reloptions: Datum, validate: bool_)
     -> *mut bytea;
}
extern "C" {
    pub fn tablespace_reloptions(reloptions: Datum, validate: bool_)
     -> *mut bytea;
}
extern "C" {
    pub fn AlterTableGetRelOptionsLockLevel(defList: *mut List) -> LOCKMODE;
}
#[repr(C)]
#[derive(Copy)]
pub struct dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_node() {
    assert_eq!(::std::mem::size_of::<dlist_node>() , 16usize , concat ! (
               "Size of: " , stringify ! ( dlist_node ) ));
    assert_eq! (::std::mem::align_of::<dlist_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dlist_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_node ) ) . prev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_node ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_node ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_node ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for dlist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dlist_head {
    pub head: dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_head() {
    assert_eq!(::std::mem::size_of::<dlist_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( dlist_head ) ));
    assert_eq! (::std::mem::align_of::<dlist_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dlist_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_head ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_head ) , "::" ,
                stringify ! ( head ) ));
}
impl Clone for dlist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_iter() {
    assert_eq!(::std::mem::size_of::<dlist_iter>() , 16usize , concat ! (
               "Size of: " , stringify ! ( dlist_iter ) ));
    assert_eq! (::std::mem::align_of::<dlist_iter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dlist_iter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_iter ) ) . cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_iter ) , "::" ,
                stringify ! ( cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_iter ) ) . end as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_iter ) , "::" ,
                stringify ! ( end ) ));
}
impl Clone for dlist_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_mutable_iter() {
    assert_eq!(::std::mem::size_of::<dlist_mutable_iter>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( dlist_mutable_iter ) ));
    assert_eq! (::std::mem::align_of::<dlist_mutable_iter>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( dlist_mutable_iter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_mutable_iter ) ) . cur as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_mutable_iter ) ,
                "::" , stringify ! ( cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_mutable_iter ) ) . next as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_mutable_iter ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dlist_mutable_iter ) ) . end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dlist_mutable_iter ) ,
                "::" , stringify ! ( end ) ));
}
impl Clone for dlist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct slist_node {
    pub next: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_node() {
    assert_eq!(::std::mem::size_of::<slist_node>() , 8usize , concat ! (
               "Size of: " , stringify ! ( slist_node ) ));
    assert_eq! (::std::mem::align_of::<slist_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( slist_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slist_node ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( slist_node ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for slist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct slist_head {
    pub head: slist_node,
}
#[test]
fn bindgen_test_layout_slist_head() {
    assert_eq!(::std::mem::size_of::<slist_head>() , 8usize , concat ! (
               "Size of: " , stringify ! ( slist_head ) ));
    assert_eq! (::std::mem::align_of::<slist_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( slist_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slist_head ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( slist_head ) , "::" ,
                stringify ! ( head ) ));
}
impl Clone for slist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct slist_iter {
    pub cur: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_iter() {
    assert_eq!(::std::mem::size_of::<slist_iter>() , 8usize , concat ! (
               "Size of: " , stringify ! ( slist_iter ) ));
    assert_eq! (::std::mem::align_of::<slist_iter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( slist_iter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slist_iter ) ) . cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( slist_iter ) , "::" ,
                stringify ! ( cur ) ));
}
impl Clone for slist_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_mutable_iter() {
    assert_eq!(::std::mem::size_of::<slist_mutable_iter>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( slist_mutable_iter ) ));
    assert_eq! (::std::mem::align_of::<slist_mutable_iter>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( slist_mutable_iter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slist_mutable_iter ) ) . cur as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( slist_mutable_iter ) ,
                "::" , stringify ! ( cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slist_mutable_iter ) ) . next as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( slist_mutable_iter ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slist_mutable_iter ) ) . prev as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( slist_mutable_iter ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for slist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node);
}
pub type bgworker_main_type =
    ::std::option::Option<unsafe extern "C" fn(main_arg: Datum)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BgWorkerStartTime {
    BgWorkerStart_PostmasterStart = 0,
    BgWorkerStart_ConsistentState = 1,
    BgWorkerStart_RecoveryFinished = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct BackgroundWorker {
    pub bgw_name: [::std::os::raw::c_char; 64usize],
    pub bgw_flags: ::std::os::raw::c_int,
    pub bgw_start_time: BgWorkerStartTime,
    pub bgw_restart_time: ::std::os::raw::c_int,
    pub bgw_library_name: [::std::os::raw::c_char; 64usize],
    pub bgw_function_name: [::std::os::raw::c_char; 64usize],
    pub bgw_main_arg: Datum,
    pub bgw_extra: [::std::os::raw::c_char; 128usize],
    pub bgw_notify_pid: pid_t,
}
#[test]
fn bindgen_test_layout_BackgroundWorker() {
    assert_eq!(::std::mem::size_of::<BackgroundWorker>() , 352usize , concat !
               ( "Size of: " , stringify ! ( BackgroundWorker ) ));
    assert_eq! (::std::mem::align_of::<BackgroundWorker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( BackgroundWorker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_flags as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_start_time as
                * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_restart_time
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_restart_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_library_name
                as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_library_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_function_name
                as * const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_function_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_main_arg as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_main_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_extra as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BackgroundWorker ) ) . bgw_notify_pid as
                * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( BackgroundWorker ) ,
                "::" , stringify ! ( bgw_notify_pid ) ));
}
impl Clone for BackgroundWorker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BgwHandleStatus {
    BGWH_STARTED = 0,
    BGWH_NOT_YET_STARTED = 1,
    BGWH_STOPPED = 2,
    BGWH_POSTMASTER_DIED = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorkerHandle {
    _unused: [u8; 0],
}
extern "C" {
    pub fn RegisterBackgroundWorker(worker: *mut BackgroundWorker);
}
extern "C" {
    pub fn RegisterDynamicBackgroundWorker(worker: *mut BackgroundWorker,
                                           handle:
                                               *mut *mut BackgroundWorkerHandle)
     -> bool_;
}
extern "C" {
    pub fn GetBackgroundWorkerPid(handle: *mut BackgroundWorkerHandle,
                                  pidp: *mut pid_t) -> BgwHandleStatus;
}
extern "C" {
    pub fn WaitForBackgroundWorkerStartup(handle: *mut BackgroundWorkerHandle,
                                          pid: *mut pid_t) -> BgwHandleStatus;
}
extern "C" {
    pub fn WaitForBackgroundWorkerShutdown(arg1: *mut BackgroundWorkerHandle)
     -> BgwHandleStatus;
}
extern "C" {
    pub fn TerminateBackgroundWorker(handle: *mut BackgroundWorkerHandle);
}
extern "C" {
    #[link_name = "MyBgworkerEntry"]
    pub static mut MyBgworkerEntry: *mut BackgroundWorker;
}
extern "C" {
    pub fn BackgroundWorkerInitializeConnection(dbname:
                                                    *mut ::std::os::raw::c_char,
                                                username:
                                                    *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn BackgroundWorkerInitializeConnectionByOid(dboid: Oid,
                                                     useroid: Oid);
}
extern "C" {
    pub fn BackgroundWorkerBlockSignals();
}
extern "C" {
    pub fn BackgroundWorkerUnblockSignals();
}
extern "C" {
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_uid ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_tid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_overrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_status as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_utime as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_stime as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_stime ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub si_addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _lower ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _upper as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _upper ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_lsb as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_lsb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_bnd as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_bnd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_fd as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_fd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _call_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _call_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _syscall as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _syscall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _arch as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _arch ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1>() , 112usize ,
               concat ! (
               "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _kill as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _kill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _rt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _rt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigchld as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigchld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigfault
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigfault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigpoll as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigpoll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigsys as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigsys ) ));
}
impl Clone for siginfo_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(::std::mem::size_of::<siginfo_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( siginfo_t ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( siginfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . _sifields as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( _sifields ) ));
}
impl Clone for siginfo_t {
    fn clone(&self) -> Self { *self }
}
pub const SI_ASYNCNL: _bindgen_ty_8 = _bindgen_ty_8::SI_ASYNCNL;
pub const SI_TKILL: _bindgen_ty_8 = _bindgen_ty_8::SI_TKILL;
pub const SI_SIGIO: _bindgen_ty_8 = _bindgen_ty_8::SI_SIGIO;
pub const SI_ASYNCIO: _bindgen_ty_8 = _bindgen_ty_8::SI_ASYNCIO;
pub const SI_MESGQ: _bindgen_ty_8 = _bindgen_ty_8::SI_MESGQ;
pub const SI_TIMER: _bindgen_ty_8 = _bindgen_ty_8::SI_TIMER;
pub const SI_QUEUE: _bindgen_ty_8 = _bindgen_ty_8::SI_QUEUE;
pub const SI_USER: _bindgen_ty_8 = _bindgen_ty_8::SI_USER;
pub const SI_KERNEL: _bindgen_ty_8 = _bindgen_ty_8::SI_KERNEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
pub const ILL_ILLOPC: _bindgen_ty_9 = _bindgen_ty_9::ILL_ILLOPC;
pub const ILL_ILLOPN: _bindgen_ty_9 = _bindgen_ty_9::ILL_ILLOPN;
pub const ILL_ILLADR: _bindgen_ty_9 = _bindgen_ty_9::ILL_ILLADR;
pub const ILL_ILLTRP: _bindgen_ty_9 = _bindgen_ty_9::ILL_ILLTRP;
pub const ILL_PRVOPC: _bindgen_ty_9 = _bindgen_ty_9::ILL_PRVOPC;
pub const ILL_PRVREG: _bindgen_ty_9 = _bindgen_ty_9::ILL_PRVREG;
pub const ILL_COPROC: _bindgen_ty_9 = _bindgen_ty_9::ILL_COPROC;
pub const ILL_BADSTK: _bindgen_ty_9 = _bindgen_ty_9::ILL_BADSTK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
pub const FPE_INTDIV: _bindgen_ty_10 = _bindgen_ty_10::FPE_INTDIV;
pub const FPE_INTOVF: _bindgen_ty_10 = _bindgen_ty_10::FPE_INTOVF;
pub const FPE_FLTDIV: _bindgen_ty_10 = _bindgen_ty_10::FPE_FLTDIV;
pub const FPE_FLTOVF: _bindgen_ty_10 = _bindgen_ty_10::FPE_FLTOVF;
pub const FPE_FLTUND: _bindgen_ty_10 = _bindgen_ty_10::FPE_FLTUND;
pub const FPE_FLTRES: _bindgen_ty_10 = _bindgen_ty_10::FPE_FLTRES;
pub const FPE_FLTINV: _bindgen_ty_10 = _bindgen_ty_10::FPE_FLTINV;
pub const FPE_FLTSUB: _bindgen_ty_10 = _bindgen_ty_10::FPE_FLTSUB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
pub const SEGV_MAPERR: _bindgen_ty_11 = _bindgen_ty_11::SEGV_MAPERR;
pub const SEGV_ACCERR: _bindgen_ty_11 = _bindgen_ty_11::SEGV_ACCERR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
pub const BUS_ADRALN: _bindgen_ty_12 = _bindgen_ty_12::BUS_ADRALN;
pub const BUS_ADRERR: _bindgen_ty_12 = _bindgen_ty_12::BUS_ADRERR;
pub const BUS_OBJERR: _bindgen_ty_12 = _bindgen_ty_12::BUS_OBJERR;
pub const BUS_MCEERR_AR: _bindgen_ty_12 = _bindgen_ty_12::BUS_MCEERR_AR;
pub const BUS_MCEERR_AO: _bindgen_ty_12 = _bindgen_ty_12::BUS_MCEERR_AO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5,
}
pub const CLD_EXITED: _bindgen_ty_13 = _bindgen_ty_13::CLD_EXITED;
pub const CLD_KILLED: _bindgen_ty_13 = _bindgen_ty_13::CLD_KILLED;
pub const CLD_DUMPED: _bindgen_ty_13 = _bindgen_ty_13::CLD_DUMPED;
pub const CLD_TRAPPED: _bindgen_ty_13 = _bindgen_ty_13::CLD_TRAPPED;
pub const CLD_STOPPED: _bindgen_ty_13 = _bindgen_ty_13::CLD_STOPPED;
pub const CLD_CONTINUED: _bindgen_ty_13 = _bindgen_ty_13::CLD_CONTINUED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
pub const POLL_IN: _bindgen_ty_14 = _bindgen_ty_14::POLL_IN;
pub const POLL_OUT: _bindgen_ty_14 = _bindgen_ty_14::POLL_OUT;
pub const POLL_MSG: _bindgen_ty_14 = _bindgen_ty_14::POLL_MSG;
pub const POLL_ERR: _bindgen_ty_14 = _bindgen_ty_14::POLL_ERR;
pub const POLL_PRI: _bindgen_ty_14 = _bindgen_ty_14::POLL_PRI;
pub const POLL_HUP: _bindgen_ty_14 = _bindgen_ty_14::POLL_HUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _attribute as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _attribute ) ));
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _tid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _sigev_thread as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _sigev_thread ) ));
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( _sigev_un ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_15 = _bindgen_ty_15::SIGEV_SIGNAL;
pub const SIGEV_NONE: _bindgen_ty_15 = _bindgen_ty_15::SIGEV_NONE;
pub const SIGEV_THREAD: _bindgen_ty_15 = _bindgen_ty_15::SIGEV_THREAD;
pub const SIGEV_THREAD_ID: _bindgen_ty_15 = _bindgen_ty_15::SIGEV_THREAD_ID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int,
                         __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int,
                   __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t,
                    __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int,
                                                                 arg2:
                                                                     *mut siginfo_t,
                                                                 arg3:
                                                                     *mut ::std::os::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) . sa_handler
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                sa_sigaction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_sigaction ) ));
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 152usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_restorer as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_restorer ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(__sig: ::std::os::raw::c_int, __act: *const sigaction,
                     __oact: *mut sigaction) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int,
                    __val: sigval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_sys_siglist"]
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    #[link_name = "sys_siglist"]
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::std::mem::size_of::<_fpx_sw_bytes>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (::std::mem::align_of::<_fpx_sw_bytes>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . magic1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( magic1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . extended_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( extended_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_bv as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . padding as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(::std::mem::size_of::<_fpreg>() , 10usize , concat ! (
               "Size of: " , stringify ! ( _fpreg ) ));
    assert_eq! (::std::mem::align_of::<_fpreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( exponent ) ));
}
impl Clone for _fpreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(::std::mem::size_of::<_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _fpxreg ) ));
    assert_eq! (::std::mem::align_of::<_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . padding as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(::std::mem::size_of::<_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _xmmreg ) ));
    assert_eq! (::std::mem::align_of::<_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xmmreg ) ) . element as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::std::mem::size_of::<_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _fpstate ) ));
    assert_eq! (::std::mem::align_of::<_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . cwd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . swd as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . ftw as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . fop as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rip as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rdp as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcr_mask as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _st as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _xmm as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . padding as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _fpstate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigcontext__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigcontext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) . fpstate as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( fpstate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) .
                __fpstate_word as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! (
                __fpstate_word ) ));
}
impl Clone for sigcontext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::std::mem::size_of::<sigcontext>() , 256usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (::std::mem::align_of::<sigcontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r8 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r9 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r10 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r11 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r13 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r14 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r15 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdi as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsi as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbp as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbx as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdx as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rax as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rcx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsp as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rip as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . eflags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cs as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . gs as * const _ as usize
                } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . fs as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __pad0 as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . trapno as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . oldmask as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( oldmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cr2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(::std::mem::size_of::<_xsave_hdr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (::std::mem::align_of::<_xsave_hdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . xstate_bv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . reserved1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . reserved2 as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for _xsave_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::std::mem::size_of::<_ymmh_state>() , 256usize , concat ! (
               "Size of: " , stringify ! ( _ymmh_state ) ));
    assert_eq! (::std::mem::align_of::<_ymmh_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _ymmh_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ymmh_state ) ) . ymmh_space as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ymmh_state ) , "::" ,
                stringify ! ( ymmh_space ) ));
}
impl Clone for _ymmh_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::std::mem::size_of::<_xstate>() , 832usize , concat ! (
               "Size of: " , stringify ! ( _xstate ) ));
    assert_eq! (::std::mem::align_of::<_xstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . fpstate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . xstate_hdr as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( xstate_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . ymmh as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( ymmh ) ));
}
impl Clone for _xstate {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(__sig: ::std::os::raw::c_int,
                        __interrupt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
pub const SS_ONSTACK: _bindgen_ty_16 = _bindgen_ty_16::SS_ONSTACK;
pub const SS_DISABLE: _bindgen_ty_16 = _bindgen_ty_16::SS_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 { SS_ONSTACK = 1, SS_DISABLE = 2, }
#[repr(C)]
#[derive(Copy)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::std::mem::size_of::<sigaltstack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sigaltstack ) ));
    assert_eq! (::std::mem::align_of::<sigaltstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_size ) ));
}
impl Clone for sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = sigaltstack;
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Copy)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(::std::mem::size_of::<_libc_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (::std::mem::align_of::<_libc_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . significand as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . exponent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . padding as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(::std::mem::size_of::<_libc_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (::std::mem::align_of::<_libc_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_xmmreg ) ) . element as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(::std::mem::size_of::<_libc_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (::std::mem::align_of::<_libc_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . swd as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . ftw as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . fop as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rip as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rdp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcr_mask as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _st as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _xmm as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . padding as * const _
                as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _libc_fpstate {
    fn clone(&self) -> Self { *self }
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Copy)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(::std::mem::size_of::<mcontext_t>() , 256usize , concat ! (
               "Size of: " , stringify ! ( mcontext_t ) ));
    assert_eq! (::std::mem::align_of::<mcontext_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcontext_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . gregs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( gregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . fpregs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( fpregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for mcontext_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(::std::mem::size_of::<ucontext>() , 936usize , concat ! (
               "Size of: " , stringify ! ( ucontext ) ));
    assert_eq! (::std::mem::align_of::<ucontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_link as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_stack as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_mcontext as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_sigmask as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . __fpregs_mem as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( __fpregs_mem ) ));
}
impl Clone for ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(__ss: *const sigaltstack, __oss: *mut sigaltstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int,
                           __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct Latch {
    pub is_set: sig_atomic_t,
    pub is_shared: bool_,
    pub owner_pid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Latch() {
    assert_eq!(::std::mem::size_of::<Latch>() , 12usize , concat ! (
               "Size of: " , stringify ! ( Latch ) ));
    assert_eq! (::std::mem::align_of::<Latch>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Latch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Latch ) ) . is_set as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Latch ) , "::" ,
                stringify ! ( is_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Latch ) ) . is_shared as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Latch ) , "::" ,
                stringify ! ( is_shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Latch ) ) . owner_pid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Latch ) , "::" ,
                stringify ! ( owner_pid ) ));
}
impl Clone for Latch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WaitEvent {
    pub pos: ::std::os::raw::c_int,
    pub events: uint32,
    pub fd: pgsocket,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_WaitEvent() {
    assert_eq!(::std::mem::size_of::<WaitEvent>() , 24usize , concat ! (
               "Size of: " , stringify ! ( WaitEvent ) ));
    assert_eq! (::std::mem::align_of::<WaitEvent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WaitEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WaitEvent ) ) . pos as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WaitEvent ) , "::" ,
                stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WaitEvent ) ) . events as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WaitEvent ) , "::" ,
                stringify ! ( events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WaitEvent ) ) . fd as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WaitEvent ) , "::" ,
                stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WaitEvent ) ) . user_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WaitEvent ) , "::" ,
                stringify ! ( user_data ) ));
}
impl Clone for WaitEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitEventSet {
    _unused: [u8; 0],
}
extern "C" {
    pub fn InitializeLatchSupport();
}
extern "C" {
    pub fn InitLatch(latch: *mut Latch);
}
extern "C" {
    pub fn InitSharedLatch(latch: *mut Latch);
}
extern "C" {
    pub fn OwnLatch(latch: *mut Latch);
}
extern "C" {
    pub fn DisownLatch(latch: *mut Latch);
}
extern "C" {
    pub fn SetLatch(latch: *mut Latch);
}
extern "C" {
    pub fn ResetLatch(latch: *mut Latch);
}
extern "C" {
    pub fn CreateWaitEventSet(context: MemoryContext,
                              nevents: ::std::os::raw::c_int)
     -> *mut WaitEventSet;
}
extern "C" {
    pub fn FreeWaitEventSet(set: *mut WaitEventSet);
}
extern "C" {
    pub fn AddWaitEventToSet(set: *mut WaitEventSet, events: uint32,
                             fd: pgsocket, latch: *mut Latch,
                             user_data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ModifyWaitEvent(set: *mut WaitEventSet, pos: ::std::os::raw::c_int,
                           events: uint32, latch: *mut Latch);
}
extern "C" {
    pub fn WaitEventSetWait(set: *mut WaitEventSet,
                            timeout: ::std::os::raw::c_long,
                            occurred_events: *mut WaitEvent,
                            nevents: ::std::os::raw::c_int,
                            wait_event_info: uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WaitLatch(latch: *mut Latch, wakeEvents: ::std::os::raw::c_int,
                     timeout: ::std::os::raw::c_long, wait_event_info: uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WaitLatchOrSocket(latch: *mut Latch,
                             wakeEvents: ::std::os::raw::c_int,
                             sock: pgsocket, timeout: ::std::os::raw::c_long,
                             wait_event_info: uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn latch_sigusr1_handler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGSemaphoreData {
    _unused: [u8; 0],
}
pub type PGSemaphore = *mut PGSemaphoreData;
extern "C" {
    pub fn PGSemaphoreShmemSize(maxSemas: ::std::os::raw::c_int) -> Size;
}
extern "C" {
    pub fn PGReserveSemaphores(maxSemas: ::std::os::raw::c_int,
                               port: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PGSemaphoreCreate() -> PGSemaphore;
}
extern "C" {
    pub fn PGSemaphoreReset(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreLock(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreUnlock(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreTryLock(sema: PGSemaphore) -> bool_;
}
#[repr(C)]
#[derive(Copy)]
pub struct XidCache {
    pub xids: [TransactionId; 64usize],
}
#[test]
fn bindgen_test_layout_XidCache() {
    assert_eq!(::std::mem::size_of::<XidCache>() , 256usize , concat ! (
               "Size of: " , stringify ! ( XidCache ) ));
    assert_eq! (::std::mem::align_of::<XidCache>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( XidCache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XidCache ) ) . xids as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( XidCache ) , "::" ,
                stringify ! ( xids ) ));
}
impl Clone for XidCache {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "MyProc"]
    pub static mut MyProc: *mut PGPROC;
}
#[repr(C)]
#[derive(Copy)]
pub struct PGXACT {
    pub xid: TransactionId,
    pub xmin: TransactionId,
    pub vacuumFlags: uint8,
    pub overflowed: bool_,
    pub delayChkpt: bool_,
    pub nxids: uint8,
}
#[test]
fn bindgen_test_layout_PGXACT() {
    assert_eq!(::std::mem::size_of::<PGXACT>() , 12usize , concat ! (
               "Size of: " , stringify ! ( PGXACT ) ));
    assert_eq! (::std::mem::align_of::<PGXACT>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( PGXACT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGXACT ) ) . xid as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PGXACT ) , "::" ,
                stringify ! ( xid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGXACT ) ) . xmin as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PGXACT ) , "::" ,
                stringify ! ( xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGXACT ) ) . vacuumFlags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PGXACT ) , "::" ,
                stringify ! ( vacuumFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGXACT ) ) . overflowed as * const _ as
                usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( PGXACT ) , "::" ,
                stringify ! ( overflowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGXACT ) ) . delayChkpt as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( PGXACT ) , "::" ,
                stringify ! ( delayChkpt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PGXACT ) ) . nxids as * const _ as usize
                } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( PGXACT ) , "::" ,
                stringify ! ( nxids ) ));
}
impl Clone for PGXACT {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "MyPgXact"]
    pub static mut MyPgXact: *mut PGXACT;
}
#[repr(C)]
#[derive(Copy)]
pub struct PROC_HDR {
    pub allProcs: *mut PGPROC,
    pub allPgXact: *mut PGXACT,
    pub allProcCount: uint32,
    pub freeProcs: *mut PGPROC,
    pub autovacFreeProcs: *mut PGPROC,
    pub bgworkerFreeProcs: *mut PGPROC,
    pub procArrayGroupFirst: pg_atomic_uint32,
    pub walwriterLatch: *mut Latch,
    pub checkpointerLatch: *mut Latch,
    pub spins_per_delay: ::std::os::raw::c_int,
    pub startupProc: *mut PGPROC,
    pub startupProcPid: ::std::os::raw::c_int,
    pub startupBufferPinWaitBufId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROC_HDR() {
    assert_eq!(::std::mem::size_of::<PROC_HDR>() , 96usize , concat ! (
               "Size of: " , stringify ! ( PROC_HDR ) ));
    assert_eq! (::std::mem::align_of::<PROC_HDR>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PROC_HDR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . allProcs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( allProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . allPgXact as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( allPgXact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . allProcCount as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( allProcCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . freeProcs as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( freeProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . autovacFreeProcs as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( autovacFreeProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . bgworkerFreeProcs as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( bgworkerFreeProcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . procArrayGroupFirst as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( procArrayGroupFirst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . walwriterLatch as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( walwriterLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . checkpointerLatch as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( checkpointerLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . spins_per_delay as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( spins_per_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . startupProc as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( startupProc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . startupProcPid as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( startupProcPid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PROC_HDR ) ) . startupBufferPinWaitBufId
                as * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( PROC_HDR ) , "::" ,
                stringify ! ( startupBufferPinWaitBufId ) ));
}
impl Clone for PROC_HDR {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ProcGlobal"]
    pub static mut ProcGlobal: *mut PROC_HDR;
}
extern "C" {
    #[link_name = "PreparedXactProcs"]
    pub static mut PreparedXactProcs: *mut PGPROC;
}
extern "C" {
    #[link_name = "DeadlockTimeout"]
    pub static mut DeadlockTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "StatementTimeout"]
    pub static mut StatementTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "LockTimeout"]
    pub static mut LockTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "IdleInTransactionSessionTimeout"]
    pub static mut IdleInTransactionSessionTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "log_lock_waits"]
    pub static mut log_lock_waits: bool_;
}
extern "C" {
    pub fn ProcGlobalSemas() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ProcGlobalShmemSize() -> Size;
}
extern "C" {
    pub fn InitProcGlobal();
}
extern "C" {
    pub fn InitProcess();
}
extern "C" {
    pub fn InitProcessPhase2();
}
extern "C" {
    pub fn InitAuxiliaryProcess();
}
extern "C" {
    pub fn PublishStartupProcessInformation();
}
extern "C" {
    pub fn SetStartupBufferPinWaitBufId(bufid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetStartupBufferPinWaitBufId() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HaveNFreeProcs(n: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn ProcReleaseLocks(isCommit: bool_);
}
extern "C" {
    pub fn ProcQueueInit(queue: *mut PROC_QUEUE);
}
extern "C" {
    pub fn ProcSleep(locallock: *mut LOCALLOCK, lockMethodTable: LockMethod)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ProcWakeup(proc_: *mut PGPROC, waitStatus: ::std::os::raw::c_int)
     -> *mut PGPROC;
}
extern "C" {
    pub fn ProcLockWakeup(lockMethodTable: LockMethod, lock: *mut LOCK);
}
extern "C" {
    pub fn CheckDeadLockAlert();
}
extern "C" {
    pub fn IsWaitingForLock() -> bool_;
}
extern "C" {
    pub fn LockErrorCleanup();
}
extern "C" {
    pub fn ProcWaitForSignal(wait_event_info: uint32);
}
extern "C" {
    pub fn ProcSendSignal(pid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn AuxiliaryPidGetProc(pid: ::std::os::raw::c_int) -> *mut PGPROC;
}
extern "C" {
    pub fn BecomeLockGroupLeader();
}
extern "C" {
    pub fn BecomeLockGroupMember(leader: *mut PGPROC,
                                 pid: ::std::os::raw::c_int) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct shm_mq_iovec {
    pub data: *const ::std::os::raw::c_char,
    pub len: Size,
}
#[test]
fn bindgen_test_layout_shm_mq_iovec() {
    assert_eq!(::std::mem::size_of::<shm_mq_iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( shm_mq_iovec ) ));
    assert_eq! (::std::mem::align_of::<shm_mq_iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( shm_mq_iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shm_mq_iovec ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( shm_mq_iovec ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shm_mq_iovec ) ) . len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( shm_mq_iovec ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for shm_mq_iovec {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum shm_mq_result {
    SHM_MQ_SUCCESS = 0,
    SHM_MQ_WOULD_BLOCK = 1,
    SHM_MQ_DETACHED = 2,
}
extern "C" {
    pub fn shm_mq_create(address: *mut ::std::os::raw::c_void, size: Size)
     -> *mut shm_mq;
}
extern "C" {
    pub fn shm_mq_set_receiver(mq: *mut shm_mq, arg1: *mut PGPROC);
}
extern "C" {
    pub fn shm_mq_set_sender(mq: *mut shm_mq, arg1: *mut PGPROC);
}
extern "C" {
    pub fn shm_mq_get_receiver(arg1: *mut shm_mq) -> *mut PGPROC;
}
extern "C" {
    pub fn shm_mq_get_sender(arg1: *mut shm_mq) -> *mut PGPROC;
}
extern "C" {
    pub fn shm_mq_attach(mq: *mut shm_mq, seg: *mut dsm_segment,
                         handle: *mut BackgroundWorkerHandle)
     -> *mut shm_mq_handle;
}
extern "C" {
    pub fn shm_mq_set_handle(arg1: *mut shm_mq_handle,
                             arg2: *mut BackgroundWorkerHandle);
}
extern "C" {
    pub fn shm_mq_detach(mqh: *mut shm_mq_handle);
}
extern "C" {
    pub fn shm_mq_get_queue(mqh: *mut shm_mq_handle) -> *mut shm_mq;
}
extern "C" {
    pub fn shm_mq_send(mqh: *mut shm_mq_handle, nbytes: Size,
                       data: *const ::std::os::raw::c_void, nowait: bool_)
     -> shm_mq_result;
}
extern "C" {
    pub fn shm_mq_sendv(mqh: *mut shm_mq_handle, iov: *mut shm_mq_iovec,
                        iovcnt: ::std::os::raw::c_int, nowait: bool_)
     -> shm_mq_result;
}
extern "C" {
    pub fn shm_mq_receive(mqh: *mut shm_mq_handle, nbytesp: *mut Size,
                          datap: *mut *mut ::std::os::raw::c_void,
                          nowait: bool_) -> shm_mq_result;
}
extern "C" {
    pub fn shm_mq_wait_for_attach(mqh: *mut shm_mq_handle) -> shm_mq_result;
}
extern "C" {
    #[link_name = "shm_mq_minimum_size"]
    pub static shm_mq_minimum_size: Size;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_toc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn shm_toc_create(magic: uint64, address: *mut ::std::os::raw::c_void,
                          nbytes: Size) -> *mut shm_toc;
}
extern "C" {
    pub fn shm_toc_attach(magic: uint64, address: *mut ::std::os::raw::c_void)
     -> *mut shm_toc;
}
extern "C" {
    pub fn shm_toc_allocate(toc: *mut shm_toc, nbytes: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn shm_toc_freespace(toc: *mut shm_toc) -> Size;
}
extern "C" {
    pub fn shm_toc_insert(toc: *mut shm_toc, key: uint64,
                          address: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn shm_toc_lookup(toc: *mut shm_toc, key: uint64, noError: bool_)
     -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Copy)]
pub struct shm_toc_estimator {
    pub space_for_chunks: Size,
    pub number_of_keys: Size,
}
#[test]
fn bindgen_test_layout_shm_toc_estimator() {
    assert_eq!(::std::mem::size_of::<shm_toc_estimator>() , 16usize , concat !
               ( "Size of: " , stringify ! ( shm_toc_estimator ) ));
    assert_eq! (::std::mem::align_of::<shm_toc_estimator>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( shm_toc_estimator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shm_toc_estimator ) ) . space_for_chunks
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( shm_toc_estimator ) ,
                "::" , stringify ! ( space_for_chunks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shm_toc_estimator ) ) . number_of_keys as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( shm_toc_estimator ) ,
                "::" , stringify ! ( number_of_keys ) ));
}
impl Clone for shm_toc_estimator {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn shm_toc_estimate(e: *mut shm_toc_estimator) -> Size;
}
pub type parallel_worker_main_type =
    ::std::option::Option<unsafe extern "C" fn(seg: *mut dsm_segment,
                                               toc: *mut shm_toc)>;
#[repr(C)]
#[derive(Copy)]
pub struct ParallelWorkerInfo {
    pub bgwhandle: *mut BackgroundWorkerHandle,
    pub error_mqh: *mut shm_mq_handle,
    pub pid: int32,
}
#[test]
fn bindgen_test_layout_ParallelWorkerInfo() {
    assert_eq!(::std::mem::size_of::<ParallelWorkerInfo>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( ParallelWorkerInfo ) ));
    assert_eq! (::std::mem::align_of::<ParallelWorkerInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ParallelWorkerInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelWorkerInfo ) ) . bgwhandle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelWorkerInfo ) ,
                "::" , stringify ! ( bgwhandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelWorkerInfo ) ) . error_mqh as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelWorkerInfo ) ,
                "::" , stringify ! ( error_mqh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelWorkerInfo ) ) . pid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelWorkerInfo ) ,
                "::" , stringify ! ( pid ) ));
}
impl Clone for ParallelWorkerInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ParallelContext {
    pub node: dlist_node,
    pub subid: SubTransactionId,
    pub nworkers: ::std::os::raw::c_int,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub library_name: *mut ::std::os::raw::c_char,
    pub function_name: *mut ::std::os::raw::c_char,
    pub error_context_stack: *mut ErrorContextCallback,
    pub estimator: shm_toc_estimator,
    pub seg: *mut dsm_segment,
    pub private_memory: *mut ::std::os::raw::c_void,
    pub toc: *mut shm_toc,
    pub worker: *mut ParallelWorkerInfo,
}
#[test]
fn bindgen_test_layout_ParallelContext() {
    assert_eq!(::std::mem::size_of::<ParallelContext>() , 104usize , concat !
               ( "Size of: " , stringify ! ( ParallelContext ) ));
    assert_eq! (::std::mem::align_of::<ParallelContext>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ParallelContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . subid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( subid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . nworkers as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( nworkers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . nworkers_launched
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( nworkers_launched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . library_name as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( library_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . function_name as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( function_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . error_context_stack
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( error_context_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . estimator as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( estimator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . seg as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( seg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . private_memory as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( private_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . toc as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( toc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParallelContext ) ) . worker as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ParallelContext ) ,
                "::" , stringify ! ( worker ) ));
}
impl Clone for ParallelContext {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ParallelMessagePending"]
    pub static mut ParallelMessagePending: bool_;
}
extern "C" {
    #[link_name = "ParallelWorkerNumber"]
    pub static mut ParallelWorkerNumber: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "InitializingParallelWorker"]
    pub static mut InitializingParallelWorker: bool_;
}
extern "C" {
    pub fn CreateParallelContext(library_name: *const ::std::os::raw::c_char,
                                 function_name: *const ::std::os::raw::c_char,
                                 nworkers: ::std::os::raw::c_int)
     -> *mut ParallelContext;
}
extern "C" {
    pub fn InitializeParallelDSM(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn ReinitializeParallelDSM(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn LaunchParallelWorkers(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn WaitForParallelWorkersToFinish(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn DestroyParallelContext(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn ParallelContextActive() -> bool_;
}
extern "C" {
    pub fn HandleParallelMessageInterrupt();
}
extern "C" {
    pub fn HandleParallelMessages();
}
extern "C" {
    pub fn AtEOXact_Parallel(isCommit: bool_);
}
extern "C" {
    pub fn AtEOSubXact_Parallel(isCommit: bool_, mySubId: SubTransactionId);
}
extern "C" {
    pub fn ParallelWorkerReportLastRecEnd(last_xlog_end: XLogRecPtr);
}
extern "C" {
    pub fn ParallelWorkerMain(main_arg: Datum);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockClauseStrength {
    LCS_NONE = 0,
    LCS_FORKEYSHARE = 1,
    LCS_FORSHARE = 2,
    LCS_FORNOKEYUPDATE = 3,
    LCS_FORUPDATE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockWaitPolicy {
    LockWaitBlock = 0,
    LockWaitSkip = 1,
    LockWaitError = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
#[test]
fn bindgen_test_layout_Alias() {
    assert_eq!(::std::mem::size_of::<Alias>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Alias ) ));
    assert_eq! (::std::mem::align_of::<Alias>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Alias ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Alias ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Alias ) ) . aliasname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Alias ) , "::" ,
                stringify ! ( aliasname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Alias ) ) . colnames as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Alias ) , "::" ,
                stringify ! ( colnames ) ));
}
impl Clone for Alias {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OnCommitAction {
    ONCOMMIT_NOOP = 0,
    ONCOMMIT_PRESERVE_ROWS = 1,
    ONCOMMIT_DELETE_ROWS = 2,
    ONCOMMIT_DROP = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inh: bool_,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeVar() {
    assert_eq!(::std::mem::size_of::<RangeVar>() , 56usize , concat ! (
               "Size of: " , stringify ! ( RangeVar ) ));
    assert_eq! (::std::mem::align_of::<RangeVar>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RangeVar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . catalogname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( catalogname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . schemaname as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( schemaname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . relname as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( relname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . inh as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( inh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . relpersistence as * const
                _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( relpersistence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . alias as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeVar ) ) . location as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeVar ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for RangeVar {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TableFunc {
    pub type_: NodeTag,
    pub ns_uris: *mut List,
    pub ns_names: *mut List,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub colnames: *mut List,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub notnulls: *mut Bitmapset,
    pub ordinalitycol: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TableFunc() {
    assert_eq!(::std::mem::size_of::<TableFunc>() , 104usize , concat ! (
               "Size of: " , stringify ! ( TableFunc ) ));
    assert_eq! (::std::mem::align_of::<TableFunc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TableFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . ns_uris as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( ns_uris ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . ns_names as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( ns_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . docexpr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( docexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . rowexpr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( rowexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . colnames as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( colnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . coltypes as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( coltypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . coltypmods as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( coltypmods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . colcollations as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( colcollations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . colexprs as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( colexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . coldefexprs as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( coldefexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . notnulls as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( notnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . ordinalitycol as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( ordinalitycol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFunc ) ) . location as * const _ as
                usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFunc ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for TableFunc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool_,
}
#[test]
fn bindgen_test_layout_IntoClause() {
    assert_eq!(::std::mem::size_of::<IntoClause>() , 64usize , concat ! (
               "Size of: " , stringify ! ( IntoClause ) ));
    assert_eq! (::std::mem::align_of::<IntoClause>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IntoClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . rel as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( rel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . colNames as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( colNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . options as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . onCommit as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( onCommit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . tableSpaceName as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( tableSpaceName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . viewQuery as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( viewQuery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntoClause ) ) . skipData as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( IntoClause ) , "::" ,
                stringify ! ( skipData ) ));
}
impl Clone for IntoClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Expr {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_Expr() {
    assert_eq!(::std::mem::size_of::<Expr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( Expr ) ));
    assert_eq! (::std::mem::align_of::<Expr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Expr ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Expr ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for Expr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Var() {
    assert_eq!(::std::mem::size_of::<Var>() , 40usize , concat ! (
               "Size of: " , stringify ! ( Var ) ));
    assert_eq! (::std::mem::align_of::<Var>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Var ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . xpr as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . varno as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( varno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . varattno as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( varattno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . vartype as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( vartype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . vartypmod as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( vartypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . varcollid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( varcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . varlevelsup as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( varlevelsup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . varnoold as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( varnoold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . varoattno as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( varoattno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Var ) ) . location as * const _ as usize
                } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Var ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for Var {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool_,
    pub constbyval: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Const() {
    assert_eq!(::std::mem::size_of::<Const>() , 40usize , concat ! (
               "Size of: " , stringify ! ( Const ) ));
    assert_eq! (::std::mem::align_of::<Const>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Const ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . xpr as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . consttype as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( consttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . consttypmod as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( consttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . constcollid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( constcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . constlen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( constlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . constvalue as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( constvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . constisnull as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( constisnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . constbyval as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( constbyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Const ) ) . location as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Const ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for Const {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ParamKind {
    PARAM_EXTERN = 0,
    PARAM_EXEC = 1,
    PARAM_SUBLINK = 2,
    PARAM_MULTIEXPR = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Param() {
    assert_eq!(::std::mem::size_of::<Param>() , 28usize , concat ! (
               "Size of: " , stringify ! ( Param ) ));
    assert_eq! (::std::mem::align_of::<Param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . xpr as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . paramkind as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( paramkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . paramid as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( paramid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . paramtype as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( paramtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . paramtypmod as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( paramtypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . paramcollid as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( paramcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Param ) ) . location as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Param ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for Param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GroupingFunc() {
    assert_eq!(::std::mem::size_of::<GroupingFunc>() , 40usize , concat ! (
               "Size of: " , stringify ! ( GroupingFunc ) ));
    assert_eq! (::std::mem::align_of::<GroupingFunc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GroupingFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingFunc ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingFunc ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingFunc ) ) . args as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingFunc ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingFunc ) ) . refs as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingFunc ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingFunc ) ) . cols as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingFunc ) , "::" ,
                stringify ! ( cols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingFunc ) ) . agglevelsup as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingFunc ) , "::" ,
                stringify ! ( agglevelsup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingFunc ) ) . location as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingFunc ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for GroupingFunc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: bool_,
    pub winagg: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowFunc() {
    assert_eq!(::std::mem::size_of::<WindowFunc>() , 56usize , concat ! (
               "Size of: " , stringify ! ( WindowFunc ) ));
    assert_eq! (::std::mem::align_of::<WindowFunc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WindowFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . winfnoid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( winfnoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . wintype as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( wintype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . wincollid as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( wincollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . inputcollid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( inputcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . args as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . aggfilter as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( aggfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . winref as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( winref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . winstar as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( winstar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . winagg as * const _ as
                usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( winagg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFunc ) ) . location as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFunc ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for WindowFunc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
#[test]
fn bindgen_test_layout_ArrayRef() {
    assert_eq!(::std::mem::size_of::<ArrayRef>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ArrayRef ) ));
    assert_eq! (::std::mem::align_of::<ArrayRef>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ArrayRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . refarraytype as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( refarraytype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . refelemtype as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( refelemtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . reftypmod as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( reftypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . refcollid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( refcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . refupperindexpr as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( refupperindexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . reflowerindexpr as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( reflowerindexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . refexpr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( refexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayRef ) ) . refassgnexpr as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayRef ) , "::" ,
                stringify ! ( refassgnexpr ) ));
}
impl Clone for ArrayRef {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CoercionContext {
    COERCION_IMPLICIT = 0,
    COERCION_ASSIGNMENT = 1,
    COERCION_EXPLICIT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CoercionForm {
    COERCE_EXPLICIT_CALL = 0,
    COERCE_EXPLICIT_CAST = 1,
    COERCE_IMPLICIT_CAST = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool_,
    pub funcvariadic: bool_,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FuncExpr() {
    assert_eq!(::std::mem::size_of::<FuncExpr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( FuncExpr ) ));
    assert_eq! (::std::mem::align_of::<FuncExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FuncExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . funcid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( funcid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . funcresulttype as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( funcresulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . funcretset as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( funcretset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . funcvariadic as * const _
                as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( funcvariadic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . funcformat as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( funcformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . funccollid as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( funccollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . inputcollid as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( inputcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . args as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncExpr ) ) . location as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for FuncExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NamedArgExpr() {
    assert_eq!(::std::mem::size_of::<NamedArgExpr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( NamedArgExpr ) ));
    assert_eq! (::std::mem::align_of::<NamedArgExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NamedArgExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedArgExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedArgExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedArgExpr ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedArgExpr ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedArgExpr ) ) . name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedArgExpr ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedArgExpr ) ) . argnumber as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedArgExpr ) , "::" ,
                stringify ! ( argnumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedArgExpr ) ) . location as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedArgExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for NamedArgExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool_,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OpExpr() {
    assert_eq!(::std::mem::size_of::<OpExpr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( OpExpr ) ));
    assert_eq! (::std::mem::align_of::<OpExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( OpExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . xpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . opno as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( opno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . opfuncid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( opfuncid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . opresulttype as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( opresulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . opretset as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( opretset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . opcollid as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( opcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . inputcollid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( inputcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . args as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpExpr ) ) . location as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( OpExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for OpExpr {
    fn clone(&self) -> Self { *self }
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Copy)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: bool_,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ScalarArrayOpExpr() {
    assert_eq!(::std::mem::size_of::<ScalarArrayOpExpr>() , 40usize , concat !
               ( "Size of: " , stringify ! ( ScalarArrayOpExpr ) ));
    assert_eq! (::std::mem::align_of::<ScalarArrayOpExpr>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ScalarArrayOpExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . xpr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . opno as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( opno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . opfuncid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( opfuncid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . useOr as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( useOr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . inputcollid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( inputcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . args as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScalarArrayOpExpr ) ) . location as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ScalarArrayOpExpr ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for ScalarArrayOpExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BoolExprType { AND_EXPR = 0, OR_EXPR = 1, NOT_EXPR = 2, }
#[repr(C)]
#[derive(Copy)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BoolExpr() {
    assert_eq!(::std::mem::size_of::<BoolExpr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( BoolExpr ) ));
    assert_eq! (::std::mem::align_of::<BoolExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BoolExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BoolExpr ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BoolExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BoolExpr ) ) . boolop as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( BoolExpr ) , "::" ,
                stringify ! ( boolop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BoolExpr ) ) . args as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( BoolExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BoolExpr ) ) . location as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( BoolExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for BoolExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SubLinkType {
    EXISTS_SUBLINK = 0,
    ALL_SUBLINK = 1,
    ANY_SUBLINK = 2,
    ROWCOMPARE_SUBLINK = 3,
    EXPR_SUBLINK = 4,
    MULTIEXPR_SUBLINK = 5,
    ARRAY_SUBLINK = 6,
    CTE_SUBLINK = 7,
}
#[repr(C)]
#[derive(Copy)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SubLink() {
    assert_eq!(::std::mem::size_of::<SubLink>() , 48usize , concat ! (
               "Size of: " , stringify ! ( SubLink ) ));
    assert_eq! (::std::mem::align_of::<SubLink>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SubLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . xpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . subLinkType as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( subLinkType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . subLinkId as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( subLinkId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . testexpr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( testexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . operName as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( operName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . subselect as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( subselect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubLink ) ) . location as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SubLink ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for SubLink {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool_,
    pub unknownEqFalse: bool_,
    pub parallel_safe: bool_,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
#[test]
fn bindgen_test_layout_SubPlan() {
    assert_eq!(::std::mem::size_of::<SubPlan>() , 96usize , concat ! (
               "Size of: " , stringify ! ( SubPlan ) ));
    assert_eq! (::std::mem::align_of::<SubPlan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SubPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . xpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . subLinkType as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( subLinkType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . testexpr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( testexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . paramIds as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( paramIds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . plan_id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( plan_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . plan_name as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( plan_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . firstColType as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( firstColType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . firstColTypmod as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( firstColTypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . firstColCollation as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( firstColCollation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . useHashTable as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( useHashTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . unknownEqFalse as * const _
                as usize } , 53usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( unknownEqFalse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . parallel_safe as * const _
                as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( parallel_safe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . setParam as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( setParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . parParam as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( parParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . args as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . startup_cost as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( startup_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlan ) ) . per_call_cost as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlan ) , "::" ,
                stringify ! ( per_call_cost ) ));
}
impl Clone for SubPlan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
#[test]
fn bindgen_test_layout_AlternativeSubPlan() {
    assert_eq!(::std::mem::size_of::<AlternativeSubPlan>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( AlternativeSubPlan ) ));
    assert_eq! (::std::mem::align_of::<AlternativeSubPlan>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlternativeSubPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlternativeSubPlan ) ) . xpr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlternativeSubPlan ) ,
                "::" , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlternativeSubPlan ) ) . subplans as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlternativeSubPlan ) ,
                "::" , stringify ! ( subplans ) ));
}
impl Clone for AlternativeSubPlan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
#[test]
fn bindgen_test_layout_FieldSelect() {
    assert_eq!(::std::mem::size_of::<FieldSelect>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FieldSelect ) ));
    assert_eq! (::std::mem::align_of::<FieldSelect>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FieldSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldSelect ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldSelect ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldSelect ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldSelect ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldSelect ) ) . fieldnum as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldSelect ) , "::" ,
                stringify ! ( fieldnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldSelect ) ) . resulttype as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldSelect ) , "::" ,
                stringify ! ( resulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldSelect ) ) . resulttypmod as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldSelect ) , "::" ,
                stringify ! ( resulttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldSelect ) ) . resultcollid as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldSelect ) , "::" ,
                stringify ! ( resultcollid ) ));
}
impl Clone for FieldSelect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
#[test]
fn bindgen_test_layout_FieldStore() {
    assert_eq!(::std::mem::size_of::<FieldStore>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FieldStore ) ));
    assert_eq! (::std::mem::align_of::<FieldStore>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FieldStore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldStore ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldStore ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldStore ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldStore ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldStore ) ) . newvals as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldStore ) , "::" ,
                stringify ! ( newvals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldStore ) ) . fieldnums as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldStore ) , "::" ,
                stringify ! ( fieldnums ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FieldStore ) ) . resulttype as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FieldStore ) , "::" ,
                stringify ! ( resulttype ) ));
}
impl Clone for FieldStore {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RelabelType() {
    assert_eq!(::std::mem::size_of::<RelabelType>() , 40usize , concat ! (
               "Size of: " , stringify ! ( RelabelType ) ));
    assert_eq! (::std::mem::align_of::<RelabelType>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RelabelType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . resulttype as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( resulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . resulttypmod as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( resulttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . resultcollid as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( resultcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . relabelformat as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( relabelformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelabelType ) ) . location as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RelabelType ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for RelabelType {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceViaIO() {
    assert_eq!(::std::mem::size_of::<CoerceViaIO>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CoerceViaIO ) ));
    assert_eq! (::std::mem::align_of::<CoerceViaIO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CoerceViaIO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceViaIO ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceViaIO ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceViaIO ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceViaIO ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceViaIO ) ) . resulttype as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceViaIO ) , "::" ,
                stringify ! ( resulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceViaIO ) ) . resultcollid as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceViaIO ) , "::" ,
                stringify ! ( resultcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceViaIO ) ) . coerceformat as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceViaIO ) , "::" ,
                stringify ! ( coerceformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceViaIO ) ) . location as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceViaIO ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for CoerceViaIO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemfuncid: Oid,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub isExplicit: bool_,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ArrayCoerceExpr() {
    assert_eq!(::std::mem::size_of::<ArrayCoerceExpr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ArrayCoerceExpr ) ));
    assert_eq! (::std::mem::align_of::<ArrayCoerceExpr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ArrayCoerceExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . elemfuncid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( elemfuncid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . resulttype as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( resulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . resulttypmod as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( resulttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . resultcollid as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( resultcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . isExplicit as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( isExplicit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . coerceformat as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( coerceformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayCoerceExpr ) ) . location as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayCoerceExpr ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for ArrayCoerceExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ConvertRowtypeExpr() {
    assert_eq!(::std::mem::size_of::<ConvertRowtypeExpr>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( ConvertRowtypeExpr ) ));
    assert_eq! (::std::mem::align_of::<ConvertRowtypeExpr>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ConvertRowtypeExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConvertRowtypeExpr ) ) . xpr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ConvertRowtypeExpr ) ,
                "::" , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConvertRowtypeExpr ) ) . arg as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ConvertRowtypeExpr ) ,
                "::" , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConvertRowtypeExpr ) ) . resulttype as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ConvertRowtypeExpr ) ,
                "::" , stringify ! ( resulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConvertRowtypeExpr ) ) . convertformat as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ConvertRowtypeExpr ) ,
                "::" , stringify ! ( convertformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConvertRowtypeExpr ) ) . location as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ConvertRowtypeExpr ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for ConvertRowtypeExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CollateExpr() {
    assert_eq!(::std::mem::size_of::<CollateExpr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CollateExpr ) ));
    assert_eq! (::std::mem::align_of::<CollateExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CollateExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateExpr ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateExpr ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateExpr ) ) . collOid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateExpr ) , "::" ,
                stringify ! ( collOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateExpr ) ) . location as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for CollateExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CaseExpr() {
    assert_eq!(::std::mem::size_of::<CaseExpr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( CaseExpr ) ));
    assert_eq! (::std::mem::align_of::<CaseExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CaseExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . casetype as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( casetype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . casecollid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( casecollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . arg as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . args as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . defresult as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( defresult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseExpr ) ) . location as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for CaseExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CaseWhen() {
    assert_eq!(::std::mem::size_of::<CaseWhen>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CaseWhen ) ));
    assert_eq! (::std::mem::align_of::<CaseWhen>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CaseWhen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseWhen ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseWhen ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseWhen ) ) . expr as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseWhen ) , "::" ,
                stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseWhen ) ) . result as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseWhen ) , "::" ,
                stringify ! ( result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseWhen ) ) . location as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseWhen ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for CaseWhen {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
#[test]
fn bindgen_test_layout_CaseTestExpr() {
    assert_eq!(::std::mem::size_of::<CaseTestExpr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CaseTestExpr ) ));
    assert_eq! (::std::mem::align_of::<CaseTestExpr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CaseTestExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseTestExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseTestExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseTestExpr ) ) . typeId as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseTestExpr ) , "::" ,
                stringify ! ( typeId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseTestExpr ) ) . typeMod as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseTestExpr ) , "::" ,
                stringify ! ( typeMod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CaseTestExpr ) ) . collation as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CaseTestExpr ) , "::" ,
                stringify ! ( collation ) ));
}
impl Clone for CaseTestExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ArrayExpr() {
    assert_eq!(::std::mem::size_of::<ArrayExpr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ArrayExpr ) ));
    assert_eq! (::std::mem::align_of::<ArrayExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ArrayExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . array_typeid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( array_typeid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . array_collid as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( array_collid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . element_typeid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( element_typeid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . elements as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . multidims as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( multidims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayExpr ) ) . location as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for ArrayExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RowExpr() {
    assert_eq!(::std::mem::size_of::<RowExpr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( RowExpr ) ));
    assert_eq! (::std::mem::align_of::<RowExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RowExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowExpr ) ) . xpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RowExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowExpr ) ) . args as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RowExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowExpr ) ) . row_typeid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RowExpr ) , "::" ,
                stringify ! ( row_typeid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowExpr ) ) . row_format as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RowExpr ) , "::" ,
                stringify ! ( row_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowExpr ) ) . colnames as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RowExpr ) , "::" ,
                stringify ! ( colnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowExpr ) ) . location as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RowExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for RowExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RowCompareType {
    ROWCOMPARE_LT = 1,
    ROWCOMPARE_LE = 2,
    ROWCOMPARE_EQ = 3,
    ROWCOMPARE_GE = 4,
    ROWCOMPARE_GT = 5,
    ROWCOMPARE_NE = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
#[test]
fn bindgen_test_layout_RowCompareExpr() {
    assert_eq!(::std::mem::size_of::<RowCompareExpr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( RowCompareExpr ) ));
    assert_eq! (::std::mem::align_of::<RowCompareExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RowCompareExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . rctype as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( rctype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . opnos as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( opnos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . opfamilies as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( opfamilies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . inputcollids as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( inputcollids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . largs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( largs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowCompareExpr ) ) . rargs as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RowCompareExpr ) , "::"
                , stringify ! ( rargs ) ));
}
impl Clone for RowCompareExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoalesceExpr() {
    assert_eq!(::std::mem::size_of::<CoalesceExpr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CoalesceExpr ) ));
    assert_eq! (::std::mem::align_of::<CoalesceExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CoalesceExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoalesceExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CoalesceExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoalesceExpr ) ) . coalescetype as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CoalesceExpr ) , "::" ,
                stringify ! ( coalescetype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoalesceExpr ) ) . coalescecollid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CoalesceExpr ) , "::" ,
                stringify ! ( coalescecollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoalesceExpr ) ) . args as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CoalesceExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoalesceExpr ) ) . location as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CoalesceExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for CoalesceExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MinMaxOp { IS_GREATEST = 0, IS_LEAST = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MinMaxExpr() {
    assert_eq!(::std::mem::size_of::<MinMaxExpr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( MinMaxExpr ) ));
    assert_eq! (::std::mem::align_of::<MinMaxExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MinMaxExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . minmaxtype as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( minmaxtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . minmaxcollid as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( minmaxcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . inputcollid as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( inputcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . op as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . args as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxExpr ) ) . location as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for MinMaxExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SQLValueFunctionOp {
    SVFOP_CURRENT_DATE = 0,
    SVFOP_CURRENT_TIME = 1,
    SVFOP_CURRENT_TIME_N = 2,
    SVFOP_CURRENT_TIMESTAMP = 3,
    SVFOP_CURRENT_TIMESTAMP_N = 4,
    SVFOP_LOCALTIME = 5,
    SVFOP_LOCALTIME_N = 6,
    SVFOP_LOCALTIMESTAMP = 7,
    SVFOP_LOCALTIMESTAMP_N = 8,
    SVFOP_CURRENT_ROLE = 9,
    SVFOP_CURRENT_USER = 10,
    SVFOP_USER = 11,
    SVFOP_SESSION_USER = 12,
    SVFOP_CURRENT_CATALOG = 13,
    SVFOP_CURRENT_SCHEMA = 14,
}
#[repr(C)]
#[derive(Copy)]
pub struct SQLValueFunction {
    pub xpr: Expr,
    pub op: SQLValueFunctionOp,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SQLValueFunction() {
    assert_eq!(::std::mem::size_of::<SQLValueFunction>() , 20usize , concat !
               ( "Size of: " , stringify ! ( SQLValueFunction ) ));
    assert_eq! (::std::mem::align_of::<SQLValueFunction>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SQLValueFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SQLValueFunction ) ) . xpr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SQLValueFunction ) ,
                "::" , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SQLValueFunction ) ) . op as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SQLValueFunction ) ,
                "::" , stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SQLValueFunction ) ) . type_ as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SQLValueFunction ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SQLValueFunction ) ) . typmod as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SQLValueFunction ) ,
                "::" , stringify ! ( typmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SQLValueFunction ) ) . location as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SQLValueFunction ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for SQLValueFunction {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XmlExprOp {
    IS_XMLCONCAT = 0,
    IS_XMLELEMENT = 1,
    IS_XMLFOREST = 2,
    IS_XMLPARSE = 3,
    IS_XMLPI = 4,
    IS_XMLROOT = 5,
    IS_XMLSERIALIZE = 6,
    IS_DOCUMENT = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XmlOptionType { XMLOPTION_DOCUMENT = 0, XMLOPTION_CONTENT = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XmlExpr() {
    assert_eq!(::std::mem::size_of::<XmlExpr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( XmlExpr ) ));
    assert_eq! (::std::mem::align_of::<XmlExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( XmlExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . xpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . op as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . name as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . named_args as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( named_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . arg_names as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( arg_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . args as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . xmloption as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( xmloption ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . type_ as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . typmod as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( typmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlExpr ) ) . location as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for XmlExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NullTestType { IS_NULL = 0, IS_NOT_NULL = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NullTest() {
    assert_eq!(::std::mem::size_of::<NullTest>() , 32usize , concat ! (
               "Size of: " , stringify ! ( NullTest ) ));
    assert_eq! (::std::mem::align_of::<NullTest>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NullTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NullTest ) ) . xpr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NullTest ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NullTest ) ) . arg as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NullTest ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NullTest ) ) . nulltesttype as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( NullTest ) , "::" ,
                stringify ! ( nulltesttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NullTest ) ) . argisrow as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( NullTest ) , "::" ,
                stringify ! ( argisrow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NullTest ) ) . location as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( NullTest ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for NullTest {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BoolTestType {
    IS_TRUE = 0,
    IS_NOT_TRUE = 1,
    IS_FALSE = 2,
    IS_NOT_FALSE = 3,
    IS_UNKNOWN = 4,
    IS_NOT_UNKNOWN = 5,
}
#[repr(C)]
#[derive(Copy)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BooleanTest() {
    assert_eq!(::std::mem::size_of::<BooleanTest>() , 24usize , concat ! (
               "Size of: " , stringify ! ( BooleanTest ) ));
    assert_eq! (::std::mem::align_of::<BooleanTest>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BooleanTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BooleanTest ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BooleanTest ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BooleanTest ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( BooleanTest ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BooleanTest ) ) . booltesttype as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( BooleanTest ) , "::" ,
                stringify ! ( booltesttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BooleanTest ) ) . location as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( BooleanTest ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for BooleanTest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceToDomain() {
    assert_eq!(::std::mem::size_of::<CoerceToDomain>() , 40usize , concat ! (
               "Size of: " , stringify ! ( CoerceToDomain ) ));
    assert_eq! (::std::mem::align_of::<CoerceToDomain>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CoerceToDomain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . resulttype as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( resulttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . resulttypmod as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( resulttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . resultcollid as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( resultcollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . coercionformat as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( coercionformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomain ) ) . location as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomain ) , "::"
                , stringify ! ( location ) ));
}
impl Clone for CoerceToDomain {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceToDomainValue() {
    assert_eq!(::std::mem::size_of::<CoerceToDomainValue>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( CoerceToDomainValue ) ));
    assert_eq! (::std::mem::align_of::<CoerceToDomainValue>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CoerceToDomainValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomainValue ) ) . xpr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomainValue ) ,
                "::" , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomainValue ) ) . typeId as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomainValue ) ,
                "::" , stringify ! ( typeId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomainValue ) ) . typeMod as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomainValue ) ,
                "::" , stringify ! ( typeMod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomainValue ) ) . collation as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomainValue ) ,
                "::" , stringify ! ( collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CoerceToDomainValue ) ) . location as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CoerceToDomainValue ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for CoerceToDomainValue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SetToDefault() {
    assert_eq!(::std::mem::size_of::<SetToDefault>() , 20usize , concat ! (
               "Size of: " , stringify ! ( SetToDefault ) ));
    assert_eq! (::std::mem::align_of::<SetToDefault>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SetToDefault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetToDefault ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SetToDefault ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetToDefault ) ) . typeId as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SetToDefault ) , "::" ,
                stringify ! ( typeId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetToDefault ) ) . typeMod as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SetToDefault ) , "::" ,
                stringify ! ( typeMod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetToDefault ) ) . collation as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SetToDefault ) , "::" ,
                stringify ! ( collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetToDefault ) ) . location as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SetToDefault ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for SetToDefault {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CurrentOfExpr() {
    assert_eq!(::std::mem::size_of::<CurrentOfExpr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CurrentOfExpr ) ));
    assert_eq! (::std::mem::align_of::<CurrentOfExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CurrentOfExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CurrentOfExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CurrentOfExpr ) , "::"
                , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CurrentOfExpr ) ) . cvarno as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CurrentOfExpr ) , "::"
                , stringify ! ( cvarno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CurrentOfExpr ) ) . cursor_name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CurrentOfExpr ) , "::"
                , stringify ! ( cursor_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CurrentOfExpr ) ) . cursor_param as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CurrentOfExpr ) , "::"
                , stringify ! ( cursor_param ) ));
}
impl Clone for CurrentOfExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NextValueExpr {
    pub xpr: Expr,
    pub seqid: Oid,
    pub typeId: Oid,
}
#[test]
fn bindgen_test_layout_NextValueExpr() {
    assert_eq!(::std::mem::size_of::<NextValueExpr>() , 12usize , concat ! (
               "Size of: " , stringify ! ( NextValueExpr ) ));
    assert_eq! (::std::mem::align_of::<NextValueExpr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( NextValueExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NextValueExpr ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NextValueExpr ) , "::"
                , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NextValueExpr ) ) . seqid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( NextValueExpr ) , "::"
                , stringify ! ( seqid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NextValueExpr ) ) . typeId as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NextValueExpr ) , "::"
                , stringify ! ( typeId ) ));
}
impl Clone for NextValueExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
#[test]
fn bindgen_test_layout_InferenceElem() {
    assert_eq!(::std::mem::size_of::<InferenceElem>() , 24usize , concat ! (
               "Size of: " , stringify ! ( InferenceElem ) ));
    assert_eq! (::std::mem::align_of::<InferenceElem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( InferenceElem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferenceElem ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( InferenceElem ) , "::"
                , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferenceElem ) ) . expr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( InferenceElem ) , "::"
                , stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferenceElem ) ) . infercollid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( InferenceElem ) , "::"
                , stringify ! ( infercollid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferenceElem ) ) . inferopclass as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( InferenceElem ) , "::"
                , stringify ! ( inferopclass ) ));
}
impl Clone for InferenceElem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool_,
}
#[test]
fn bindgen_test_layout_TargetEntry() {
    assert_eq!(::std::mem::size_of::<TargetEntry>() , 48usize , concat ! (
               "Size of: " , stringify ! ( TargetEntry ) ));
    assert_eq! (::std::mem::align_of::<TargetEntry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TargetEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . expr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . resno as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( resno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . resname as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( resname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . ressortgroupref as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( ressortgroupref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . resorigtbl as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( resorigtbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . resorigcol as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( resorigcol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TargetEntry ) ) . resjunk as * const _ as
                usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( TargetEntry ) , "::" ,
                stringify ! ( resjunk ) ));
}
impl Clone for TargetEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTblRef() {
    assert_eq!(::std::mem::size_of::<RangeTblRef>() , 8usize , concat ! (
               "Size of: " , stringify ! ( RangeTblRef ) ));
    assert_eq! (::std::mem::align_of::<RangeTblRef>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RangeTblRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblRef ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblRef ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblRef ) ) . rtindex as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblRef ) , "::" ,
                stringify ! ( rtindex ) ));
}
impl Clone for RangeTblRef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool_,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JoinExpr() {
    assert_eq!(::std::mem::size_of::<JoinExpr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( JoinExpr ) ));
    assert_eq! (::std::mem::align_of::<JoinExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( JoinExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . jointype as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( jointype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . isNatural as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( isNatural ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . larg as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( larg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . rarg as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( rarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . usingClause as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( usingClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . quals as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( quals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . alias as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinExpr ) ) . rtindex as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinExpr ) , "::" ,
                stringify ! ( rtindex ) ));
}
impl Clone for JoinExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
#[test]
fn bindgen_test_layout_FromExpr() {
    assert_eq!(::std::mem::size_of::<FromExpr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( FromExpr ) ));
    assert_eq! (::std::mem::align_of::<FromExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FromExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FromExpr ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FromExpr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FromExpr ) ) . fromlist as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FromExpr ) , "::" ,
                stringify ! ( fromlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FromExpr ) ) . quals as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FromExpr ) , "::" ,
                stringify ! ( quals ) ));
}
impl Clone for FromExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: *mut List,
}
#[test]
fn bindgen_test_layout_OnConflictExpr() {
    assert_eq!(::std::mem::size_of::<OnConflictExpr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( OnConflictExpr ) ));
    assert_eq! (::std::mem::align_of::<OnConflictExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( OnConflictExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . action as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . arbiterElems as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( arbiterElems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . arbiterWhere as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( arbiterWhere ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . constraint as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . onConflictSet as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( onConflictSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . onConflictWhere as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( onConflictWhere ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . exclRelIndex as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( exclRelIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictExpr ) ) . exclRelTlist as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictExpr ) , "::"
                , stringify ! ( exclRelTlist ) ));
}
impl Clone for OnConflictExpr {
    fn clone(&self) -> Self { *self }
}
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[test]
fn bindgen_test_layout_PageXLogRecPtr() {
    assert_eq!(::std::mem::size_of::<PageXLogRecPtr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( PageXLogRecPtr ) ));
    assert_eq! (::std::mem::align_of::<PageXLogRecPtr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( PageXLogRecPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PageXLogRecPtr ) ) . xlogid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PageXLogRecPtr ) , "::"
                , stringify ! ( xlogid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PageXLogRecPtr ) ) . xrecoff as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PageXLogRecPtr ) , "::"
                , stringify ! ( xrecoff ) ));
}
impl Clone for PageXLogRecPtr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: __IncompleteArrayField<ItemIdData>,
}
#[test]
fn bindgen_test_layout_PageHeaderData() {
    assert_eq!(::std::mem::size_of::<PageHeaderData>() , 24usize , concat ! (
               "Size of: " , stringify ! ( PageHeaderData ) ));
    assert_eq! (::std::mem::align_of::<PageHeaderData>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( PageHeaderData ) ));
}
pub type PageHeader = *mut PageHeaderData;
extern "C" {
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
}
extern "C" {
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> bool_;
}
extern "C" {
    pub fn PageAddItemExtended(page: Page, item: Item, size: Size,
                               offsetNumber: OffsetNumber,
                               flags: ::std::os::raw::c_int) -> OffsetNumber;
}
extern "C" {
    pub fn PageGetTempPage(page: Page) -> Page;
}
extern "C" {
    pub fn PageGetTempPageCopy(page: Page) -> Page;
}
extern "C" {
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
}
extern "C" {
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
}
extern "C" {
    pub fn PageRepairFragmentation(page: Page);
}
extern "C" {
    pub fn PageGetFreeSpace(page: Page) -> Size;
}
extern "C" {
    pub fn PageGetFreeSpaceForMultipleTuples(page: Page,
                                             ntups: ::std::os::raw::c_int)
     -> Size;
}
extern "C" {
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
}
extern "C" {
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
}
extern "C" {
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
}
extern "C" {
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PageIndexTupleDeleteNoCompact(page: Page, offset: OffsetNumber);
}
extern "C" {
    pub fn PageIndexTupleOverwrite(page: Page, offnum: OffsetNumber,
                                   newtup: Item, newsize: Size) -> bool_;
}
extern "C" {
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BulkInsertStateData {
    _unused: [u8; 0],
}
pub type BulkInsertState = *mut BulkInsertStateData;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockTupleMode {
    LockTupleKeyShare = 0,
    LockTupleShare = 1,
    LockTupleNoKeyExclusive = 2,
    LockTupleExclusive = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct HeapUpdateFailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
}
#[test]
fn bindgen_test_layout_HeapUpdateFailureData() {
    assert_eq!(::std::mem::size_of::<HeapUpdateFailureData>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( HeapUpdateFailureData )
               ));
    assert_eq! (::std::mem::align_of::<HeapUpdateFailureData>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( HeapUpdateFailureData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapUpdateFailureData ) ) . ctid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapUpdateFailureData )
                , "::" , stringify ! ( ctid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapUpdateFailureData ) ) . xmax as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapUpdateFailureData )
                , "::" , stringify ! ( xmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapUpdateFailureData ) ) . cmax as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapUpdateFailureData )
                , "::" , stringify ! ( cmax ) ));
}
impl Clone for HeapUpdateFailureData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn relation_openrv(relation: *const RangeVar, lockmode: LOCKMODE)
     -> Relation;
}
extern "C" {
    pub fn relation_openrv_extended(relation: *const RangeVar,
                                    lockmode: LOCKMODE, missing_ok: bool_)
     -> Relation;
}
extern "C" {
    pub fn relation_close(relation: Relation, lockmode: LOCKMODE);
}
extern "C" {
    pub fn heap_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn heap_openrv(relation: *const RangeVar, lockmode: LOCKMODE)
     -> Relation;
}
extern "C" {
    pub fn heap_openrv_extended(relation: *const RangeVar, lockmode: LOCKMODE,
                                missing_ok: bool_) -> Relation;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapScanDescData {
    _unused: [u8; 0],
}
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHeapScanDescData {
    _unused: [u8; 0],
}
pub type ParallelHeapScanDesc = *mut ParallelHeapScanDescData;
extern "C" {
    pub fn heap_beginscan(relation: Relation, snapshot: Snapshot,
                          nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_catalog(relation: Relation,
                                  nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_strat(relation: Relation, snapshot: Snapshot,
                                nkeys: ::std::os::raw::c_int, key: ScanKey,
                                allow_strat: bool_, allow_sync: bool_)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_bm(relation: Relation, snapshot: Snapshot,
                             nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_sampling(relation: Relation, snapshot: Snapshot,
                                   nkeys: ::std::os::raw::c_int, key: ScanKey,
                                   allow_strat: bool_, allow_sync: bool_,
                                   allow_pagemode: bool_) -> HeapScanDesc;
}
extern "C" {
    pub fn heap_setscanlimits(scan: HeapScanDesc, startBlk: BlockNumber,
                              endBlk: BlockNumber);
}
extern "C" {
    pub fn heapgetpage(scan: HeapScanDesc, page: BlockNumber);
}
extern "C" {
    pub fn heap_rescan(scan: HeapScanDesc, key: ScanKey);
}
extern "C" {
    pub fn heap_rescan_set_params(scan: HeapScanDesc, key: ScanKey,
                                  allow_strat: bool_, allow_sync: bool_,
                                  allow_pagemode: bool_);
}
extern "C" {
    pub fn heap_endscan(scan: HeapScanDesc);
}
extern "C" {
    pub fn heap_getnext(scan: HeapScanDesc, direction: ScanDirection)
     -> HeapTuple;
}
extern "C" {
    pub fn heap_parallelscan_estimate(snapshot: Snapshot) -> Size;
}
extern "C" {
    pub fn heap_parallelscan_initialize(target: ParallelHeapScanDesc,
                                        relation: Relation,
                                        snapshot: Snapshot);
}
extern "C" {
    pub fn heap_parallelscan_reinitialize(parallel_scan:
                                              ParallelHeapScanDesc);
}
extern "C" {
    pub fn heap_beginscan_parallel(arg1: Relation, arg2: ParallelHeapScanDesc)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_fetch(relation: Relation, snapshot: Snapshot,
                      tuple: HeapTuple, userbuf: *mut Buffer, keep_buf: bool_,
                      stats_relation: Relation) -> bool_;
}
extern "C" {
    pub fn heap_hot_search_buffer(tid: ItemPointer, relation: Relation,
                                  buffer: Buffer, snapshot: Snapshot,
                                  heapTuple: HeapTuple, all_dead: *mut bool_,
                                  first_call: bool_) -> bool_;
}
extern "C" {
    pub fn heap_hot_search(tid: ItemPointer, relation: Relation,
                           snapshot: Snapshot, all_dead: *mut bool_) -> bool_;
}
extern "C" {
    pub fn heap_get_latest_tid(relation: Relation, snapshot: Snapshot,
                               tid: ItemPointer);
}
extern "C" {
    pub fn setLastTid(tid: ItemPointer);
}
extern "C" {
    pub fn GetBulkInsertState() -> BulkInsertState;
}
extern "C" {
    pub fn FreeBulkInsertState(arg1: BulkInsertState);
}
extern "C" {
    pub fn ReleaseBulkInsertStatePin(bistate: BulkInsertState);
}
extern "C" {
    pub fn heap_insert(relation: Relation, tup: HeapTuple, cid: CommandId,
                       options: ::std::os::raw::c_int,
                       bistate: BulkInsertState) -> Oid;
}
extern "C" {
    pub fn heap_multi_insert(relation: Relation, tuples: *mut HeapTuple,
                             ntuples: ::std::os::raw::c_int, cid: CommandId,
                             options: ::std::os::raw::c_int,
                             bistate: BulkInsertState);
}
extern "C" {
    pub fn heap_delete(relation: Relation, tid: ItemPointer, cid: CommandId,
                       crosscheck: Snapshot, wait: bool_,
                       hufd: *mut HeapUpdateFailureData) -> HTSU_Result;
}
extern "C" {
    pub fn heap_finish_speculative(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    pub fn heap_abort_speculative(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    pub fn heap_update(relation: Relation, otid: ItemPointer,
                       newtup: HeapTuple, cid: CommandId,
                       crosscheck: Snapshot, wait: bool_,
                       hufd: *mut HeapUpdateFailureData,
                       lockmode: *mut LockTupleMode) -> HTSU_Result;
}
extern "C" {
    pub fn heap_lock_tuple(relation: Relation, tuple: HeapTuple,
                           cid: CommandId, mode: LockTupleMode,
                           wait_policy: LockWaitPolicy, follow_update: bool_,
                           buffer: *mut Buffer,
                           hufd: *mut HeapUpdateFailureData) -> HTSU_Result;
}
extern "C" {
    pub fn heap_inplace_update(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    pub fn heap_freeze_tuple(tuple: HeapTupleHeader,
                             cutoff_xid: TransactionId,
                             cutoff_multi: TransactionId) -> bool_;
}
extern "C" {
    pub fn heap_tuple_needs_freeze(tuple: HeapTupleHeader,
                                   cutoff_xid: TransactionId,
                                   cutoff_multi: MultiXactId, buf: Buffer)
     -> bool_;
}
extern "C" {
    pub fn heap_tuple_needs_eventual_freeze(tuple: HeapTupleHeader) -> bool_;
}
extern "C" {
    pub fn simple_heap_insert(relation: Relation, tup: HeapTuple) -> Oid;
}
extern "C" {
    pub fn simple_heap_delete(relation: Relation, tid: ItemPointer);
}
extern "C" {
    pub fn simple_heap_update(relation: Relation, otid: ItemPointer,
                              tup: HeapTuple);
}
extern "C" {
    pub fn heap_sync(relation: Relation);
}
extern "C" {
    pub fn heap_update_snapshot(scan: HeapScanDesc, snapshot: Snapshot);
}
extern "C" {
    pub fn heap_page_prune_opt(relation: Relation, buffer: Buffer);
}
extern "C" {
    pub fn heap_page_prune(relation: Relation, buffer: Buffer,
                           OldestXmin: TransactionId, report_stats: bool_,
                           latestRemovedXid: *mut TransactionId)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heap_page_prune_execute(buffer: Buffer,
                                   redirected: *mut OffsetNumber,
                                   nredirected: ::std::os::raw::c_int,
                                   nowdead: *mut OffsetNumber,
                                   ndead: ::std::os::raw::c_int,
                                   nowunused: *mut OffsetNumber,
                                   nunused: ::std::os::raw::c_int);
}
extern "C" {
    pub fn heap_get_root_tuples(page: Page, root_offsets: *mut OffsetNumber);
}
extern "C" {
    pub fn ss_report_location(rel: Relation, location: BlockNumber);
}
extern "C" {
    pub fn ss_get_location(rel: Relation, relnblocks: BlockNumber)
     -> BlockNumber;
}
extern "C" {
    pub fn SyncScanShmemInit();
}
extern "C" {
    pub fn SyncScanShmemSize() -> Size;
}
#[repr(C)]
#[derive(Copy)]
pub struct TupleConversionMap {
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub attrMap: *mut AttrNumber,
    pub invalues: *mut Datum,
    pub inisnull: *mut bool_,
    pub outvalues: *mut Datum,
    pub outisnull: *mut bool_,
}
#[test]
fn bindgen_test_layout_TupleConversionMap() {
    assert_eq!(::std::mem::size_of::<TupleConversionMap>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( TupleConversionMap ) ));
    assert_eq! (::std::mem::align_of::<TupleConversionMap>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TupleConversionMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . indesc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( indesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . outdesc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( outdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . attrMap as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( attrMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . invalues as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( invalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . inisnull as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( inisnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . outvalues as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( outvalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleConversionMap ) ) . outisnull as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleConversionMap ) ,
                "::" , stringify ! ( outisnull ) ));
}
impl Clone for TupleConversionMap {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn convert_tuples_by_position(indesc: TupleDesc, outdesc: TupleDesc,
                                      msg: *const ::std::os::raw::c_char)
     -> *mut TupleConversionMap;
}
extern "C" {
    pub fn convert_tuples_by_name(indesc: TupleDesc, outdesc: TupleDesc,
                                  msg: *const ::std::os::raw::c_char)
     -> *mut TupleConversionMap;
}
extern "C" {
    pub fn convert_tuples_by_name_map(indesc: TupleDesc, outdesc: TupleDesc,
                                      msg: *const ::std::os::raw::c_char)
     -> *mut AttrNumber;
}
extern "C" {
    pub fn do_convert_tuple(tuple: HeapTuple, map: *mut TupleConversionMap)
     -> HeapTuple;
}
extern "C" {
    pub fn free_conversion_map(map: *mut TupleConversionMap);
}
#[repr(C)]
#[derive(Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type instr_time = timespec;
#[repr(C)]
#[derive(Copy)]
pub struct BufferUsage {
    pub shared_blks_hit: ::std::os::raw::c_long,
    pub shared_blks_read: ::std::os::raw::c_long,
    pub shared_blks_dirtied: ::std::os::raw::c_long,
    pub shared_blks_written: ::std::os::raw::c_long,
    pub local_blks_hit: ::std::os::raw::c_long,
    pub local_blks_read: ::std::os::raw::c_long,
    pub local_blks_dirtied: ::std::os::raw::c_long,
    pub local_blks_written: ::std::os::raw::c_long,
    pub temp_blks_read: ::std::os::raw::c_long,
    pub temp_blks_written: ::std::os::raw::c_long,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
}
#[test]
fn bindgen_test_layout_BufferUsage() {
    assert_eq!(::std::mem::size_of::<BufferUsage>() , 112usize , concat ! (
               "Size of: " , stringify ! ( BufferUsage ) ));
    assert_eq! (::std::mem::align_of::<BufferUsage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BufferUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . shared_blks_hit as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( shared_blks_hit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . shared_blks_read as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( shared_blks_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . shared_blks_dirtied as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( shared_blks_dirtied ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . shared_blks_written as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( shared_blks_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . local_blks_hit as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( local_blks_hit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . local_blks_read as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( local_blks_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . local_blks_dirtied as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( local_blks_dirtied ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . local_blks_written as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( local_blks_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . temp_blks_read as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( temp_blks_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . temp_blks_written as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( temp_blks_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . blk_read_time as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( blk_read_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BufferUsage ) ) . blk_write_time as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( BufferUsage ) , "::" ,
                stringify ! ( blk_write_time ) ));
}
impl Clone for BufferUsage {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum InstrumentOption {
    INSTRUMENT_TIMER = 1,
    INSTRUMENT_BUFFERS = 2,
    INSTRUMENT_ROWS = 4,
    INSTRUMENT_ALL = 2147483647,
}
#[repr(C)]
#[derive(Copy)]
pub struct Instrumentation {
    pub need_timer: bool_,
    pub need_bufusage: bool_,
    pub running: bool_,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
}
#[test]
fn bindgen_test_layout_Instrumentation() {
    assert_eq!(::std::mem::size_of::<Instrumentation>() , 328usize , concat !
               ( "Size of: " , stringify ! ( Instrumentation ) ));
    assert_eq! (::std::mem::align_of::<Instrumentation>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( Instrumentation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . need_timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( need_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . need_bufusage as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( need_bufusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . running as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . starttime as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( starttime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . counter as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . firsttuple as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( firsttuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . tuplecount as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( tuplecount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . bufusage_start as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( bufusage_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . startup as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( startup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . total as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . ntuples as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( ntuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . nloops as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( nloops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . nfiltered1 as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( nfiltered1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . nfiltered2 as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( nfiltered2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Instrumentation ) ) . bufusage as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( Instrumentation ) ,
                "::" , stringify ! ( bufusage ) ));
}
impl Clone for Instrumentation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct WorkerInstrumentation {
    pub num_workers: ::std::os::raw::c_int,
    pub instrument: __IncompleteArrayField<Instrumentation>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WorkerInstrumentation() {
    assert_eq!(::std::mem::size_of::<WorkerInstrumentation>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( WorkerInstrumentation )
               ));
    assert_eq! (::std::mem::align_of::<WorkerInstrumentation>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( WorkerInstrumentation ) ));
}
extern "C" {
    #[link_name = "pgBufferUsage"]
    pub static mut pgBufferUsage: BufferUsage;
}
extern "C" {
    pub fn InstrAlloc(n: ::std::os::raw::c_int,
                      instrument_options: ::std::os::raw::c_int)
     -> *mut Instrumentation;
}
extern "C" {
    pub fn InstrInit(instr: *mut Instrumentation,
                     instrument_options: ::std::os::raw::c_int);
}
extern "C" {
    pub fn InstrStartNode(instr: *mut Instrumentation);
}
extern "C" {
    pub fn InstrStopNode(instr: *mut Instrumentation, nTuples: f64);
}
extern "C" {
    pub fn InstrEndLoop(instr: *mut Instrumentation);
}
extern "C" {
    pub fn InstrAggNode(dst: *mut Instrumentation, add: *mut Instrumentation);
}
extern "C" {
    pub fn InstrStartParallelQuery();
}
extern "C" {
    pub fn InstrEndParallelQuery(result: *mut BufferUsage);
}
extern "C" {
    pub fn InstrAccumParallelQuery(result: *mut BufferUsage);
}
#[repr(C)]
#[derive(Copy)]
pub struct ParseState {
    pub parentParseState: *mut ParseState,
    pub p_sourcetext: *const ::std::os::raw::c_char,
    pub p_rtable: *mut List,
    pub p_joinexprs: *mut List,
    pub p_joinlist: *mut List,
    pub p_namespace: *mut List,
    pub p_lateral_active: bool_,
    pub p_ctenamespace: *mut List,
    pub p_future_ctes: *mut List,
    pub p_parent_cte: *mut CommonTableExpr,
    pub p_target_relation: Relation,
    pub p_target_rangetblentry: *mut RangeTblEntry,
    pub p_is_insert: bool_,
    pub p_windowdefs: *mut List,
    pub p_expr_kind: ParseExprKind,
    pub p_next_resno: ::std::os::raw::c_int,
    pub p_multiassign_exprs: *mut List,
    pub p_locking_clause: *mut List,
    pub p_locked_from_parent: bool_,
    pub p_resolve_unknowns: bool_,
    pub p_queryEnv: *mut QueryEnvironment,
    pub p_hasAggs: bool_,
    pub p_hasWindowFuncs: bool_,
    pub p_hasTargetSRFs: bool_,
    pub p_hasSubLinks: bool_,
    pub p_hasModifyingCTE: bool_,
    pub p_last_srf: *mut Node,
    pub p_pre_columnref_hook: PreParseColumnRefHook,
    pub p_post_columnref_hook: PostParseColumnRefHook,
    pub p_paramref_hook: ParseParamRefHook,
    pub p_coerce_param_hook: CoerceParamHook,
    pub p_ref_hook_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ParseState() {
    assert_eq!(::std::mem::size_of::<ParseState>() , 208usize , concat ! (
               "Size of: " , stringify ! ( ParseState ) ));
    assert_eq! (::std::mem::align_of::<ParseState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ParseState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . parentParseState as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( parentParseState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_sourcetext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_sourcetext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_rtable as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_rtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_joinexprs as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_joinexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_joinlist as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_joinlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_namespace as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_namespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_lateral_active as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_lateral_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_ctenamespace as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_ctenamespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_future_ctes as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_future_ctes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_parent_cte as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_parent_cte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_target_relation as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_target_relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_target_rangetblentry
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_target_rangetblentry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_is_insert as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_is_insert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_windowdefs as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_windowdefs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_expr_kind as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_expr_kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_next_resno as * const
                _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_next_resno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_multiassign_exprs as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_multiassign_exprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_locking_clause as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_locking_clause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_locked_from_parent as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_locked_from_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_resolve_unknowns as *
                const _ as usize } , 137usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_resolve_unknowns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_queryEnv as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_queryEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_hasAggs as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_hasAggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_hasWindowFuncs as *
                const _ as usize } , 153usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_hasWindowFuncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_hasTargetSRFs as *
                const _ as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_hasTargetSRFs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_hasSubLinks as * const
                _ as usize } , 155usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_hasSubLinks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_hasModifyingCTE as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_hasModifyingCTE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_last_srf as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_last_srf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_pre_columnref_hook as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_pre_columnref_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_post_columnref_hook as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_post_columnref_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_paramref_hook as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_paramref_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_coerce_param_hook as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_coerce_param_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseState ) ) . p_ref_hook_state as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseState ) , "::" ,
                stringify ! ( p_ref_hook_state ) ));
}
impl Clone for ParseState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool_,
    pub pflags: uint16,
    pub ptype: Oid,
}
#[test]
fn bindgen_test_layout_ParamExternData() {
    assert_eq!(::std::mem::size_of::<ParamExternData>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ParamExternData ) ));
    assert_eq! (::std::mem::align_of::<ParamExternData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ParamExternData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExternData ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExternData ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExternData ) ) . isnull as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExternData ) ,
                "::" , stringify ! ( isnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExternData ) ) . pflags as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExternData ) ,
                "::" , stringify ! ( pflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExternData ) ) . ptype as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExternData ) ,
                "::" , stringify ! ( ptype ) ));
}
impl Clone for ParamExternData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::std::os::raw::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub numParams: ::std::os::raw::c_int,
    pub paramMask: *mut Bitmapset,
    pub params: __IncompleteArrayField<ParamExternData>,
}
#[test]
fn bindgen_test_layout_ParamListInfoData() {
    assert_eq!(::std::mem::size_of::<ParamListInfoData>() , 48usize , concat !
               ( "Size of: " , stringify ! ( ParamListInfoData ) ));
    assert_eq! (::std::mem::align_of::<ParamListInfoData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ParamListInfoData ) ));
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook =
    ::std::option::Option<unsafe extern "C" fn(params: ParamListInfo,
                                               paramid:
                                                   ::std::os::raw::c_int)>;
pub type ParserSetupHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct ParamExecData {
    pub execPlan: *mut ::std::os::raw::c_void,
    pub value: Datum,
    pub isnull: bool_,
}
#[test]
fn bindgen_test_layout_ParamExecData() {
    assert_eq!(::std::mem::size_of::<ParamExecData>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ParamExecData ) ));
    assert_eq! (::std::mem::align_of::<ParamExecData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ParamExecData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExecData ) ) . execPlan as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExecData ) , "::"
                , stringify ! ( execPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExecData ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExecData ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamExecData ) ) . isnull as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamExecData ) , "::"
                , stringify ! ( isnull ) ));
}
impl Clone for ParamExecData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn copyParamList(from: ParamListInfo) -> ParamListInfo;
}
extern "C" {
    pub fn EstimateParamListSpace(paramLI: ParamListInfo) -> Size;
}
extern "C" {
    pub fn SerializeParamList(paramLI: ParamListInfo,
                              start_address:
                                  *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn RestoreParamList(start_address: *mut *mut ::std::os::raw::c_char)
     -> ParamListInfo;
}
#[repr(C)]
#[derive(Copy)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint32,
    pub hasReturning: bool_,
    pub hasModifyingCTE: bool_,
    pub canSetTag: bool_,
    pub transientPlan: bool_,
    pub dependsOnRole: bool_,
    pub parallelModeNeeded: bool_,
    pub planTree: *mut Plan,
    pub rtable: *mut List,
    pub resultRelations: *mut List,
    pub nonleafResultRelations: *mut List,
    pub rootResultRelations: *mut List,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub nParamExec: ::std::os::raw::c_int,
    pub utilityStmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PlannedStmt() {
    assert_eq!(::std::mem::size_of::<PlannedStmt>() , 128usize , concat ! (
               "Size of: " , stringify ! ( PlannedStmt ) ));
    assert_eq! (::std::mem::align_of::<PlannedStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PlannedStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . commandType as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( commandType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . queryId as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( queryId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . hasReturning as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( hasReturning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . hasModifyingCTE as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( hasModifyingCTE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . canSetTag as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( canSetTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . transientPlan as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( transientPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . dependsOnRole as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( dependsOnRole ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . parallelModeNeeded as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( parallelModeNeeded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . planTree as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( planTree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . rtable as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( rtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . resultRelations as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( resultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . nonleafResultRelations
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( nonleafResultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . rootResultRelations as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( rootResultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . subplans as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( subplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . rewindPlanIDs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( rewindPlanIDs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . rowMarks as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . relationOids as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( relationOids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . invalItems as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( invalItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . nParamExec as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( nParamExec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . utilityStmt as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( utilityStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . stmt_location as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( stmt_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannedStmt ) ) . stmt_len as * const _
                as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannedStmt ) , "::" ,
                stringify ! ( stmt_len ) ));
}
impl Clone for PlannedStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: f64,
    pub plan_width: ::std::os::raw::c_int,
    pub parallel_aware: bool_,
    pub parallel_safe: bool_,
    pub plan_node_id: ::std::os::raw::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut Plan,
    pub righttree: *mut Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_Plan() {
    assert_eq!(::std::mem::size_of::<Plan>() , 104usize , concat ! (
               "Size of: " , stringify ! ( Plan ) ));
    assert_eq! (::std::mem::align_of::<Plan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . startup_cost as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( startup_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . total_cost as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( total_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . plan_rows as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( plan_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . plan_width as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( plan_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . parallel_aware as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( parallel_aware ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . parallel_safe as * const _ as
                usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( parallel_safe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . plan_node_id as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( plan_node_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . targetlist as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( targetlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . qual as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . lefttree as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( lefttree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . righttree as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( righttree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . initPlan as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( initPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . extParam as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( extParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Plan ) ) . allParam as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( Plan ) , "::" ,
                stringify ! ( allParam ) ));
}
impl Clone for Plan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
#[test]
fn bindgen_test_layout_Result() {
    assert_eq!(::std::mem::size_of::<Result>() , 112usize , concat ! (
               "Size of: " , stringify ! ( Result ) ));
    assert_eq! (::std::mem::align_of::<Result>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Result ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Result ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Result ) ) . resconstantqual as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Result ) , "::" ,
                stringify ! ( resconstantqual ) ));
}
impl Clone for Result {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ProjectSet {
    pub plan: Plan,
}
#[test]
fn bindgen_test_layout_ProjectSet() {
    assert_eq!(::std::mem::size_of::<ProjectSet>() , 104usize , concat ! (
               "Size of: " , stringify ! ( ProjectSet ) ));
    assert_eq! (::std::mem::align_of::<ProjectSet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ProjectSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSet ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSet ) , "::" ,
                stringify ! ( plan ) ));
}
impl Clone for ProjectSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub nominalRelation: Index,
    pub partitioned_rels: *mut List,
    pub resultRelations: *mut List,
    pub resultRelIndex: ::std::os::raw::c_int,
    pub rootResultRelIndex: ::std::os::raw::c_int,
    pub plans: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub fdwDirectModifyPlans: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
    pub onConflictAction: OnConflictAction,
    pub arbiterIndexes: *mut List,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelRTI: Index,
    pub exclRelTlist: *mut List,
}
#[test]
fn bindgen_test_layout_ModifyTable() {
    assert_eq!(::std::mem::size_of::<ModifyTable>() , 240usize , concat ! (
               "Size of: " , stringify ! ( ModifyTable ) ));
    assert_eq! (::std::mem::align_of::<ModifyTable>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ModifyTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . operation as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . canSetTag as * const _
                as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( canSetTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . nominalRelation as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( nominalRelation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . partitioned_rels as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( partitioned_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . resultRelations as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( resultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . resultRelIndex as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( resultRelIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . rootResultRelIndex as *
                const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( rootResultRelIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . plans as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( plans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . withCheckOptionLists as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( withCheckOptionLists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . returningLists as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( returningLists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . fdwPrivLists as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( fdwPrivLists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . fdwDirectModifyPlans as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( fdwDirectModifyPlans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . rowMarks as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . epqParam as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( epqParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . onConflictAction as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( onConflictAction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . arbiterIndexes as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( arbiterIndexes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . onConflictSet as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( onConflictSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . onConflictWhere as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( onConflictWhere ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . exclRelRTI as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( exclRelRTI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTable ) ) . exclRelTlist as * const
                _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTable ) , "::" ,
                stringify ! ( exclRelTlist ) ));
}
impl Clone for ModifyTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Append {
    pub plan: Plan,
    pub partitioned_rels: *mut List,
    pub appendplans: *mut List,
}
#[test]
fn bindgen_test_layout_Append() {
    assert_eq!(::std::mem::size_of::<Append>() , 120usize , concat ! (
               "Size of: " , stringify ! ( Append ) ));
    assert_eq! (::std::mem::align_of::<Append>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Append ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Append ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Append ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Append ) ) . partitioned_rels as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Append ) , "::" ,
                stringify ! ( partitioned_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Append ) ) . appendplans as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Append ) , "::" ,
                stringify ! ( appendplans ) ));
}
impl Clone for Append {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MergeAppend {
    pub plan: Plan,
    pub partitioned_rels: *mut List,
    pub mergeplans: *mut List,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_MergeAppend() {
    assert_eq!(::std::mem::size_of::<MergeAppend>() , 160usize , concat ! (
               "Size of: " , stringify ! ( MergeAppend ) ));
    assert_eq! (::std::mem::align_of::<MergeAppend>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MergeAppend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . partitioned_rels as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( partitioned_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . mergeplans as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( mergeplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . numCols as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . sortColIdx as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( sortColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . sortOperators as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( sortOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . collations as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( collations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppend ) ) . nullsFirst as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppend ) , "::" ,
                stringify ! ( nullsFirst ) ));
}
impl Clone for MergeAppend {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_RecursiveUnion() {
    assert_eq!(::std::mem::size_of::<RecursiveUnion>() , 136usize , concat ! (
               "Size of: " , stringify ! ( RecursiveUnion ) ));
    assert_eq! (::std::mem::align_of::<RecursiveUnion>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RecursiveUnion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnion ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnion ) , "::"
                , stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnion ) ) . wtParam as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnion ) , "::"
                , stringify ! ( wtParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnion ) ) . numCols as * const _
                as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnion ) , "::"
                , stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnion ) ) . dupColIdx as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnion ) , "::"
                , stringify ! ( dupColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnion ) ) . dupOperators as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnion ) , "::"
                , stringify ! ( dupOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnion ) ) . numGroups as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnion ) , "::"
                , stringify ! ( numGroups ) ));
}
impl Clone for RecursiveUnion {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapAnd() {
    assert_eq!(::std::mem::size_of::<BitmapAnd>() , 112usize , concat ! (
               "Size of: " , stringify ! ( BitmapAnd ) ));
    assert_eq! (::std::mem::align_of::<BitmapAnd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapAnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAnd ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAnd ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAnd ) ) . bitmapplans as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAnd ) , "::" ,
                stringify ! ( bitmapplans ) ));
}
impl Clone for BitmapAnd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapOr {
    pub plan: Plan,
    pub isshared: bool_,
    pub bitmapplans: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapOr() {
    assert_eq!(::std::mem::size_of::<BitmapOr>() , 120usize , concat ! (
               "Size of: " , stringify ! ( BitmapOr ) ));
    assert_eq! (::std::mem::align_of::<BitmapOr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapOr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOr ) ) . plan as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOr ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOr ) ) . isshared as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOr ) , "::" ,
                stringify ! ( isshared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOr ) ) . bitmapplans as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOr ) , "::" ,
                stringify ! ( bitmapplans ) ));
}
impl Clone for BitmapOr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
#[test]
fn bindgen_test_layout_Scan() {
    assert_eq!(::std::mem::size_of::<Scan>() , 112usize , concat ! (
               "Size of: " , stringify ! ( Scan ) ));
    assert_eq! (::std::mem::align_of::<Scan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Scan ) ) . plan as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Scan ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Scan ) ) . scanrelid as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Scan ) , "::" ,
                stringify ! ( scanrelid ) ));
}
impl Clone for Scan {
    fn clone(&self) -> Self { *self }
}
pub type SeqScan = Scan;
#[repr(C)]
#[derive(Copy)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: *mut TableSampleClause,
}
#[test]
fn bindgen_test_layout_SampleScan() {
    assert_eq!(::std::mem::size_of::<SampleScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( SampleScan ) ));
    assert_eq! (::std::mem::align_of::<SampleScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SampleScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScan ) ) . tablesample as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScan ) , "::" ,
                stringify ! ( tablesample ) ));
}
impl Clone for SampleScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderbyops: *mut List,
    pub indexorderdir: ScanDirection,
}
#[test]
fn bindgen_test_layout_IndexScan() {
    assert_eq!(::std::mem::size_of::<IndexScan>() , 168usize , concat ! (
               "Size of: " , stringify ! ( IndexScan ) ));
    assert_eq! (::std::mem::align_of::<IndexScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexid as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexqual as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexqual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexqualorig as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexqualorig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexorderby as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexorderby ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexorderbyorig as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexorderbyorig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexorderbyops as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexorderbyops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScan ) ) . indexorderdir as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScan ) , "::" ,
                stringify ! ( indexorderdir ) ));
}
impl Clone for IndexScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection,
}
#[test]
fn bindgen_test_layout_IndexOnlyScan() {
    assert_eq!(::std::mem::size_of::<IndexOnlyScan>() , 152usize , concat ! (
               "Size of: " , stringify ! ( IndexOnlyScan ) ));
    assert_eq! (::std::mem::align_of::<IndexOnlyScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexOnlyScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScan ) , "::"
                , stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScan ) ) . indexid as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScan ) , "::"
                , stringify ! ( indexid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScan ) ) . indexqual as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScan ) , "::"
                , stringify ! ( indexqual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScan ) ) . indexorderby as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScan ) , "::"
                , stringify ! ( indexorderby ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScan ) ) . indextlist as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScan ) , "::"
                , stringify ! ( indextlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScan ) ) . indexorderdir as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScan ) , "::"
                , stringify ! ( indexorderdir ) ));
}
impl Clone for IndexOnlyScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub isshared: bool_,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapIndexScan() {
    assert_eq!(::std::mem::size_of::<BitmapIndexScan>() , 136usize , concat !
               ( "Size of: " , stringify ! ( BitmapIndexScan ) ));
    assert_eq! (::std::mem::align_of::<BitmapIndexScan>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( BitmapIndexScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScan ) ) . scan as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScan ) ,
                "::" , stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScan ) ) . indexid as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScan ) ,
                "::" , stringify ! ( indexid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScan ) ) . isshared as * const
                _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScan ) ,
                "::" , stringify ! ( isshared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScan ) ) . indexqual as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScan ) ,
                "::" , stringify ! ( indexqual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScan ) ) . indexqualorig as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScan ) ,
                "::" , stringify ! ( indexqualorig ) ));
}
impl Clone for BitmapIndexScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapHeapScan() {
    assert_eq!(::std::mem::size_of::<BitmapHeapScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( BitmapHeapScan ) ));
    assert_eq! (::std::mem::align_of::<BitmapHeapScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapHeapScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScan ) , "::"
                , stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScan ) ) . bitmapqualorig as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScan ) , "::"
                , stringify ! ( bitmapqualorig ) ));
}
impl Clone for BitmapHeapScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
#[test]
fn bindgen_test_layout_TidScan() {
    assert_eq!(::std::mem::size_of::<TidScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( TidScan ) ));
    assert_eq! (::std::mem::align_of::<TidScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TidScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScan ) ) . scan as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScan ) ) . tidquals as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScan ) , "::" ,
                stringify ! ( tidquals ) ));
}
impl Clone for TidScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
}
#[test]
fn bindgen_test_layout_SubqueryScan() {
    assert_eq!(::std::mem::size_of::<SubqueryScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( SubqueryScan ) ));
    assert_eq! (::std::mem::align_of::<SubqueryScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SubqueryScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubqueryScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SubqueryScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubqueryScan ) ) . subplan as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( SubqueryScan ) , "::" ,
                stringify ! ( subplan ) ));
}
impl Clone for SubqueryScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: *mut List,
    pub funcordinality: bool_,
}
#[test]
fn bindgen_test_layout_FunctionScan() {
    assert_eq!(::std::mem::size_of::<FunctionScan>() , 128usize , concat ! (
               "Size of: " , stringify ! ( FunctionScan ) ));
    assert_eq! (::std::mem::align_of::<FunctionScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FunctionScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScan ) ) . functions as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScan ) , "::" ,
                stringify ! ( functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScan ) ) . funcordinality as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScan ) , "::" ,
                stringify ! ( funcordinality ) ));
}
impl Clone for FunctionScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
#[test]
fn bindgen_test_layout_ValuesScan() {
    assert_eq!(::std::mem::size_of::<ValuesScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( ValuesScan ) ));
    assert_eq! (::std::mem::align_of::<ValuesScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ValuesScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScan ) ) . values_lists as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScan ) , "::" ,
                stringify ! ( values_lists ) ));
}
impl Clone for ValuesScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TableFuncScan {
    pub scan: Scan,
    pub tablefunc: *mut TableFunc,
}
#[test]
fn bindgen_test_layout_TableFuncScan() {
    assert_eq!(::std::mem::size_of::<TableFuncScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( TableFuncScan ) ));
    assert_eq! (::std::mem::align_of::<TableFuncScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TableFuncScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScan ) , "::"
                , stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScan ) ) . tablefunc as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScan ) , "::"
                , stringify ! ( tablefunc ) ));
}
impl Clone for TableFuncScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CteScan() {
    assert_eq!(::std::mem::size_of::<CteScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( CteScan ) ));
    assert_eq! (::std::mem::align_of::<CteScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CteScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScan ) ) . scan as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScan ) ) . ctePlanId as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScan ) , "::" ,
                stringify ! ( ctePlanId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScan ) ) . cteParam as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScan ) , "::" ,
                stringify ! ( cteParam ) ));
}
impl Clone for CteScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NamedTuplestoreScan {
    pub scan: Scan,
    pub enrname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NamedTuplestoreScan() {
    assert_eq!(::std::mem::size_of::<NamedTuplestoreScan>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( NamedTuplestoreScan )
               ));
    assert_eq! (::std::mem::align_of::<NamedTuplestoreScan>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( NamedTuplestoreScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedTuplestoreScan ) ) . scan as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedTuplestoreScan ) ,
                "::" , stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedTuplestoreScan ) ) . enrname as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( NamedTuplestoreScan ) ,
                "::" , stringify ! ( enrname ) ));
}
impl Clone for NamedTuplestoreScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WorkTableScan() {
    assert_eq!(::std::mem::size_of::<WorkTableScan>() , 120usize , concat ! (
               "Size of: " , stringify ! ( WorkTableScan ) ));
    assert_eq! (::std::mem::align_of::<WorkTableScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WorkTableScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WorkTableScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WorkTableScan ) , "::"
                , stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WorkTableScan ) ) . wtParam as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( WorkTableScan ) , "::"
                , stringify ! ( wtParam ) ));
}
impl Clone for WorkTableScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType,
    pub fs_server: Oid,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fdw_scan_tlist: *mut List,
    pub fdw_recheck_quals: *mut List,
    pub fs_relids: *mut Bitmapset,
    pub fsSystemCol: bool_,
}
#[test]
fn bindgen_test_layout_ForeignScan() {
    assert_eq!(::std::mem::size_of::<ForeignScan>() , 168usize , concat ! (
               "Size of: " , stringify ! ( ForeignScan ) ));
    assert_eq! (::std::mem::align_of::<ForeignScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . operation as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fs_server as * const _
                as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fs_server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fdw_exprs as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fdw_exprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fdw_private as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fdw_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fdw_scan_tlist as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fdw_scan_tlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fdw_recheck_quals as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fdw_recheck_quals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fs_relids as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fs_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScan ) ) . fsSystemCol as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScan ) , "::" ,
                stringify ! ( fsSystemCol ) ));
}
impl Clone for ForeignScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: *mut List,
    pub custom_exprs: *mut List,
    pub custom_private: *mut List,
    pub custom_scan_tlist: *mut List,
    pub custom_relids: *mut Bitmapset,
    pub methods: *const CustomScanMethods,
}
#[test]
fn bindgen_test_layout_CustomScan() {
    assert_eq!(::std::mem::size_of::<CustomScan>() , 168usize , concat ! (
               "Size of: " , stringify ! ( CustomScan ) ));
    assert_eq! (::std::mem::align_of::<CustomScan>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CustomScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . scan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . flags as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . custom_plans as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( custom_plans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . custom_exprs as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( custom_exprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . custom_private as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( custom_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . custom_scan_tlist as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( custom_scan_tlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . custom_relids as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( custom_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScan ) ) . methods as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScan ) , "::" ,
                stringify ! ( methods ) ));
}
impl Clone for CustomScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub inner_unique: bool_,
    pub joinqual: *mut List,
}
#[test]
fn bindgen_test_layout_Join() {
    assert_eq!(::std::mem::size_of::<Join>() , 120usize , concat ! (
               "Size of: " , stringify ! ( Join ) ));
    assert_eq! (::std::mem::align_of::<Join>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Join ) ) . plan as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Join ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Join ) ) . jointype as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Join ) , "::" ,
                stringify ! ( jointype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Join ) ) . inner_unique as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( Join ) , "::" ,
                stringify ! ( inner_unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Join ) ) . joinqual as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Join ) , "::" ,
                stringify ! ( joinqual ) ));
}
impl Clone for Join {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
#[test]
fn bindgen_test_layout_NestLoop() {
    assert_eq!(::std::mem::size_of::<NestLoop>() , 128usize , concat ! (
               "Size of: " , stringify ! ( NestLoop ) ));
    assert_eq! (::std::mem::align_of::<NestLoop>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NestLoop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoop ) ) . join as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoop ) , "::" ,
                stringify ! ( join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoop ) ) . nestParams as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoop ) , "::" ,
                stringify ! ( nestParams ) ));
}
impl Clone for NestLoop {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: *mut Var,
}
#[test]
fn bindgen_test_layout_NestLoopParam() {
    assert_eq!(::std::mem::size_of::<NestLoopParam>() , 16usize , concat ! (
               "Size of: " , stringify ! ( NestLoopParam ) ));
    assert_eq! (::std::mem::align_of::<NestLoopParam>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NestLoopParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopParam ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopParam ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopParam ) ) . paramno as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopParam ) , "::"
                , stringify ! ( paramno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopParam ) ) . paramval as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopParam ) , "::"
                , stringify ! ( paramval ) ));
}
impl Clone for NestLoopParam {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MergeJoin {
    pub join: Join,
    pub skip_mark_restore: bool_,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::std::os::raw::c_int,
    pub mergeNullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_MergeJoin() {
    assert_eq!(::std::mem::size_of::<MergeJoin>() , 168usize , concat ! (
               "Size of: " , stringify ! ( MergeJoin ) ));
    assert_eq! (::std::mem::align_of::<MergeJoin>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MergeJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . join as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . skip_mark_restore as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( skip_mark_restore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . mergeclauses as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( mergeclauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . mergeFamilies as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( mergeFamilies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . mergeCollations as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( mergeCollations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . mergeStrategies as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( mergeStrategies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoin ) ) . mergeNullsFirst as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoin ) , "::" ,
                stringify ! ( mergeNullsFirst ) ));
}
impl Clone for MergeJoin {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
}
#[test]
fn bindgen_test_layout_HashJoin() {
    assert_eq!(::std::mem::size_of::<HashJoin>() , 128usize , concat ! (
               "Size of: " , stringify ! ( HashJoin ) ));
    assert_eq! (::std::mem::align_of::<HashJoin>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HashJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoin ) ) . join as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoin ) , "::" ,
                stringify ! ( join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoin ) ) . hashclauses as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoin ) , "::" ,
                stringify ! ( hashclauses ) ));
}
impl Clone for HashJoin {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Material {
    pub plan: Plan,
}
#[test]
fn bindgen_test_layout_Material() {
    assert_eq!(::std::mem::size_of::<Material>() , 104usize , concat ! (
               "Size of: " , stringify ! ( Material ) ));
    assert_eq! (::std::mem::align_of::<Material>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Material ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . plan as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( plan ) ));
}
impl Clone for Material {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_Sort() {
    assert_eq!(::std::mem::size_of::<Sort>() , 144usize , concat ! (
               "Size of: " , stringify ! ( Sort ) ));
    assert_eq! (::std::mem::align_of::<Sort>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Sort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sort ) ) . plan as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Sort ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sort ) ) . numCols as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Sort ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sort ) ) . sortColIdx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Sort ) , "::" ,
                stringify ! ( sortColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sort ) ) . sortOperators as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Sort ) , "::" ,
                stringify ! ( sortOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sort ) ) . collations as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( Sort ) , "::" ,
                stringify ! ( collations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sort ) ) . nullsFirst as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( Sort ) , "::" ,
                stringify ! ( nullsFirst ) ));
}
impl Clone for Sort {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
}
#[test]
fn bindgen_test_layout_Group() {
    assert_eq!(::std::mem::size_of::<Group>() , 128usize , concat ! (
               "Size of: " , stringify ! ( Group ) ));
    assert_eq! (::std::mem::align_of::<Group>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Group ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Group ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Group ) ) . numCols as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Group ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Group ) ) . grpColIdx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Group ) , "::" ,
                stringify ! ( grpColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Group ) ) . grpOperators as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Group ) , "::" ,
                stringify ! ( grpOperators ) ));
}
impl Clone for Group {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
    pub aggParams: *mut Bitmapset,
    pub groupingSets: *mut List,
    pub chain: *mut List,
}
#[test]
fn bindgen_test_layout_Agg() {
    assert_eq!(::std::mem::size_of::<Agg>() , 168usize , concat ! (
               "Size of: " , stringify ! ( Agg ) ));
    assert_eq! (::std::mem::align_of::<Agg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Agg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . plan as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . aggstrategy as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( aggstrategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . aggsplit as * const _ as usize
                } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( aggsplit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . numCols as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . grpColIdx as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( grpColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . grpOperators as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( grpOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . numGroups as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( numGroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . aggParams as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( aggParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . groupingSets as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( groupingSets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Agg ) ) . chain as * const _ as usize } ,
                160usize , concat ! (
                "Alignment of field: " , stringify ! ( Agg ) , "::" ,
                stringify ! ( chain ) ));
}
impl Clone for Agg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
}
#[test]
fn bindgen_test_layout_WindowAgg() {
    assert_eq!(::std::mem::size_of::<WindowAgg>() , 176usize , concat ! (
               "Size of: " , stringify ! ( WindowAgg ) ));
    assert_eq! (::std::mem::align_of::<WindowAgg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WindowAgg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . winref as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( winref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . partNumCols as * const _
                as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( partNumCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . partColIdx as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( partColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . partOperators as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( partOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . ordNumCols as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( ordNumCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . ordColIdx as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( ordColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . ordOperators as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( ordOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . frameOptions as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( frameOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . startOffset as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( startOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAgg ) ) . endOffset as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAgg ) , "::" ,
                stringify ! ( endOffset ) ));
}
impl Clone for WindowAgg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
}
#[test]
fn bindgen_test_layout_Unique() {
    assert_eq!(::std::mem::size_of::<Unique>() , 128usize , concat ! (
               "Size of: " , stringify ! ( Unique ) ));
    assert_eq! (::std::mem::align_of::<Unique>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Unique ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Unique ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Unique ) ) . numCols as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Unique ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Unique ) ) . uniqColIdx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Unique ) , "::" ,
                stringify ! ( uniqColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Unique ) ) . uniqOperators as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Unique ) , "::" ,
                stringify ! ( uniqOperators ) ));
}
impl Clone for Unique {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub single_copy: bool_,
    pub invisible: bool_,
}
#[test]
fn bindgen_test_layout_Gather() {
    assert_eq!(::std::mem::size_of::<Gather>() , 120usize , concat ! (
               "Size of: " , stringify ! ( Gather ) ));
    assert_eq! (::std::mem::align_of::<Gather>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Gather ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Gather ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Gather ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Gather ) ) . num_workers as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Gather ) , "::" ,
                stringify ! ( num_workers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Gather ) ) . rescan_param as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( Gather ) , "::" ,
                stringify ! ( rescan_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Gather ) ) . single_copy as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Gather ) , "::" ,
                stringify ! ( single_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Gather ) ) . invisible as * const _ as
                usize } , 113usize , concat ! (
                "Alignment of field: " , stringify ! ( Gather ) , "::" ,
                stringify ! ( invisible ) ));
}
impl Clone for Gather {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GatherMerge {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_GatherMerge() {
    assert_eq!(::std::mem::size_of::<GatherMerge>() , 152usize , concat ! (
               "Size of: " , stringify ! ( GatherMerge ) ));
    assert_eq! (::std::mem::align_of::<GatherMerge>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GatherMerge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . plan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . num_workers as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( num_workers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . rescan_param as * const
                _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( rescan_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . numCols as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . sortColIdx as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( sortColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . sortOperators as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( sortOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . collations as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( collations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMerge ) ) . nullsFirst as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMerge ) , "::" ,
                stringify ! ( nullsFirst ) ));
}
impl Clone for GatherMerge {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Hash {
    pub plan: Plan,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool_,
}
#[test]
fn bindgen_test_layout_Hash() {
    assert_eq!(::std::mem::size_of::<Hash>() , 112usize , concat ! (
               "Size of: " , stringify ! ( Hash ) ));
    assert_eq! (::std::mem::align_of::<Hash>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash ) ) . plan as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash ) ) . skewTable as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash ) , "::" ,
                stringify ! ( skewTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash ) ) . skewColumn as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash ) , "::" ,
                stringify ! ( skewColumn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash ) ) . skewInherit as * const _ as
                usize } , 110usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash ) , "::" ,
                stringify ! ( skewInherit ) ));
}
impl Clone for Hash {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_SetOp() {
    assert_eq!(::std::mem::size_of::<SetOp>() , 152usize , concat ! (
               "Size of: " , stringify ! ( SetOp ) ));
    assert_eq! (::std::mem::align_of::<SetOp>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SetOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . cmd as * const _ as usize } ,
                104usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . strategy as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . numCols as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . dupColIdx as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( dupColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . dupOperators as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( dupOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . flagColIdx as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( flagColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . firstFlag as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( firstFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOp ) ) . numGroups as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOp ) , "::" ,
                stringify ! ( numGroups ) ));
}
impl Clone for SetOp {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRows() {
    assert_eq!(::std::mem::size_of::<LockRows>() , 120usize , concat ! (
               "Size of: " , stringify ! ( LockRows ) ));
    assert_eq! (::std::mem::align_of::<LockRows>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockRows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRows ) ) . plan as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRows ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRows ) ) . rowMarks as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRows ) , "::" ,
                stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRows ) ) . epqParam as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRows ) , "::" ,
                stringify ! ( epqParam ) ));
}
impl Clone for LockRows {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
}
#[test]
fn bindgen_test_layout_Limit() {
    assert_eq!(::std::mem::size_of::<Limit>() , 120usize , concat ! (
               "Size of: " , stringify ! ( Limit ) ));
    assert_eq! (::std::mem::align_of::<Limit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Limit ) ) . plan as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Limit ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Limit ) ) . limitOffset as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Limit ) , "::" ,
                stringify ! ( limitOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Limit ) ) . limitCount as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Limit ) , "::" ,
                stringify ! ( limitCount ) ));
}
impl Clone for Limit {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RowMarkType {
    ROW_MARK_EXCLUSIVE = 0,
    ROW_MARK_NOKEYEXCLUSIVE = 1,
    ROW_MARK_SHARE = 2,
    ROW_MARK_KEYSHARE = 3,
    ROW_MARK_REFERENCE = 4,
    ROW_MARK_COPY = 5,
}
#[repr(C)]
#[derive(Copy)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub allMarkTypes: ::std::os::raw::c_int,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub isParent: bool_,
}
#[test]
fn bindgen_test_layout_PlanRowMark() {
    assert_eq!(::std::mem::size_of::<PlanRowMark>() , 36usize , concat ! (
               "Size of: " , stringify ! ( PlanRowMark ) ));
    assert_eq! (::std::mem::align_of::<PlanRowMark>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( PlanRowMark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . rti as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( rti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . prti as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( prti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . rowmarkId as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( rowmarkId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . markType as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( markType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . allMarkTypes as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( allMarkTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . strength as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . waitPolicy as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( waitPolicy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanRowMark ) ) . isParent as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanRowMark ) , "::" ,
                stringify ! ( isParent ) ));
}
impl Clone for PlanRowMark {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
#[test]
fn bindgen_test_layout_PlanInvalItem() {
    assert_eq!(::std::mem::size_of::<PlanInvalItem>() , 12usize , concat ! (
               "Size of: " , stringify ! ( PlanInvalItem ) ));
    assert_eq! (::std::mem::align_of::<PlanInvalItem>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( PlanInvalItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanInvalItem ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanInvalItem ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanInvalItem ) ) . cacheId as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanInvalItem ) , "::"
                , stringify ! ( cacheId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanInvalItem ) ) . hashValue as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanInvalItem ) , "::"
                , stringify ! ( hashValue ) ));
}
impl Clone for PlanInvalItem {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EphemeralNameRelationType { ENR_NAMED_TUPLESTORE = 0, }
#[repr(C)]
#[derive(Copy)]
pub struct EphemeralNamedRelationMetadataData {
    pub name: *mut ::std::os::raw::c_char,
    pub reliddesc: Oid,
    pub tupdesc: TupleDesc,
    pub enrtype: EphemeralNameRelationType,
    pub enrtuples: f64,
}
#[test]
fn bindgen_test_layout_EphemeralNamedRelationMetadataData() {
    assert_eq!(::std::mem::size_of::<EphemeralNamedRelationMetadataData>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( EphemeralNamedRelationMetadataData
               ) ));
    assert_eq! (::std::mem::align_of::<EphemeralNamedRelationMetadataData>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                EphemeralNamedRelationMetadataData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationMetadataData ) ) .
                name as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationMetadataData ) , "::" , stringify ! (
                name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationMetadataData ) ) .
                reliddesc as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationMetadataData ) , "::" , stringify ! (
                reliddesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationMetadataData ) ) .
                tupdesc as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationMetadataData ) , "::" , stringify ! (
                tupdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationMetadataData ) ) .
                enrtype as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationMetadataData ) , "::" , stringify ! (
                enrtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationMetadataData ) ) .
                enrtuples as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationMetadataData ) , "::" , stringify ! (
                enrtuples ) ));
}
impl Clone for EphemeralNamedRelationMetadataData {
    fn clone(&self) -> Self { *self }
}
pub type EphemeralNamedRelationMetadata =
    *mut EphemeralNamedRelationMetadataData;
#[repr(C)]
#[derive(Copy)]
pub struct EphemeralNamedRelationData {
    pub md: EphemeralNamedRelationMetadataData,
    pub reldata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_EphemeralNamedRelationData() {
    assert_eq!(::std::mem::size_of::<EphemeralNamedRelationData>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( EphemeralNamedRelationData ) ));
    assert_eq! (::std::mem::align_of::<EphemeralNamedRelationData>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EphemeralNamedRelationData )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationData ) ) . md as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationData ) , "::" , stringify ! ( md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EphemeralNamedRelationData ) ) . reldata
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                EphemeralNamedRelationData ) , "::" , stringify ! ( reldata )
                ));
}
impl Clone for EphemeralNamedRelationData {
    fn clone(&self) -> Self { *self }
}
pub type EphemeralNamedRelation = *mut EphemeralNamedRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryEnvironment {
    _unused: [u8; 0],
}
extern "C" {
    pub fn create_queryEnv() -> *mut QueryEnvironment;
}
extern "C" {
    pub fn get_visible_ENR_metadata(queryEnv: *mut QueryEnvironment,
                                    refname: *const ::std::os::raw::c_char)
     -> EphemeralNamedRelationMetadata;
}
extern "C" {
    pub fn register_ENR(queryEnv: *mut QueryEnvironment,
                        enr: EphemeralNamedRelation);
}
extern "C" {
    pub fn unregister_ENR(queryEnv: *mut QueryEnvironment,
                          name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_ENR(queryEnv: *mut QueryEnvironment,
                   name: *const ::std::os::raw::c_char)
     -> EphemeralNamedRelation;
}
extern "C" {
    pub fn ENRMetadataGetTupDesc(enrmd: EphemeralNamedRelationMetadata)
     -> TupleDesc;
}
#[repr(C)]
#[derive(Copy)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool_,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool_,
    pub tginitdeferred: bool_,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
    pub tgoldtable: *mut ::std::os::raw::c_char,
    pub tgnewtable: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Trigger() {
    assert_eq!(::std::mem::size_of::<Trigger>() , 88usize , concat ! (
               "Size of: " , stringify ! ( Trigger ) ));
    assert_eq! (::std::mem::align_of::<Trigger>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Trigger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgoid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgfoid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgfoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgtype as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgenabled as * const _ as
                usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgenabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgisinternal as * const _
                as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgisinternal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgconstrrelid as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgconstrrelid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgconstrindid as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgconstrindid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgconstraint as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgconstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgdeferrable as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgdeferrable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tginitdeferred as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tginitdeferred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgnargs as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgnargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgnattr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgnattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgattr as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgargs as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgqual as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgqual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgoldtable as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgoldtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Trigger ) ) . tgnewtable as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( Trigger ) , "::" ,
                stringify ! ( tgnewtable ) ));
}
impl Clone for Trigger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool_,
    pub trig_insert_after_row: bool_,
    pub trig_insert_instead_row: bool_,
    pub trig_insert_before_statement: bool_,
    pub trig_insert_after_statement: bool_,
    pub trig_update_before_row: bool_,
    pub trig_update_after_row: bool_,
    pub trig_update_instead_row: bool_,
    pub trig_update_before_statement: bool_,
    pub trig_update_after_statement: bool_,
    pub trig_delete_before_row: bool_,
    pub trig_delete_after_row: bool_,
    pub trig_delete_instead_row: bool_,
    pub trig_delete_before_statement: bool_,
    pub trig_delete_after_statement: bool_,
    pub trig_truncate_before_statement: bool_,
    pub trig_truncate_after_statement: bool_,
    pub trig_insert_new_table: bool_,
    pub trig_update_old_table: bool_,
    pub trig_update_new_table: bool_,
    pub trig_delete_old_table: bool_,
}
#[test]
fn bindgen_test_layout_TriggerDesc() {
    assert_eq!(::std::mem::size_of::<TriggerDesc>() , 40usize , concat ! (
               "Size of: " , stringify ! ( TriggerDesc ) ));
    assert_eq! (::std::mem::align_of::<TriggerDesc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TriggerDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . triggers as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( triggers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . numtriggers as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( numtriggers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_insert_before_row
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_insert_before_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_insert_after_row
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_insert_after_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_insert_instead_row
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_insert_instead_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_insert_before_statement as * const _ as usize } , 15usize
                , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_insert_before_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_insert_after_statement as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_insert_after_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_update_before_row
                as * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_before_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_update_after_row
                as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_after_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_update_instead_row
                as * const _ as usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_instead_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_update_before_statement as * const _ as usize } , 20usize
                , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_before_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_update_after_statement as * const _ as usize } , 21usize
                , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_after_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_delete_before_row
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_delete_before_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_delete_after_row
                as * const _ as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_delete_after_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_delete_instead_row
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_delete_instead_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_delete_before_statement as * const _ as usize } , 25usize
                , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_delete_before_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_delete_after_statement as * const _ as usize } , 26usize
                , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_delete_after_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_truncate_before_statement as * const _ as usize } ,
                27usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_truncate_before_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) .
                trig_truncate_after_statement as * const _ as usize } ,
                28usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_truncate_after_statement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_insert_new_table
                as * const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_insert_new_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_update_old_table
                as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_old_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_update_new_table
                as * const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_update_new_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerDesc ) ) . trig_delete_old_table
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerDesc ) , "::" ,
                stringify ! ( trig_delete_old_table ) ));
}
impl Clone for TriggerDesc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool_,
    pub ssup_nulls_first: bool_,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::std::os::raw::c_void,
    pub comparator: ::std::option::Option<unsafe extern "C" fn(x: Datum,
                                                               y: Datum,
                                                               ssup:
                                                                   SortSupport)
                                              -> ::std::os::raw::c_int>,
    pub abbreviate: bool_,
    pub abbrev_converter: ::std::option::Option<unsafe extern "C" fn(original:
                                                                         Datum,
                                                                     ssup:
                                                                         SortSupport)
                                                    -> Datum>,
    pub abbrev_abort: ::std::option::Option<unsafe extern "C" fn(memtupcount:
                                                                     ::std::os::raw::c_int,
                                                                 ssup:
                                                                     SortSupport)
                                                -> bool_>,
    pub abbrev_full_comparator: ::std::option::Option<unsafe extern "C" fn(x:
                                                                               Datum,
                                                                           y:
                                                                               Datum,
                                                                           ssup:
                                                                               SortSupport)
                                                          ->
                                                              ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_SortSupportData() {
    assert_eq!(::std::mem::size_of::<SortSupportData>() , 64usize , concat ! (
               "Size of: " , stringify ! ( SortSupportData ) ));
    assert_eq! (::std::mem::align_of::<SortSupportData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SortSupportData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . ssup_cxt as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( ssup_cxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . ssup_collation as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( ssup_collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . ssup_reverse as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( ssup_reverse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . ssup_nulls_first as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( ssup_nulls_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . ssup_attno as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( ssup_attno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . ssup_extra as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( ssup_extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . comparator as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( comparator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . abbreviate as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( abbreviate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . abbrev_converter as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( abbrev_converter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) . abbrev_abort as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( abbrev_abort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortSupportData ) ) .
                abbrev_full_comparator as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( SortSupportData ) ,
                "::" , stringify ! ( abbrev_full_comparator ) ));
}
impl Clone for SortSupportData {
    fn clone(&self) -> Self { *self }
}
pub type SortSupport = *mut SortSupportData;
extern "C" {
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: SortSupport);
}
extern "C" {
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid,
                                            ssup: SortSupport);
}
extern "C" {
    pub fn PrepareSortSupportFromIndexRel(indexRel: Relation, strategy: int16,
                                          ssup: SortSupport);
}
#[repr(C)]
#[derive(Copy)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_isempty: bool_,
    pub tts_shouldFree: bool_,
    pub tts_shouldFreeMin: bool_,
    pub tts_slow: bool_,
    pub tts_tuple: HeapTuple,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_mcxt: MemoryContext,
    pub tts_buffer: Buffer,
    pub tts_nvalid: ::std::os::raw::c_int,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool_,
    pub tts_mintuple: MinimalTuple,
    pub tts_minhdr: HeapTupleData,
    pub tts_off: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_TupleTableSlot() {
    assert_eq!(::std::mem::size_of::<TupleTableSlot>() , 96usize , concat ! (
               "Size of: " , stringify ! ( TupleTableSlot ) ));
    assert_eq! (::std::mem::align_of::<TupleTableSlot>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TupleTableSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_isempty as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_isempty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_shouldFree as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_shouldFree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_shouldFreeMin as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_shouldFreeMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_slow as * const
                _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_slow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_tuple as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_tuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_tupleDescriptor
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_tupleDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_mcxt as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_mcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_buffer as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_nvalid as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_nvalid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_values as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_isnull as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_isnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_mintuple as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_mintuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_minhdr as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_minhdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleTableSlot ) ) . tts_off as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleTableSlot ) , "::"
                , stringify ! ( tts_off ) ));
}
impl Clone for TupleTableSlot {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn MakeTupleTableSlot() -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecAllocTableSlot(tupleTable: *mut *mut List)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecResetTupleTable(tupleTable: *mut List, shouldFree: bool_);
}
extern "C" {
    pub fn MakeSingleTupleTableSlot(tupdesc: TupleDesc)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecDropSingleTupleTableSlot(slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn ExecSetSlotDescriptor(slot: *mut TupleTableSlot,
                                 tupdesc: TupleDesc);
}
extern "C" {
    pub fn ExecStoreTuple(tuple: HeapTuple, slot: *mut TupleTableSlot,
                          buffer: Buffer, shouldFree: bool_)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecStoreMinimalTuple(mtup: MinimalTuple,
                                 slot: *mut TupleTableSlot, shouldFree: bool_)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecClearTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecStoreVirtualTuple(slot: *mut TupleTableSlot)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecStoreAllNullTuple(slot: *mut TupleTableSlot)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecCopySlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    pub fn ExecCopySlotMinimalTuple(slot: *mut TupleTableSlot)
     -> MinimalTuple;
}
extern "C" {
    pub fn ExecFetchSlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    pub fn ExecFetchSlotMinimalTuple(slot: *mut TupleTableSlot)
     -> MinimalTuple;
}
extern "C" {
    pub fn ExecFetchSlotTupleDatum(slot: *mut TupleTableSlot) -> Datum;
}
extern "C" {
    pub fn ExecMaterializeSlot(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    pub fn ExecCopySlot(dstslot: *mut TupleTableSlot,
                        srcslot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn slot_getattr(slot: *mut TupleTableSlot,
                        attnum: ::std::os::raw::c_int, isnull: *mut bool_)
     -> Datum;
}
extern "C" {
    pub fn slot_getallattrs(slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn slot_getsomeattrs(slot: *mut TupleTableSlot,
                             attnum: ::std::os::raw::c_int);
}
extern "C" {
    pub fn slot_attisnull(slot: *mut TupleTableSlot,
                          attnum: ::std::os::raw::c_int) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplestorestate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn tuplestore_begin_heap(randomAccess: bool_, interXact: bool_,
                                 maxKBytes: ::std::os::raw::c_int)
     -> *mut Tuplestorestate;
}
extern "C" {
    pub fn tuplestore_set_eflags(state: *mut Tuplestorestate,
                                 eflags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tuplestore_puttupleslot(state: *mut Tuplestorestate,
                                   slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn tuplestore_puttuple(state: *mut Tuplestorestate, tuple: HeapTuple);
}
extern "C" {
    pub fn tuplestore_putvalues(state: *mut Tuplestorestate, tdesc: TupleDesc,
                                values: *mut Datum, isnull: *mut bool_);
}
extern "C" {
    pub fn tuplestore_alloc_read_pointer(state: *mut Tuplestorestate,
                                         eflags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tuplestore_select_read_pointer(state: *mut Tuplestorestate,
                                          ptr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tuplestore_copy_read_pointer(state: *mut Tuplestorestate,
                                        srcptr: ::std::os::raw::c_int,
                                        destptr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tuplestore_trim(state: *mut Tuplestorestate);
}
extern "C" {
    pub fn tuplestore_in_memory(state: *mut Tuplestorestate) -> bool_;
}
extern "C" {
    pub fn tuplestore_gettupleslot(state: *mut Tuplestorestate,
                                   forward: bool_, copy: bool_,
                                   slot: *mut TupleTableSlot) -> bool_;
}
extern "C" {
    pub fn tuplestore_advance(state: *mut Tuplestorestate, forward: bool_)
     -> bool_;
}
extern "C" {
    pub fn tuplestore_skiptuples(state: *mut Tuplestorestate, ntuples: int64,
                                 forward: bool_) -> bool_;
}
extern "C" {
    pub fn tuplestore_tuple_count(state: *mut Tuplestorestate) -> int64;
}
extern "C" {
    pub fn tuplestore_ateof(state: *mut Tuplestorestate) -> bool_;
}
extern "C" {
    pub fn tuplestore_rescan(state: *mut Tuplestorestate);
}
extern "C" {
    pub fn tuplestore_clear(state: *mut Tuplestorestate);
}
extern "C" {
    pub fn tuplestore_end(state: *mut Tuplestorestate);
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_IndexTupleData() {
    assert_eq!(::std::mem::size_of::<IndexTupleData>() , 8usize , concat ! (
               "Size of: " , stringify ! ( IndexTupleData ) ));
    assert_eq! (::std::mem::align_of::<IndexTupleData>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( IndexTupleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexTupleData ) ) . t_tid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexTupleData ) , "::"
                , stringify ! ( t_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexTupleData ) ) . t_info as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexTupleData ) , "::"
                , stringify ! ( t_info ) ));
}
impl Clone for IndexTupleData {
    fn clone(&self) -> Self { *self }
}
pub type IndexTuple = *mut IndexTupleData;
#[repr(C)]
#[derive(Copy)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
#[test]
fn bindgen_test_layout_IndexAttributeBitMapData() {
    assert_eq!(::std::mem::size_of::<IndexAttributeBitMapData>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( IndexAttributeBitMapData ) ));
    assert_eq! (::std::mem::align_of::<IndexAttributeBitMapData>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( IndexAttributeBitMapData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexAttributeBitMapData ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                IndexAttributeBitMapData ) , "::" , stringify ! ( bits ) ));
}
impl Clone for IndexAttributeBitMapData {
    fn clone(&self) -> Self { *self }
}
pub type IndexAttributeBitMap = *mut IndexAttributeBitMapData;
extern "C" {
    pub fn index_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                            isnull: *mut bool_) -> IndexTuple;
}
extern "C" {
    pub fn nocache_index_getattr(tup: IndexTuple,
                                 attnum: ::std::os::raw::c_int,
                                 tupleDesc: TupleDesc) -> Datum;
}
extern "C" {
    pub fn index_deform_tuple(tup: IndexTuple, tupleDescriptor: TupleDesc,
                              values: *mut Datum, isnull: *mut bool_);
}
extern "C" {
    pub fn CopyIndexTuple(source: IndexTuple) -> IndexTuple;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplesortstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn tuplesort_begin_heap(tupDesc: TupleDesc,
                                nkeys: ::std::os::raw::c_int,
                                attNums: *mut AttrNumber,
                                sortOperators: *mut Oid,
                                sortCollations: *mut Oid,
                                nullsFirstFlags: *mut bool_,
                                workMem: ::std::os::raw::c_int,
                                randomAccess: bool_) -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_cluster(tupDesc: TupleDesc, indexRel: Relation,
                                   workMem: ::std::os::raw::c_int,
                                   randomAccess: bool_)
     -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_index_btree(heapRel: Relation, indexRel: Relation,
                                       enforceUnique: bool_,
                                       workMem: ::std::os::raw::c_int,
                                       randomAccess: bool_)
     -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_index_hash(heapRel: Relation, indexRel: Relation,
                                      high_mask: uint32, low_mask: uint32,
                                      max_buckets: uint32,
                                      workMem: ::std::os::raw::c_int,
                                      randomAccess: bool_)
     -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_datum(datumType: Oid, sortOperator: Oid,
                                 sortCollation: Oid, nullsFirstFlag: bool_,
                                 workMem: ::std::os::raw::c_int,
                                 randomAccess: bool_) -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_set_bound(state: *mut Tuplesortstate, bound: int64);
}
extern "C" {
    pub fn tuplesort_puttupleslot(state: *mut Tuplesortstate,
                                  slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn tuplesort_putheaptuple(state: *mut Tuplesortstate, tup: HeapTuple);
}
extern "C" {
    pub fn tuplesort_putindextuplevalues(state: *mut Tuplesortstate,
                                         rel: Relation, self_: ItemPointer,
                                         values: *mut Datum,
                                         isnull: *mut bool_);
}
extern "C" {
    pub fn tuplesort_putdatum(state: *mut Tuplesortstate, val: Datum,
                              isNull: bool_);
}
extern "C" {
    pub fn tuplesort_performsort(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_gettupleslot(state: *mut Tuplesortstate, forward: bool_,
                                  copy: bool_, slot: *mut TupleTableSlot,
                                  abbrev: *mut Datum) -> bool_;
}
extern "C" {
    pub fn tuplesort_getheaptuple(state: *mut Tuplesortstate, forward: bool_)
     -> HeapTuple;
}
extern "C" {
    pub fn tuplesort_getindextuple(state: *mut Tuplesortstate, forward: bool_)
     -> IndexTuple;
}
extern "C" {
    pub fn tuplesort_getdatum(state: *mut Tuplesortstate, forward: bool_,
                              val: *mut Datum, isNull: *mut bool_,
                              abbrev: *mut Datum) -> bool_;
}
extern "C" {
    pub fn tuplesort_skiptuples(state: *mut Tuplesortstate, ntuples: int64,
                                forward: bool_) -> bool_;
}
extern "C" {
    pub fn tuplesort_end(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_get_stats(state: *mut Tuplesortstate,
                               sortMethod: *mut *const ::std::os::raw::c_char,
                               spaceType: *mut *const ::std::os::raw::c_char,
                               spaceUsed: *mut ::std::os::raw::c_long);
}
extern "C" {
    pub fn tuplesort_merge_order(allowedMem: int64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tuplesort_rescan(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_markpos(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_restorepos(state: *mut Tuplesortstate);
}
#[repr(C)]
#[derive(Copy)]
pub struct ConditionVariable {
    pub mutex: slock_t,
    pub wakeup: proclist_head,
}
#[test]
fn bindgen_test_layout_ConditionVariable() {
    assert_eq!(::std::mem::size_of::<ConditionVariable>() , 12usize , concat !
               ( "Size of: " , stringify ! ( ConditionVariable ) ));
    assert_eq! (::std::mem::align_of::<ConditionVariable>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( ConditionVariable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConditionVariable ) ) . mutex as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ConditionVariable ) ,
                "::" , stringify ! ( mutex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConditionVariable ) ) . wakeup as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ConditionVariable ) ,
                "::" , stringify ! ( wakeup ) ));
}
impl Clone for ConditionVariable {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ConditionVariableInit(arg1: *mut ConditionVariable);
}
extern "C" {
    pub fn ConditionVariableSleep(arg1: *mut ConditionVariable,
                                  wait_event_info: uint32);
}
extern "C" {
    pub fn ConditionVariableCancelSleep();
}
extern "C" {
    pub fn ConditionVariablePrepareToSleep(arg1: *mut ConditionVariable);
}
extern "C" {
    pub fn ConditionVariableSignal(arg1: *mut ConditionVariable) -> bool_;
}
extern "C" {
    pub fn ConditionVariableBroadcast(arg1: *mut ConditionVariable)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ExprState {
    pub tag: Node,
    pub flags: uint8,
    pub resnull: bool_,
    pub resvalue: Datum,
    pub resultslot: *mut TupleTableSlot,
    pub steps: *mut ExprEvalStep,
    pub evalfunc: ExprStateEvalFunc,
    pub expr: *mut Expr,
    pub steps_len: ::std::os::raw::c_int,
    pub steps_alloc: ::std::os::raw::c_int,
    pub innermost_caseval: *mut Datum,
    pub innermost_casenull: *mut bool_,
    pub innermost_domainval: *mut Datum,
    pub innermost_domainnull: *mut bool_,
}
#[test]
fn bindgen_test_layout_ExprState() {
    assert_eq!(::std::mem::size_of::<ExprState>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ExprState ) ));
    assert_eq! (::std::mem::align_of::<ExprState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExprState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . tag as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . resnull as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( resnull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . resvalue as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( resvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . resultslot as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( resultslot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . steps as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( steps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . evalfunc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( evalfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . expr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . steps_len as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( steps_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . steps_alloc as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( steps_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . innermost_caseval as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( innermost_caseval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . innermost_casenull as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( innermost_casenull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . innermost_domainval as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( innermost_domainval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprState ) ) . innermost_domainnull as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprState ) , "::" ,
                stringify ! ( innermost_domainnull ) ));
}
impl Clone for ExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool_,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool_,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool_,
    pub ecxt_estate: *mut EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
#[test]
fn bindgen_test_layout_ExprContext() {
    assert_eq!(::std::mem::size_of::<ExprContext>() , 128usize , concat ! (
               "Size of: " , stringify ! ( ExprContext ) ));
    assert_eq! (::std::mem::align_of::<ExprContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExprContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_scantuple as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_scantuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_innertuple as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_innertuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_outertuple as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_outertuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_per_query_memory
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_per_query_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_per_tuple_memory
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_per_tuple_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_param_exec_vals as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_param_exec_vals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_param_list_info as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_param_list_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_aggvalues as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_aggvalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_aggnulls as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_aggnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . caseValue_datum as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( caseValue_datum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . caseValue_isNull as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( caseValue_isNull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . domainValue_datum as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( domainValue_datum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . domainValue_isNull as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( domainValue_isNull ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_estate as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_estate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext ) ) . ecxt_callbacks as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext ) , "::" ,
                stringify ! ( ecxt_callbacks ) ));
}
impl Clone for ExprContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep {
    _unused: [u8; 0],
}
pub type ExprStateEvalFunc =
    ::std::option::Option<unsafe extern "C" fn(expression: *mut ExprState,
                                               econtext: *mut ExprContext,
                                               isNull: *mut bool_) -> Datum>;
pub type ExprContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Copy)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
#[test]
fn bindgen_test_layout_ExprContext_CB() {
    assert_eq!(::std::mem::size_of::<ExprContext_CB>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ExprContext_CB ) ));
    assert_eq! (::std::mem::align_of::<ExprContext_CB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExprContext_CB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext_CB ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext_CB ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext_CB ) ) . function as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext_CB ) , "::"
                , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExprContext_CB ) ) . arg as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExprContext_CB ) , "::"
                , stringify ! ( arg ) ));
}
impl Clone for ExprContext_CB {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ExprDoneCond {
    ExprSingleResult = 0,
    ExprMultipleResult = 1,
    ExprEndResult = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetFunctionReturnMode {
    SFRM_ValuePerCall = 1,
    SFRM_Materialize = 2,
    SFRM_Materialize_Random = 4,
    SFRM_Materialize_Preferred = 8,
}
#[repr(C)]
#[derive(Copy)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_ReturnSetInfo() {
    assert_eq!(::std::mem::size_of::<ReturnSetInfo>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ReturnSetInfo ) ));
    assert_eq! (::std::mem::align_of::<ReturnSetInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ReturnSetInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . econtext as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( econtext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . expectedDesc as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( expectedDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . allowedModes as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( allowedModes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . returnMode as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( returnMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . isDone as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( isDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . setResult as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( setResult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReturnSetInfo ) ) . setDesc as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ReturnSetInfo ) , "::"
                , stringify ! ( setDesc ) ));
}
impl Clone for ReturnSetInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_state: ExprState,
    pub pi_exprContext: *mut ExprContext,
}
#[test]
fn bindgen_test_layout_ProjectionInfo() {
    assert_eq!(::std::mem::size_of::<ProjectionInfo>() , 104usize , concat ! (
               "Size of: " , stringify ! ( ProjectionInfo ) ));
    assert_eq! (::std::mem::align_of::<ProjectionInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ProjectionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectionInfo ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectionInfo ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectionInfo ) ) . pi_state as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectionInfo ) , "::"
                , stringify ! ( pi_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectionInfo ) ) . pi_exprContext as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectionInfo ) , "::"
                , stringify ! ( pi_exprContext ) ));
}
impl Clone for ProjectionInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
    pub jf_junkAttNo: AttrNumber,
}
#[test]
fn bindgen_test_layout_JunkFilter() {
    assert_eq!(::std::mem::size_of::<JunkFilter>() , 48usize , concat ! (
               "Size of: " , stringify ! ( JunkFilter ) ));
    assert_eq! (::std::mem::align_of::<JunkFilter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( JunkFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JunkFilter ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( JunkFilter ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JunkFilter ) ) . jf_targetList as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( JunkFilter ) , "::" ,
                stringify ! ( jf_targetList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JunkFilter ) ) . jf_cleanTupType as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( JunkFilter ) , "::" ,
                stringify ! ( jf_cleanTupType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JunkFilter ) ) . jf_cleanMap as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( JunkFilter ) , "::" ,
                stringify ! ( jf_cleanMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JunkFilter ) ) . jf_resultSlot as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( JunkFilter ) , "::" ,
                stringify ! ( jf_resultSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JunkFilter ) ) . jf_junkAttNo as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( JunkFilter ) , "::" ,
                stringify ! ( jf_junkAttNo ) ));
}
impl Clone for JunkFilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut ExprState,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_FdwRoutine: *mut FdwRoutine,
    pub ri_FdwState: *mut ::std::os::raw::c_void,
    pub ri_usesFdwDirectModify: bool_,
    pub ri_WithCheckOptions: *mut List,
    pub ri_WithCheckOptionExprs: *mut List,
    pub ri_ConstraintExprs: *mut *mut ExprState,
    pub ri_junkFilter: *mut JunkFilter,
    pub ri_projectReturning: *mut ProjectionInfo,
    pub ri_onConflictSetProj: *mut ProjectionInfo,
    pub ri_onConflictSetWhere: *mut ExprState,
    pub ri_PartitionCheck: *mut List,
    pub ri_PartitionCheckExpr: *mut ExprState,
    pub ri_PartitionRoot: Relation,
}
#[test]
fn bindgen_test_layout_ResultRelInfo() {
    assert_eq!(::std::mem::size_of::<ResultRelInfo>() , 176usize , concat ! (
               "Size of: " , stringify ! ( ResultRelInfo ) ));
    assert_eq! (::std::mem::align_of::<ResultRelInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ResultRelInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_RangeTableIndex as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_RangeTableIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_RelationDesc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_RelationDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_NumIndices as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_NumIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_IndexRelationDescs
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_IndexRelationDescs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_IndexRelationInfo
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_IndexRelationInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_TrigDesc as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_TrigDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_TrigFunctions as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_TrigFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_TrigWhenExprs as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_TrigWhenExprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_TrigInstrument as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_TrigInstrument ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_FdwRoutine as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_FdwRoutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_FdwState as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_FdwState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) .
                ri_usesFdwDirectModify as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_usesFdwDirectModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_WithCheckOptions
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_WithCheckOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) .
                ri_WithCheckOptionExprs as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_WithCheckOptionExprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_ConstraintExprs as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_ConstraintExprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_junkFilter as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_junkFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_projectReturning
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_projectReturning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_onConflictSetProj
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_onConflictSetProj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_onConflictSetWhere
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_onConflictSetWhere ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_PartitionCheck as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_PartitionCheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_PartitionCheckExpr
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_PartitionCheckExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultRelInfo ) ) . ri_PartitionRoot as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultRelInfo ) , "::"
                , stringify ! ( ri_PartitionRoot ) ));
}
impl Clone for ResultRelInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_sourceText: *const ::std::os::raw::c_char,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut ResultRelInfo,
    pub es_num_result_relations: ::std::os::raw::c_int,
    pub es_result_relation_info: *mut ResultRelInfo,
    pub es_root_result_relations: *mut ResultRelInfo,
    pub es_num_root_result_relations: ::std::os::raw::c_int,
    pub es_leaf_result_relations: *mut List,
    pub es_trig_target_relations: *mut List,
    pub es_trig_tuple_slot: *mut TupleTableSlot,
    pub es_trig_oldtup_slot: *mut TupleTableSlot,
    pub es_trig_newtup_slot: *mut TupleTableSlot,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_queryEnv: *mut QueryEnvironment,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_rowMarks: *mut List,
    pub es_processed: uint64,
    pub es_lastoid: Oid,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool_,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epqTuple: *mut HeapTuple,
    pub es_epqTupleSet: *mut bool_,
    pub es_epqScanDone: *mut bool_,
    pub es_query_dsa: *mut dsa_area,
}
#[test]
fn bindgen_test_layout_EState() {
    assert_eq!(::std::mem::size_of::<EState>() , 280usize , concat ! (
               "Size of: " , stringify ! ( EState ) ));
    assert_eq! (::std::mem::align_of::<EState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_direction as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_snapshot as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_snapshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_crosscheck_snapshot as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_crosscheck_snapshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_range_table as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_range_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_plannedstmt as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_plannedstmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_sourceText as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_sourceText ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_junkFilter as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_junkFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_output_cid as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_output_cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_result_relations as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_result_relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_num_result_relations as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_num_result_relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_result_relation_info as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_result_relation_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_root_result_relations as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_root_result_relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_num_root_result_relations
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_num_root_result_relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_leaf_result_relations as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_leaf_result_relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_trig_target_relations as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_trig_target_relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_trig_tuple_slot as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_trig_tuple_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_trig_oldtup_slot as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_trig_oldtup_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_trig_newtup_slot as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_trig_newtup_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_param_list_info as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_param_list_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_param_exec_vals as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_param_exec_vals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_queryEnv as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_queryEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_query_cxt as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_query_cxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_tupleTable as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_tupleTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_rowMarks as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_processed as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_processed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_lastoid as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_lastoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_top_eflags as * const _
                as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_top_eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_instrument as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_instrument ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_finished as * const _ as
                usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_finished ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_exprcontexts as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_exprcontexts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_subplanstates as * const
                _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_subplanstates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_auxmodifytables as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_auxmodifytables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_per_tuple_exprcontext as
                * const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_per_tuple_exprcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_epqTuple as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_epqTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_epqTupleSet as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_epqTupleSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_epqScanDone as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_epqScanDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EState ) ) . es_query_dsa as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( EState ) , "::" ,
                stringify ! ( es_query_dsa ) ));
}
impl Clone for EState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub ermActive: bool_,
    pub curCtid: ItemPointerData,
    pub ermExtra: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ExecRowMark() {
    assert_eq!(::std::mem::size_of::<ExecRowMark>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ExecRowMark ) ));
    assert_eq! (::std::mem::align_of::<ExecRowMark>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExecRowMark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . relation as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . relid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . rti as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( rti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . prti as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( prti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . rowmarkId as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( rowmarkId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . markType as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( markType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . strength as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . waitPolicy as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( waitPolicy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . ermActive as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( ermActive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . curCtid as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( curCtid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecRowMark ) ) . ermExtra as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecRowMark ) , "::" ,
                stringify ! ( ermExtra ) ));
}
impl Clone for ExecRowMark {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
#[test]
fn bindgen_test_layout_ExecAuxRowMark() {
    assert_eq!(::std::mem::size_of::<ExecAuxRowMark>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ExecAuxRowMark ) ));
    assert_eq! (::std::mem::align_of::<ExecAuxRowMark>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExecAuxRowMark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecAuxRowMark ) ) . rowmark as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecAuxRowMark ) , "::"
                , stringify ! ( rowmark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecAuxRowMark ) ) . ctidAttNo as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecAuxRowMark ) , "::"
                , stringify ! ( ctidAttNo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecAuxRowMark ) ) . toidAttNo as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecAuxRowMark ) , "::"
                , stringify ! ( toidAttNo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecAuxRowMark ) ) . wholeAttNo as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecAuxRowMark ) , "::"
                , stringify ! ( wholeAttNo ) ));
}
impl Clone for ExecAuxRowMark {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
    pub additional: *mut ::std::os::raw::c_void,
    pub status: uint32,
    pub hash: uint32,
}
#[test]
fn bindgen_test_layout_TupleHashEntryData() {
    assert_eq!(::std::mem::size_of::<TupleHashEntryData>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( TupleHashEntryData ) ));
    assert_eq! (::std::mem::align_of::<TupleHashEntryData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TupleHashEntryData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashEntryData ) ) . firstTuple as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashEntryData ) ,
                "::" , stringify ! ( firstTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashEntryData ) ) . additional as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashEntryData ) ,
                "::" , stringify ! ( additional ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashEntryData ) ) . status as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashEntryData ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashEntryData ) ) . hash as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashEntryData ) ,
                "::" , stringify ! ( hash ) ));
}
impl Clone for TupleHashEntryData {
    fn clone(&self) -> Self { *self }
}
pub type TupleHashEntry = *mut TupleHashEntryData;
#[repr(C)]
#[derive(Copy)]
pub struct TupleHashTableData {
    pub hashtab: *mut tuplehash_hash,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
    pub hash_iv: uint32,
}
#[test]
fn bindgen_test_layout_TupleHashTableData() {
    assert_eq!(::std::mem::size_of::<TupleHashTableData>() , 104usize , concat
               ! ( "Size of: " , stringify ! ( TupleHashTableData ) ));
    assert_eq! (::std::mem::align_of::<TupleHashTableData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TupleHashTableData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . hashtab as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( hashtab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . numCols as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( numCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . keyColIdx as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( keyColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . tab_hash_funcs
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( tab_hash_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . tab_eq_funcs as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( tab_eq_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . tablecxt as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( tablecxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . tempcxt as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( tempcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . entrysize as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( entrysize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . tableslot as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( tableslot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . inputslot as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( inputslot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . in_hash_funcs as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( in_hash_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . cur_eq_funcs as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( cur_eq_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TupleHashTableData ) ) . hash_iv as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( TupleHashTableData ) ,
                "::" , stringify ! ( hash_iv ) ));
}
impl Clone for TupleHashTableData {
    fn clone(&self) -> Self { *self }
}
pub type TupleHashTable = *mut TupleHashTableData;
#[repr(C)]
#[derive(Copy)]
pub struct tuplehash_hash {
    pub size: uint64,
    pub members: uint32,
    pub sizemask: uint32,
    pub grow_threshold: uint32,
    pub data: *mut TupleHashEntryData,
    pub ctx: MemoryContext,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tuplehash_hash() {
    assert_eq!(::std::mem::size_of::<tuplehash_hash>() , 48usize , concat ! (
               "Size of: " , stringify ! ( tuplehash_hash ) ));
    assert_eq! (::std::mem::align_of::<tuplehash_hash>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tuplehash_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . members as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . sizemask as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( sizemask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . grow_threshold as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( grow_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . ctx as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_hash ) ) . private_data as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_hash ) , "::"
                , stringify ! ( private_data ) ));
}
impl Clone for tuplehash_hash {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tuplehash_status { tuplehash_EMPTY = 0, tuplehash_IN_USE = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct tuplehash_iterator {
    pub cur: uint32,
    pub end: uint32,
    pub done: bool_,
}
#[test]
fn bindgen_test_layout_tuplehash_iterator() {
    assert_eq!(::std::mem::size_of::<tuplehash_iterator>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( tuplehash_iterator ) ));
    assert_eq! (::std::mem::align_of::<tuplehash_iterator>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tuplehash_iterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_iterator ) ) . cur as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_iterator ) ,
                "::" , stringify ! ( cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_iterator ) ) . end as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_iterator ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tuplehash_iterator ) ) . done as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tuplehash_iterator ) ,
                "::" , stringify ! ( done ) ));
}
impl Clone for tuplehash_iterator {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tuplehash_create(ctx: MemoryContext, nelements: uint32,
                            private_data: *mut ::std::os::raw::c_void)
     -> *mut tuplehash_hash;
}
extern "C" {
    pub fn tuplehash_destroy(tb: *mut tuplehash_hash);
}
extern "C" {
    pub fn tuplehash_grow(tb: *mut tuplehash_hash, newsize: uint32);
}
extern "C" {
    pub fn tuplehash_insert(tb: *mut tuplehash_hash, key: MinimalTuple,
                            found: *mut bool_) -> *mut TupleHashEntryData;
}
extern "C" {
    pub fn tuplehash_lookup(tb: *mut tuplehash_hash, key: MinimalTuple)
     -> *mut TupleHashEntryData;
}
extern "C" {
    pub fn tuplehash_delete(tb: *mut tuplehash_hash, key: MinimalTuple)
     -> bool_;
}
extern "C" {
    pub fn tuplehash_start_iterate(tb: *mut tuplehash_hash,
                                   iter: *mut tuplehash_iterator);
}
extern "C" {
    pub fn tuplehash_start_iterate_at(tb: *mut tuplehash_hash,
                                      iter: *mut tuplehash_iterator,
                                      at: uint32);
}
extern "C" {
    pub fn tuplehash_iterate(tb: *mut tuplehash_hash,
                             iter: *mut tuplehash_iterator)
     -> *mut TupleHashEntryData;
}
extern "C" {
    pub fn tuplehash_stat(tb: *mut tuplehash_hash);
}
pub type TupleHashIterator = tuplehash_iterator;
#[repr(C)]
#[derive(Copy)]
pub struct AggrefExprState {
    pub type_: NodeTag,
    pub aggref: *mut Aggref,
    pub aggno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AggrefExprState() {
    assert_eq!(::std::mem::size_of::<AggrefExprState>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AggrefExprState ) ));
    assert_eq! (::std::mem::align_of::<AggrefExprState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AggrefExprState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggrefExprState ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AggrefExprState ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggrefExprState ) ) . aggref as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AggrefExprState ) ,
                "::" , stringify ! ( aggref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggrefExprState ) ) . aggno as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AggrefExprState ) ,
                "::" , stringify ! ( aggno ) ));
}
impl Clone for AggrefExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowFuncExprState {
    pub type_: NodeTag,
    pub wfunc: *mut WindowFunc,
    pub args: *mut List,
    pub aggfilter: *mut ExprState,
    pub wfuncno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowFuncExprState() {
    assert_eq!(::std::mem::size_of::<WindowFuncExprState>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( WindowFuncExprState ) ));
    assert_eq! (::std::mem::align_of::<WindowFuncExprState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( WindowFuncExprState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFuncExprState ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFuncExprState ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFuncExprState ) ) . wfunc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFuncExprState ) ,
                "::" , stringify ! ( wfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFuncExprState ) ) . args as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFuncExprState ) ,
                "::" , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFuncExprState ) ) . aggfilter as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFuncExprState ) ,
                "::" , stringify ! ( aggfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowFuncExprState ) ) . wfuncno as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowFuncExprState ) ,
                "::" , stringify ! ( wfuncno ) ));
}
impl Clone for WindowFuncExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SetExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub args: *mut List,
    pub elidedFuncState: *mut ExprState,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool_,
    pub funcReturnsSet: bool_,
    pub setArgsValid: bool_,
    pub shutdown_reg: bool_,
    pub fcinfo_data: FunctionCallInfoData,
}
#[test]
fn bindgen_test_layout_SetExprState() {
    assert_eq!(::std::mem::size_of::<SetExprState>() , 1048usize , concat ! (
               "Size of: " , stringify ! ( SetExprState ) ));
    assert_eq! (::std::mem::align_of::<SetExprState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SetExprState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . expr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . args as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . elidedFuncState as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( elidedFuncState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . func as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . funcResultStore as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( funcResultStore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . funcResultSlot as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( funcResultSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . funcResultDesc as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( funcResultDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . funcReturnsTuple as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( funcReturnsTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . funcReturnsSet as *
                const _ as usize } , 105usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( funcReturnsSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . setArgsValid as *
                const _ as usize } , 106usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( setArgsValid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . shutdown_reg as *
                const _ as usize } , 107usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( shutdown_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetExprState ) ) . fcinfo_data as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( SetExprState ) , "::" ,
                stringify ! ( fcinfo_data ) ));
}
impl Clone for SetExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut SubPlan,
    pub planstate: *mut PlanState,
    pub parent: *mut PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool_,
    pub havenullrows: bool_,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
}
#[test]
fn bindgen_test_layout_SubPlanState() {
    assert_eq!(::std::mem::size_of::<SubPlanState>() , 168usize , concat ! (
               "Size of: " , stringify ! ( SubPlanState ) ));
    assert_eq! (::std::mem::align_of::<SubPlanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SubPlanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . subplan as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( subplan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . planstate as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( planstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . parent as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . testexpr as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( testexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . args as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . curTuple as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( curTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . curArray as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( curArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . projLeft as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( projLeft ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . projRight as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( projRight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . hashtable as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( hashtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . hashnulls as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( hashnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . havehashrows as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( havehashrows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . havenullrows as *
                const _ as usize } , 97usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( havenullrows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . hashtablecxt as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( hashtablecxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . hashtempcxt as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( hashtempcxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . innerecontext as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( innerecontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . keyColIdx as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( keyColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . tab_hash_funcs as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( tab_hash_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . tab_eq_funcs as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( tab_eq_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . lhs_hash_funcs as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( lhs_hash_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubPlanState ) ) . cur_eq_funcs as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( SubPlanState ) , "::" ,
                stringify ! ( cur_eq_funcs ) ));
}
impl Clone for SubPlanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlternativeSubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut AlternativeSubPlan,
    pub subplans: *mut List,
    pub active: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AlternativeSubPlanState() {
    assert_eq!(::std::mem::size_of::<AlternativeSubPlanState>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( AlternativeSubPlanState ) ));
    assert_eq! (::std::mem::align_of::<AlternativeSubPlanState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlternativeSubPlanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlternativeSubPlanState ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlternativeSubPlanState
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlternativeSubPlanState ) ) . subplan as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlternativeSubPlanState
                ) , "::" , stringify ! ( subplan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlternativeSubPlanState ) ) . subplans as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlternativeSubPlanState
                ) , "::" , stringify ! ( subplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlternativeSubPlanState ) ) . active as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlternativeSubPlanState
                ) , "::" , stringify ! ( active ) ));
}
impl Clone for AlternativeSubPlanState {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DomainConstraintType {
    DOM_CONSTRAINT_NOTNULL = 0,
    DOM_CONSTRAINT_CHECK = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: *mut ::std::os::raw::c_char,
    pub check_expr: *mut Expr,
    pub check_exprstate: *mut ExprState,
}
#[test]
fn bindgen_test_layout_DomainConstraintState() {
    assert_eq!(::std::mem::size_of::<DomainConstraintState>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( DomainConstraintState )
               ));
    assert_eq! (::std::mem::align_of::<DomainConstraintState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( DomainConstraintState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DomainConstraintState ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DomainConstraintState )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DomainConstraintState ) ) .
                constrainttype as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( DomainConstraintState )
                , "::" , stringify ! ( constrainttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DomainConstraintState ) ) . name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DomainConstraintState )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DomainConstraintState ) ) . check_expr as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DomainConstraintState )
                , "::" , stringify ! ( check_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DomainConstraintState ) ) .
                check_exprstate as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DomainConstraintState )
                , "::" , stringify ! ( check_exprstate ) ));
}
impl Clone for DomainConstraintState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub ExecProcNode: ExecProcNodeMtd,
    pub ExecProcNodeReal: ExecProcNodeMtd,
    pub instrument: *mut Instrumentation,
    pub worker_instrument: *mut WorkerInstrumentation,
    pub qual: *mut ExprState,
    pub lefttree: *mut PlanState,
    pub righttree: *mut PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
}
#[test]
fn bindgen_test_layout_PlanState() {
    assert_eq!(::std::mem::size_of::<PlanState>() , 128usize , concat ! (
               "Size of: " , stringify ! ( PlanState ) ));
    assert_eq! (::std::mem::align_of::<PlanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PlanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . plan as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . ExecProcNode as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( ExecProcNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . ExecProcNodeReal as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( ExecProcNodeReal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . instrument as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( instrument ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . worker_instrument as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( worker_instrument ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . qual as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . lefttree as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( lefttree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . righttree as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( righttree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . initPlan as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( initPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . subPlan as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( subPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . chgParam as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( chgParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . ps_ResultTupleSlot as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( ps_ResultTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . ps_ExprContext as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( ps_ExprContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlanState ) ) . ps_ProjInfo as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( PlanState ) , "::" ,
                stringify ! ( ps_ProjInfo ) ));
}
impl Clone for PlanState {
    fn clone(&self) -> Self { *self }
}
pub type ExecProcNodeMtd =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut PlanState)
                              -> *mut TupleTableSlot>;
#[repr(C)]
#[derive(Copy)]
pub struct EPQState {
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub origslot: *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EPQState() {
    assert_eq!(::std::mem::size_of::<EPQState>() , 48usize , concat ! (
               "Size of: " , stringify ! ( EPQState ) ));
    assert_eq! (::std::mem::align_of::<EPQState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EPQState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EPQState ) ) . estate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EPQState ) , "::" ,
                stringify ! ( estate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EPQState ) ) . planstate as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EPQState ) , "::" ,
                stringify ! ( planstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EPQState ) ) . origslot as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EPQState ) , "::" ,
                stringify ! ( origslot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EPQState ) ) . plan as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EPQState ) , "::" ,
                stringify ! ( plan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EPQState ) ) . arowMarks as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EPQState ) , "::" ,
                stringify ! ( arowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EPQState ) ) . epqParam as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EPQState ) , "::" ,
                stringify ! ( epqParam ) ));
}
impl Clone for EPQState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool_,
    pub rs_checkqual: bool_,
}
#[test]
fn bindgen_test_layout_ResultState() {
    assert_eq!(::std::mem::size_of::<ResultState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( ResultState ) ));
    assert_eq! (::std::mem::align_of::<ResultState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ResultState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultState ) ) . resconstantqual as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultState ) , "::" ,
                stringify ! ( resconstantqual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultState ) ) . rs_done as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultState ) , "::" ,
                stringify ! ( rs_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultState ) ) . rs_checkqual as * const
                _ as usize } , 137usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultState ) , "::" ,
                stringify ! ( rs_checkqual ) ));
}
impl Clone for ResultState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ProjectSetState {
    pub ps: PlanState,
    pub elems: *mut *mut Node,
    pub elemdone: *mut ExprDoneCond,
    pub nelems: ::std::os::raw::c_int,
    pub pending_srf_tuples: bool_,
}
#[test]
fn bindgen_test_layout_ProjectSetState() {
    assert_eq!(::std::mem::size_of::<ProjectSetState>() , 152usize , concat !
               ( "Size of: " , stringify ! ( ProjectSetState ) ));
    assert_eq! (::std::mem::align_of::<ProjectSetState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ProjectSetState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetState ) ,
                "::" , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetState ) ) . elems as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetState ) ,
                "::" , stringify ! ( elems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetState ) ) . elemdone as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetState ) ,
                "::" , stringify ! ( elemdone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetState ) ) . nelems as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetState ) ,
                "::" , stringify ! ( nelems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetState ) ) . pending_srf_tuples
                as * const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetState ) ,
                "::" , stringify ! ( pending_srf_tuples ) ));
}
impl Clone for ProjectSetState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub mt_done: bool_,
    pub mt_plans: *mut *mut PlanState,
    pub mt_nplans: ::std::os::raw::c_int,
    pub mt_whichplan: ::std::os::raw::c_int,
    pub resultRelInfo: *mut ResultRelInfo,
    pub rootResultRelInfo: *mut ResultRelInfo,
    pub mt_arowmarks: *mut *mut List,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool_,
    pub mt_onconflict: OnConflictAction,
    pub mt_arbiterindexes: *mut List,
    pub mt_existing: *mut TupleTableSlot,
    pub mt_excludedtlist: *mut List,
    pub mt_conflproj: *mut TupleTableSlot,
    pub mt_partition_dispatch_info: *mut *mut PartitionDispatchData,
    pub mt_num_dispatch: ::std::os::raw::c_int,
    pub mt_num_partitions: ::std::os::raw::c_int,
    pub mt_partitions: *mut ResultRelInfo,
    pub mt_partition_tupconv_maps: *mut *mut TupleConversionMap,
    pub mt_partition_tuple_slot: *mut TupleTableSlot,
    pub mt_transition_capture: *mut TransitionCaptureState,
    pub mt_oc_transition_capture: *mut TransitionCaptureState,
    pub mt_transition_tupconv_maps: *mut *mut TupleConversionMap,
}
#[test]
fn bindgen_test_layout_ModifyTableState() {
    assert_eq!(::std::mem::size_of::<ModifyTableState>() , 328usize , concat !
               ( "Size of: " , stringify ! ( ModifyTableState ) ));
    assert_eq! (::std::mem::align_of::<ModifyTableState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ModifyTableState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . operation as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . canSetTag as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( canSetTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_done as * const
                _ as usize } , 133usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_plans as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_plans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_nplans as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_nplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_whichplan as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_whichplan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . resultRelInfo as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( resultRelInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . rootResultRelInfo
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( rootResultRelInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_arowmarks as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_arowmarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_epqstate as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_epqstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . fireBSTriggers as
                * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( fireBSTriggers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_onconflict as *
                const _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_onconflict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_arbiterindexes
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_arbiterindexes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_existing as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_existing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_excludedtlist
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_excludedtlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_conflproj as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_conflproj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) .
                mt_partition_dispatch_info as * const _ as usize } , 264usize
                , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_partition_dispatch_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_num_dispatch as
                * const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_num_dispatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_num_partitions
                as * const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_num_partitions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) . mt_partitions as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_partitions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) .
                mt_partition_tupconv_maps as * const _ as usize } , 288usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_partition_tupconv_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) .
                mt_partition_tuple_slot as * const _ as usize } , 296usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_partition_tuple_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) .
                mt_transition_capture as * const _ as usize } , 304usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_transition_capture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) .
                mt_oc_transition_capture as * const _ as usize } , 312usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_oc_transition_capture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTableState ) ) .
                mt_transition_tupconv_maps as * const _ as usize } , 320usize
                , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTableState ) ,
                "::" , stringify ! ( mt_transition_tupconv_maps ) ));
}
impl Clone for ModifyTableState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AppendState() {
    assert_eq!(::std::mem::size_of::<AppendState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( AppendState ) ));
    assert_eq! (::std::mem::align_of::<AppendState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AppendState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendState ) ) . appendplans as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendState ) , "::" ,
                stringify ! ( appendplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendState ) ) . as_nplans as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendState ) , "::" ,
                stringify ! ( as_nplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendState ) ) . as_whichplan as * const
                _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendState ) , "::" ,
                stringify ! ( as_whichplan ) ));
}
impl Clone for AppendState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut binaryheap,
    pub ms_initialized: bool_,
}
#[test]
fn bindgen_test_layout_MergeAppendState() {
    assert_eq!(::std::mem::size_of::<MergeAppendState>() , 176usize , concat !
               ( "Size of: " , stringify ! ( MergeAppendState ) ));
    assert_eq! (::std::mem::align_of::<MergeAppendState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( MergeAppendState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . mergeplans as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( mergeplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ms_nplans as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ms_nplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ms_nkeys as *
                const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ms_nkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ms_sortkeys as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ms_sortkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ms_slots as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ms_slots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ms_heap as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ms_heap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendState ) ) . ms_initialized as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendState ) ,
                "::" , stringify ! ( ms_initialized ) ));
}
impl Clone for MergeAppendState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool_,
    pub intermediate_empty: bool_,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
#[test]
fn bindgen_test_layout_RecursiveUnionState() {
    assert_eq!(::std::mem::size_of::<RecursiveUnionState>() , 192usize ,
               concat ! ( "Size of: " , stringify ! ( RecursiveUnionState )
               ));
    assert_eq! (::std::mem::align_of::<RecursiveUnionState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( RecursiveUnionState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . ps as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . recursing as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( recursing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) .
                intermediate_empty as * const _ as usize } , 129usize , concat
                ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( intermediate_empty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . working_table
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( working_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) .
                intermediate_table as * const _ as usize } , 144usize , concat
                ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( intermediate_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . eqfunctions as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( eqfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . hashfunctions
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( hashfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . tempContext as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( tempContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . hashtable as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( hashtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionState ) ) . tableContext as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionState ) ,
                "::" , stringify ! ( tableContext ) ));
}
impl Clone for RecursiveUnionState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapAndState() {
    assert_eq!(::std::mem::size_of::<BitmapAndState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( BitmapAndState ) ));
    assert_eq! (::std::mem::align_of::<BitmapAndState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapAndState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAndState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAndState ) , "::"
                , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAndState ) ) . bitmapplans as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAndState ) , "::"
                , stringify ! ( bitmapplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAndState ) ) . nplans as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAndState ) , "::"
                , stringify ! ( nplans ) ));
}
impl Clone for BitmapAndState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapOrState() {
    assert_eq!(::std::mem::size_of::<BitmapOrState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( BitmapOrState ) ));
    assert_eq! (::std::mem::align_of::<BitmapOrState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapOrState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOrState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOrState ) , "::"
                , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOrState ) ) . bitmapplans as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOrState ) , "::"
                , stringify ! ( bitmapplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOrState ) ) . nplans as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOrState ) , "::"
                , stringify ! ( nplans ) ));
}
impl Clone for BitmapOrState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: HeapScanDesc,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_ScanState() {
    assert_eq!(::std::mem::size_of::<ScanState>() , 152usize , concat ! (
               "Size of: " , stringify ! ( ScanState ) ));
    assert_eq! (::std::mem::align_of::<ScanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanState ) ) . ps as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanState ) ) . ss_currentRelation as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanState ) , "::" ,
                stringify ! ( ss_currentRelation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanState ) ) . ss_currentScanDesc as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanState ) , "::" ,
                stringify ! ( ss_currentScanDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ScanState ) ) . ss_ScanTupleSlot as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ScanState ) , "::" ,
                stringify ! ( ss_ScanTupleSlot ) ));
}
impl Clone for ScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
#[test]
fn bindgen_test_layout_SeqScanState() {
    assert_eq!(::std::mem::size_of::<SeqScanState>() , 160usize , concat ! (
               "Size of: " , stringify ! ( SeqScanState ) ));
    assert_eq! (::std::mem::align_of::<SeqScanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SeqScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SeqScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SeqScanState ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SeqScanState ) ) . pscan_len as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( SeqScanState ) , "::" ,
                stringify ! ( pscan_len ) ));
}
impl Clone for SeqScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: *mut List,
    pub repeatable: *mut ExprState,
    pub tsmroutine: *mut TsmRoutine,
    pub tsm_state: *mut ::std::os::raw::c_void,
    pub use_bulkread: bool_,
    pub use_pagemode: bool_,
    pub begun: bool_,
    pub seed: uint32,
}
#[test]
fn bindgen_test_layout_SampleScanState() {
    assert_eq!(::std::mem::size_of::<SampleScanState>() , 192usize , concat !
               ( "Size of: " , stringify ! ( SampleScanState ) ));
    assert_eq! (::std::mem::align_of::<SampleScanState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SampleScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . args as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . repeatable as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( repeatable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . tsmroutine as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( tsmroutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . tsm_state as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( tsm_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . use_bulkread as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( use_bulkread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . use_pagemode as *
                const _ as usize } , 185usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( use_pagemode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . begun as * const _
                as usize } , 186usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( begun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SampleScanState ) ) . seed as * const _
                as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( SampleScanState ) ,
                "::" , stringify ! ( seed ) ));
}
impl Clone for SampleScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: ScanKey,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool_,
}
#[test]
fn bindgen_test_layout_IndexRuntimeKeyInfo() {
    assert_eq!(::std::mem::size_of::<IndexRuntimeKeyInfo>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( IndexRuntimeKeyInfo ) ));
    assert_eq! (::std::mem::align_of::<IndexRuntimeKeyInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( IndexRuntimeKeyInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexRuntimeKeyInfo ) ) . scan_key as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexRuntimeKeyInfo ) ,
                "::" , stringify ! ( scan_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexRuntimeKeyInfo ) ) . key_expr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexRuntimeKeyInfo ) ,
                "::" , stringify ! ( key_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexRuntimeKeyInfo ) ) . key_toastable
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexRuntimeKeyInfo ) ,
                "::" , stringify ! ( key_toastable ) ));
}
impl Clone for IndexRuntimeKeyInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexArrayKeyInfo {
    pub scan_key: ScanKey,
    pub array_expr: *mut ExprState,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool_,
}
#[test]
fn bindgen_test_layout_IndexArrayKeyInfo() {
    assert_eq!(::std::mem::size_of::<IndexArrayKeyInfo>() , 40usize , concat !
               ( "Size of: " , stringify ! ( IndexArrayKeyInfo ) ));
    assert_eq! (::std::mem::align_of::<IndexArrayKeyInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( IndexArrayKeyInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexArrayKeyInfo ) ) . scan_key as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexArrayKeyInfo ) ,
                "::" , stringify ! ( scan_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexArrayKeyInfo ) ) . array_expr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexArrayKeyInfo ) ,
                "::" , stringify ! ( array_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexArrayKeyInfo ) ) . next_elem as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexArrayKeyInfo ) ,
                "::" , stringify ! ( next_elem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexArrayKeyInfo ) ) . num_elems as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexArrayKeyInfo ) ,
                "::" , stringify ! ( num_elems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexArrayKeyInfo ) ) . elem_values as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexArrayKeyInfo ) ,
                "::" , stringify ! ( elem_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexArrayKeyInfo ) ) . elem_nulls as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexArrayKeyInfo ) ,
                "::" , stringify ! ( elem_nulls ) ));
}
impl Clone for IndexArrayKeyInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut ExprState,
    pub indexorderbyorig: *mut List,
    pub iss_ScanKeys: ScanKey,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: ScanKey,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool_,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: IndexScanDesc,
    pub iss_ReorderQueue: *mut pairingheap,
    pub iss_ReachedEnd: bool_,
    pub iss_OrderByValues: *mut Datum,
    pub iss_OrderByNulls: *mut bool_,
    pub iss_SortSupport: SortSupport,
    pub iss_OrderByTypByVals: *mut bool_,
    pub iss_OrderByTypLens: *mut int16,
    pub iss_PscanLen: Size,
}
#[test]
fn bindgen_test_layout_IndexScanState() {
    assert_eq!(::std::mem::size_of::<IndexScanState>() , 304usize , concat ! (
               "Size of: " , stringify ! ( IndexScanState ) ));
    assert_eq! (::std::mem::align_of::<IndexScanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . indexqualorig as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( indexqualorig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . indexorderbyorig as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( indexorderbyorig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_ScanKeys as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_ScanKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_NumScanKeys as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_NumScanKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_OrderByKeys as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_OrderByKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_NumOrderByKeys
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_NumOrderByKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_RuntimeKeys as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_RuntimeKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_NumRuntimeKeys
                as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_NumRuntimeKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_RuntimeKeysReady
                as * const _ as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_RuntimeKeysReady ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_RuntimeContext
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_RuntimeContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_RelationDesc as
                * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_RelationDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_ScanDesc as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_ScanDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_ReorderQueue as
                * const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_ReorderQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_ReachedEnd as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_ReachedEnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_OrderByValues as
                * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_OrderByValues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_OrderByNulls as
                * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_OrderByNulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_SortSupport as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_SortSupport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_OrderByTypByVals
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_OrderByTypByVals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_OrderByTypLens
                as * const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_OrderByTypLens ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexScanState ) ) . iss_PscanLen as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexScanState ) , "::"
                , stringify ! ( iss_PscanLen ) ));
}
impl Clone for IndexScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub indexqual: *mut ExprState,
    pub ioss_ScanKeys: ScanKey,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: ScanKey,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool_,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: IndexScanDesc,
    pub ioss_VMBuffer: Buffer,
    pub ioss_HeapFetches: ::std::os::raw::c_long,
    pub ioss_PscanLen: Size,
}
#[test]
fn bindgen_test_layout_IndexOnlyScanState() {
    assert_eq!(::std::mem::size_of::<IndexOnlyScanState>() , 256usize , concat
               ! ( "Size of: " , stringify ! ( IndexOnlyScanState ) ));
    assert_eq! (::std::mem::align_of::<IndexOnlyScanState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( IndexOnlyScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . indexqual as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( indexqual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_ScanKeys as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_ScanKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_NumScanKeys
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_NumScanKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_OrderByKeys
                as * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_OrderByKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) .
                ioss_NumOrderByKeys as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_NumOrderByKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_RuntimeKeys
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_RuntimeKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) .
                ioss_NumRuntimeKeys as * const _ as usize } , 200usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_NumRuntimeKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) .
                ioss_RuntimeKeysReady as * const _ as usize } , 204usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_RuntimeKeysReady ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) .
                ioss_RuntimeContext as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_RuntimeContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) .
                ioss_RelationDesc as * const _ as usize } , 216usize , concat
                ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_RelationDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_ScanDesc as
                * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_ScanDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_VMBuffer as
                * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_VMBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_HeapFetches
                as * const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_HeapFetches ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOnlyScanState ) ) . ioss_PscanLen as
                * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOnlyScanState ) ,
                "::" , stringify ! ( ioss_PscanLen ) ));
}
impl Clone for IndexOnlyScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: ScanKey,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool_,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: IndexScanDesc,
}
#[test]
fn bindgen_test_layout_BitmapIndexScanState() {
    assert_eq!(::std::mem::size_of::<BitmapIndexScanState>() , 232usize ,
               concat ! ( "Size of: " , stringify ! ( BitmapIndexScanState )
               ));
    assert_eq! (::std::mem::align_of::<BitmapIndexScanState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( BitmapIndexScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) . ss as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) . biss_result as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) . biss_ScanKeys
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_ScanKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_NumScanKeys as * const _ as usize } , 168usize , concat !
                (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_NumScanKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_RuntimeKeys as * const _ as usize } , 176usize , concat !
                (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_RuntimeKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_NumRuntimeKeys as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_NumRuntimeKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) . biss_ArrayKeys
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_ArrayKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_NumArrayKeys as * const _ as usize } , 200usize , concat
                ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_NumArrayKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_RuntimeKeysReady as * const _ as usize } , 204usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_RuntimeKeysReady ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_RuntimeContext as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_RuntimeContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) .
                biss_RelationDesc as * const _ as usize } , 216usize , concat
                ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_RelationDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapIndexScanState ) ) . biss_ScanDesc
                as * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapIndexScanState )
                , "::" , stringify ! ( biss_ScanDesc ) ));
}
impl Clone for BitmapIndexScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SharedBitmapState {
    BM_INITIAL = 0,
    BM_INPROGRESS = 1,
    BM_FINISHED = 2,
}
#[repr(C)]
pub struct ParallelBitmapHeapState {
    pub tbmiterator: dsa_pointer,
    pub prefetch_iterator: dsa_pointer,
    pub mutex: slock_t,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub state: SharedBitmapState,
    pub cv: ConditionVariable,
    pub phs_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_ParallelBitmapHeapState() {
    assert_eq!(::std::mem::size_of::<ParallelBitmapHeapState>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( ParallelBitmapHeapState ) ));
    assert_eq! (::std::mem::align_of::<ParallelBitmapHeapState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ParallelBitmapHeapState ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut ExprState,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub exact_pages: ::std::os::raw::c_long,
    pub lossy_pages: ::std::os::raw::c_long,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub prefetch_maximum: ::std::os::raw::c_int,
    pub pscan_len: Size,
    pub initialized: bool_,
    pub shared_tbmiterator: *mut TBMSharedIterator,
    pub shared_prefetch_iterator: *mut TBMSharedIterator,
    pub pstate: *mut ParallelBitmapHeapState,
}
#[test]
fn bindgen_test_layout_BitmapHeapScanState() {
    assert_eq!(::std::mem::size_of::<BitmapHeapScanState>() , 264usize ,
               concat ! ( "Size of: " , stringify ! ( BitmapHeapScanState )
               ));
    assert_eq! (::std::mem::align_of::<BitmapHeapScanState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( BitmapHeapScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . ss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . bitmapqualorig
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( bitmapqualorig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . tbm as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( tbm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . tbmiterator as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( tbmiterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . tbmres as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( tbmres ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . exact_pages as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( exact_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . lossy_pages as
                * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( lossy_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) .
                prefetch_iterator as * const _ as usize } , 200usize , concat
                ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( prefetch_iterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . prefetch_pages
                as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( prefetch_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . prefetch_target
                as * const _ as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( prefetch_target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) .
                prefetch_maximum as * const _ as usize } , 216usize , concat !
                (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( prefetch_maximum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . pscan_len as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( pscan_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . initialized as
                * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) .
                shared_tbmiterator as * const _ as usize } , 240usize , concat
                ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( shared_tbmiterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) .
                shared_prefetch_iterator as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( shared_prefetch_iterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapScanState ) ) . pstate as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapScanState ) ,
                "::" , stringify ! ( pstate ) ));
}
impl Clone for BitmapHeapScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidexprs: *mut List,
    pub tss_isCurrentOf: bool_,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_TidList: *mut ItemPointerData,
    pub tss_htup: HeapTupleData,
}
#[test]
fn bindgen_test_layout_TidScanState() {
    assert_eq!(::std::mem::size_of::<TidScanState>() , 208usize , concat ! (
               "Size of: " , stringify ! ( TidScanState ) ));
    assert_eq! (::std::mem::align_of::<TidScanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TidScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . tss_tidexprs as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( tss_tidexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . tss_isCurrentOf as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( tss_isCurrentOf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . tss_NumTids as * const
                _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( tss_NumTids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . tss_TidPtr as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( tss_TidPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . tss_TidList as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( tss_TidList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidScanState ) ) . tss_htup as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( TidScanState ) , "::" ,
                stringify ! ( tss_htup ) ));
}
impl Clone for TidScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
#[test]
fn bindgen_test_layout_SubqueryScanState() {
    assert_eq!(::std::mem::size_of::<SubqueryScanState>() , 160usize , concat
               ! ( "Size of: " , stringify ! ( SubqueryScanState ) ));
    assert_eq! (::std::mem::align_of::<SubqueryScanState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( SubqueryScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubqueryScanState ) ) . ss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SubqueryScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubqueryScanState ) ) . subplan as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( SubqueryScanState ) ,
                "::" , stringify ! ( subplan ) ));
}
impl Clone for SubqueryScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanPerFuncState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub ordinality: bool_,
    pub simple: bool_,
    pub ordinal: int64,
    pub nfuncs: ::std::os::raw::c_int,
    pub funcstates: *mut FunctionScanPerFuncState,
    pub argcontext: MemoryContext,
}
#[test]
fn bindgen_test_layout_FunctionScanState() {
    assert_eq!(::std::mem::size_of::<FunctionScanState>() , 192usize , concat
               ! ( "Size of: " , stringify ! ( FunctionScanState ) ));
    assert_eq! (::std::mem::align_of::<FunctionScanState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FunctionScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . ss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . eflags as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . ordinality as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( ordinality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . simple as * const
                _ as usize } , 157usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( simple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . ordinal as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( ordinal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . nfuncs as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( nfuncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . funcstates as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( funcstates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionScanState ) ) . argcontext as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionScanState ) ,
                "::" , stringify ! ( argcontext ) ));
}
impl Clone for FunctionScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ValuesScanState() {
    assert_eq!(::std::mem::size_of::<ValuesScanState>() , 176usize , concat !
               ( "Size of: " , stringify ! ( ValuesScanState ) ));
    assert_eq! (::std::mem::align_of::<ValuesScanState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ValuesScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScanState ) ) . rowcontext as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScanState ) ,
                "::" , stringify ! ( rowcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScanState ) ) . exprlists as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScanState ) ,
                "::" , stringify ! ( exprlists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScanState ) ) . array_len as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScanState ) ,
                "::" , stringify ! ( array_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ValuesScanState ) ) . curr_idx as * const
                _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( ValuesScanState ) ,
                "::" , stringify ! ( curr_idx ) ));
}
impl Clone for ValuesScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TableFuncScanState {
    pub ss: ScanState,
    pub docexpr: *mut ExprState,
    pub rowexpr: *mut ExprState,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub ns_names: *mut List,
    pub ns_uris: *mut List,
    pub notnulls: *mut Bitmapset,
    pub opaque: *mut ::std::os::raw::c_void,
    pub routine: *const TableFuncRoutine,
    pub in_functions: *mut FmgrInfo,
    pub typioparams: *mut Oid,
    pub ordinal: int64,
    pub perValueCxt: MemoryContext,
    pub tupstore: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_TableFuncScanState() {
    assert_eq!(::std::mem::size_of::<TableFuncScanState>() , 264usize , concat
               ! ( "Size of: " , stringify ! ( TableFuncScanState ) ));
    assert_eq! (::std::mem::align_of::<TableFuncScanState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TableFuncScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . ss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . docexpr as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( docexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . rowexpr as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( rowexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . colexprs as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( colexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . coldefexprs as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( coldefexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . ns_names as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( ns_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . ns_uris as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( ns_uris ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . notnulls as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( notnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . opaque as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . routine as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . in_functions as
                * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( in_functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . typioparams as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( typioparams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . ordinal as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( ordinal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . perValueCxt as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( perValueCxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableFuncScanState ) ) . tupstore as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( TableFuncScanState ) ,
                "::" , stringify ! ( tupstore ) ));
}
impl Clone for TableFuncScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool_,
}
#[test]
fn bindgen_test_layout_CteScanState() {
    assert_eq!(::std::mem::size_of::<CteScanState>() , 192usize , concat ! (
               "Size of: " , stringify ! ( CteScanState ) ));
    assert_eq! (::std::mem::align_of::<CteScanState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CteScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . eflags as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . readptr as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( readptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . cteplanstate as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( cteplanstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . leader as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( leader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . cte_table as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( cte_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CteScanState ) ) . eof_cte as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( CteScanState ) , "::" ,
                stringify ! ( eof_cte ) ));
}
impl Clone for CteScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NamedTuplestoreScanState {
    pub ss: ScanState,
    pub readptr: ::std::os::raw::c_int,
    pub tupdesc: TupleDesc,
    pub relation: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_NamedTuplestoreScanState() {
    assert_eq!(::std::mem::size_of::<NamedTuplestoreScanState>() , 176usize ,
               concat ! (
               "Size of: " , stringify ! ( NamedTuplestoreScanState ) ));
    assert_eq! (::std::mem::align_of::<NamedTuplestoreScanState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( NamedTuplestoreScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedTuplestoreScanState ) ) . ss as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                NamedTuplestoreScanState ) , "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedTuplestoreScanState ) ) . readptr as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                NamedTuplestoreScanState ) , "::" , stringify ! ( readptr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedTuplestoreScanState ) ) . tupdesc as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                NamedTuplestoreScanState ) , "::" , stringify ! ( tupdesc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NamedTuplestoreScanState ) ) . relation
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                NamedTuplestoreScanState ) , "::" , stringify ! ( relation )
                ));
}
impl Clone for NamedTuplestoreScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
#[test]
fn bindgen_test_layout_WorkTableScanState() {
    assert_eq!(::std::mem::size_of::<WorkTableScanState>() , 160usize , concat
               ! ( "Size of: " , stringify ! ( WorkTableScanState ) ));
    assert_eq! (::std::mem::align_of::<WorkTableScanState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( WorkTableScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WorkTableScanState ) ) . ss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WorkTableScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WorkTableScanState ) ) . rustate as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( WorkTableScanState ) ,
                "::" , stringify ! ( rustate ) ));
}
impl Clone for WorkTableScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: *mut ExprState,
    pub pscan_len: Size,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ForeignScanState() {
    assert_eq!(::std::mem::size_of::<ForeignScanState>() , 184usize , concat !
               ( "Size of: " , stringify ! ( ForeignScanState ) ));
    assert_eq! (::std::mem::align_of::<ForeignScanState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ForeignScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScanState ) ) . fdw_recheck_quals
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScanState ) ,
                "::" , stringify ! ( fdw_recheck_quals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScanState ) ) . pscan_len as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScanState ) ,
                "::" , stringify ! ( pscan_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScanState ) ) . fdwroutine as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScanState ) ,
                "::" , stringify ! ( fdwroutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignScanState ) ) . fdw_state as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignScanState ) ,
                "::" , stringify ! ( fdw_state ) ));
}
impl Clone for ForeignScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomExecMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: *mut List,
    pub pscan_len: Size,
    pub methods: *const CustomExecMethods,
}
#[test]
fn bindgen_test_layout_CustomScanState() {
    assert_eq!(::std::mem::size_of::<CustomScanState>() , 184usize , concat !
               ( "Size of: " , stringify ! ( CustomScanState ) ));
    assert_eq! (::std::mem::align_of::<CustomScanState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CustomScanState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScanState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScanState ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScanState ) ) . flags as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScanState ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScanState ) ) . custom_ps as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScanState ) ,
                "::" , stringify ! ( custom_ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScanState ) ) . pscan_len as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScanState ) ,
                "::" , stringify ! ( pscan_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomScanState ) ) . methods as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomScanState ) ,
                "::" , stringify ! ( methods ) ));
}
impl Clone for CustomScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub single_match: bool_,
    pub joinqual: *mut ExprState,
}
#[test]
fn bindgen_test_layout_JoinState() {
    assert_eq!(::std::mem::size_of::<JoinState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( JoinState ) ));
    assert_eq! (::std::mem::align_of::<JoinState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( JoinState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinState ) ) . ps as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinState ) ) . jointype as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinState ) , "::" ,
                stringify ! ( jointype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinState ) ) . single_match as * const _
                as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinState ) , "::" ,
                stringify ! ( single_match ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinState ) ) . joinqual as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinState ) , "::" ,
                stringify ! ( joinqual ) ));
}
impl Clone for JoinState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool_,
    pub nl_MatchedOuter: bool_,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_NestLoopState() {
    assert_eq!(::std::mem::size_of::<NestLoopState>() , 160usize , concat ! (
               "Size of: " , stringify ! ( NestLoopState ) ));
    assert_eq! (::std::mem::align_of::<NestLoopState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NestLoopState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopState ) ) . js as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopState ) , "::"
                , stringify ! ( js ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopState ) ) . nl_NeedNewOuter as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopState ) , "::"
                , stringify ! ( nl_NeedNewOuter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopState ) ) . nl_MatchedOuter as *
                const _ as usize } , 145usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopState ) , "::"
                , stringify ! ( nl_MatchedOuter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NestLoopState ) ) . nl_NullInnerTupleSlot
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( NestLoopState ) , "::"
                , stringify ! ( nl_NullInnerTupleSlot ) ));
}
impl Clone for NestLoopState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinClauseData {
    _unused: [u8; 0],
}
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Copy)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_SkipMarkRestore: bool_,
    pub mj_ExtraMarks: bool_,
    pub mj_ConstFalseJoin: bool_,
    pub mj_FillOuter: bool_,
    pub mj_FillInner: bool_,
    pub mj_MatchedOuter: bool_,
    pub mj_MatchedInner: bool_,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
#[test]
fn bindgen_test_layout_MergeJoinState() {
    assert_eq!(::std::mem::size_of::<MergeJoinState>() , 232usize , concat ! (
               "Size of: " , stringify ! ( MergeJoinState ) ));
    assert_eq! (::std::mem::align_of::<MergeJoinState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MergeJoinState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . js as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( js ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_NumClauses as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_NumClauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_Clauses as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_Clauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_JoinState as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_JoinState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_SkipMarkRestore
                as * const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_SkipMarkRestore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_ExtraMarks as *
                const _ as usize } , 165usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_ExtraMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_ConstFalseJoin as
                * const _ as usize } , 166usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_ConstFalseJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_FillOuter as *
                const _ as usize } , 167usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_FillOuter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_FillInner as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_FillInner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_MatchedOuter as *
                const _ as usize } , 169usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_MatchedOuter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_MatchedInner as *
                const _ as usize } , 170usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_MatchedInner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_OuterTupleSlot as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_OuterTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_InnerTupleSlot as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_InnerTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_MarkedTupleSlot
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_MarkedTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) .
                mj_NullOuterTupleSlot as * const _ as usize } , 200usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_NullOuterTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) .
                mj_NullInnerTupleSlot as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_NullInnerTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_OuterEContext as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_OuterEContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeJoinState ) ) . mj_InnerEContext as
                * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeJoinState ) , "::"
                , stringify ! ( mj_InnerEContext ) ));
}
impl Clone for MergeJoinState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTupleData {
    _unused: [u8; 0],
}
pub type HashJoinTuple = *mut HashJoinTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTableData {
    _unused: [u8; 0],
}
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Copy)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut ExprState,
    pub hj_OuterHashKeys: *mut List,
    pub hj_InnerHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool_,
    pub hj_OuterNotEmpty: bool_,
}
#[test]
fn bindgen_test_layout_HashJoinState() {
    assert_eq!(::std::mem::size_of::<HashJoinState>() , 256usize , concat ! (
               "Size of: " , stringify ! ( HashJoinState ) ));
    assert_eq! (::std::mem::align_of::<HashJoinState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HashJoinState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . js as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( js ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hashclauses as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hashclauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_OuterHashKeys as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_OuterHashKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_InnerHashKeys as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_InnerHashKeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_HashOperators as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_HashOperators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_HashTable as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_HashTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_CurHashValue as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_CurHashValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_CurBucketNo as *
                const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_CurBucketNo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_CurSkewBucketNo as
                * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_CurSkewBucketNo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_CurTuple as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_CurTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_OuterTupleSlot as
                * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_OuterTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_HashTupleSlot as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_HashTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_NullOuterTupleSlot
                as * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_NullOuterTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_NullInnerTupleSlot
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_NullInnerTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) .
                hj_FirstOuterTupleSlot as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_FirstOuterTupleSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_JoinState as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_JoinState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_MatchedOuter as *
                const _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_MatchedOuter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashJoinState ) ) . hj_OuterNotEmpty as *
                const _ as usize } , 253usize , concat ! (
                "Alignment of field: " , stringify ! ( HashJoinState ) , "::"
                , stringify ! ( hj_OuterNotEmpty ) ));
}
impl Clone for HashJoinState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool_,
    pub tuplestorestate: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_MaterialState() {
    assert_eq!(::std::mem::size_of::<MaterialState>() , 168usize , concat ! (
               "Size of: " , stringify ! ( MaterialState ) ));
    assert_eq! (::std::mem::align_of::<MaterialState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MaterialState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MaterialState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MaterialState ) , "::"
                , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MaterialState ) ) . eflags as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( MaterialState ) , "::"
                , stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MaterialState ) ) . eof_underlying as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( MaterialState ) , "::"
                , stringify ! ( eof_underlying ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MaterialState ) ) . tuplestorestate as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( MaterialState ) , "::"
                , stringify ! ( tuplestorestate ) ));
}
impl Clone for MaterialState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool_,
    pub bounded: bool_,
    pub bound: int64,
    pub sort_Done: bool_,
    pub bounded_Done: bool_,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SortState() {
    assert_eq!(::std::mem::size_of::<SortState>() , 192usize , concat ! (
               "Size of: " , stringify ! ( SortState ) ));
    assert_eq! (::std::mem::align_of::<SortState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SortState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . ss as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . randomAccess as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( randomAccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . bounded as * const _ as
                usize } , 153usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( bounded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . bound as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( bound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . sort_Done as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( sort_Done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . bounded_Done as * const _
                as usize } , 169usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( bounded_Done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . bound_Done as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( bound_Done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortState ) ) . tuplesortstate as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( SortState ) , "::" ,
                stringify ! ( tuplesortstate ) ));
}
impl Clone for SortState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunctions: *mut FmgrInfo,
    pub grp_done: bool_,
}
#[test]
fn bindgen_test_layout_GroupState() {
    assert_eq!(::std::mem::size_of::<GroupState>() , 168usize , concat ! (
               "Size of: " , stringify ! ( GroupState ) ));
    assert_eq! (::std::mem::align_of::<GroupState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GroupState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupState ) ) . ss as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupState ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupState ) ) . eqfunctions as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupState ) , "::" ,
                stringify ! ( eqfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupState ) ) . grp_done as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupState ) , "::" ,
                stringify ! ( grp_done ) ));
}
impl Clone for GroupState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerAggData {
    _unused: [u8; 0],
}
pub type AggStatePerAgg = *mut AggStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerTransData {
    _unused: [u8; 0],
}
pub type AggStatePerTrans = *mut AggStatePerTransData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerGroupData {
    _unused: [u8; 0],
}
pub type AggStatePerGroup = *mut AggStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerPhaseData {
    _unused: [u8; 0],
}
pub type AggStatePerPhase = *mut AggStatePerPhaseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerHashData {
    _unused: [u8; 0],
}
pub type AggStatePerHash = *mut AggStatePerHashData;
#[repr(C)]
#[derive(Copy)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::std::os::raw::c_int,
    pub numtrans: ::std::os::raw::c_int,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub phase: AggStatePerPhase,
    pub numphases: ::std::os::raw::c_int,
    pub current_phase: ::std::os::raw::c_int,
    pub peragg: AggStatePerAgg,
    pub pertrans: AggStatePerTrans,
    pub hashcontext: *mut ExprContext,
    pub aggcontexts: *mut *mut ExprContext,
    pub tmpcontext: *mut ExprContext,
    pub curaggcontext: *mut ExprContext,
    pub curpertrans: AggStatePerTrans,
    pub input_done: bool_,
    pub agg_done: bool_,
    pub projected_set: ::std::os::raw::c_int,
    pub current_set: ::std::os::raw::c_int,
    pub grouped_cols: *mut Bitmapset,
    pub all_grouped_cols: *mut List,
    pub maxsets: ::std::os::raw::c_int,
    pub phases: AggStatePerPhase,
    pub sort_in: *mut Tuplesortstate,
    pub sort_out: *mut Tuplesortstate,
    pub sort_slot: *mut TupleTableSlot,
    pub pergroup: AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub table_filled: bool_,
    pub num_hashes: ::std::os::raw::c_int,
    pub perhash: AggStatePerHash,
    pub hash_pergroup: *mut AggStatePerGroup,
    pub evalslot: *mut TupleTableSlot,
    pub evalproj: *mut ProjectionInfo,
    pub evaldesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_AggState() {
    assert_eq!(::std::mem::size_of::<AggState>() , 384usize , concat ! (
               "Size of: " , stringify ! ( AggState ) ));
    assert_eq! (::std::mem::align_of::<AggState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AggState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . ss as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . aggs as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( aggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . numaggs as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( numaggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . numtrans as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( numtrans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . aggstrategy as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( aggstrategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . aggsplit as * const _ as
                usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( aggsplit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . phase as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( phase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . numphases as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( numphases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . current_phase as * const _
                as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( current_phase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . peragg as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( peragg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . pertrans as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( pertrans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . hashcontext as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( hashcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . aggcontexts as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( aggcontexts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . tmpcontext as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( tmpcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . curaggcontext as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( curaggcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . curpertrans as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( curpertrans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . input_done as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( input_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . agg_done as * const _ as
                usize } , 249usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( agg_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . projected_set as * const _
                as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( projected_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . current_set as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( current_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . grouped_cols as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( grouped_cols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . all_grouped_cols as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( all_grouped_cols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . maxsets as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( maxsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . phases as * const _ as
                usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( phases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . sort_in as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( sort_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . sort_out as * const _ as
                usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( sort_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . sort_slot as * const _ as
                usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( sort_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . pergroup as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( pergroup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . grp_firstTuple as * const
                _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( grp_firstTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . table_filled as * const _
                as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( table_filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . num_hashes as * const _ as
                usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( num_hashes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . perhash as * const _ as
                usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( perhash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . hash_pergroup as * const _
                as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( hash_pergroup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . evalslot as * const _ as
                usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( evalslot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . evalproj as * const _ as
                usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( evalproj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggState ) ) . evaldesc as * const _ as
                usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( AggState ) , "::" ,
                stringify ! ( evaldesc ) ));
}
impl Clone for AggState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerFuncData {
    _unused: [u8; 0],
}
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerAggData {
    _unused: [u8; 0],
}
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
#[repr(C)]
#[derive(Copy)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunctions: *mut FmgrInfo,
    pub ordEqfunctions: *mut FmgrInfo,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub curaggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub all_first: bool_,
    pub all_done: bool_,
    pub partition_spooled: bool_,
    pub more_partitions: bool_,
    pub framehead_valid: bool_,
    pub frametail_valid: bool_,
    pub first_part_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_WindowAggState() {
    assert_eq!(::std::mem::size_of::<WindowAggState>() , 384usize , concat ! (
               "Size of: " , stringify ! ( WindowAggState ) ));
    assert_eq! (::std::mem::align_of::<WindowAggState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WindowAggState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . ss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . funcs as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . numfuncs as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( numfuncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . numaggs as * const _
                as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( numaggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . perfunc as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( perfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . peragg as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( peragg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . partEqfunctions as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( partEqfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . ordEqfunctions as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( ordEqfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . buffer as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . current_ptr as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( current_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . spooled_rows as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( spooled_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . currentpos as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( currentpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . frameheadpos as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( frameheadpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . frametailpos as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( frametailpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . agg_winobj as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( agg_winobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . aggregatedbase as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( aggregatedbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . aggregatedupto as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( aggregatedupto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . frameOptions as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( frameOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . startOffset as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( startOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . endOffset as * const
                _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( endOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . startOffsetValue as
                * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( startOffsetValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . endOffsetValue as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( endOffsetValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . partcontext as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( partcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . aggcontext as *
                const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( aggcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . curaggcontext as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( curaggcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . tmpcontext as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( tmpcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . all_first as * const
                _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( all_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . all_done as * const
                _ as usize } , 345usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( all_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . partition_spooled as
                * const _ as usize } , 346usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( partition_spooled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . more_partitions as *
                const _ as usize } , 347usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( more_partitions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . framehead_valid as *
                const _ as usize } , 348usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( framehead_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . frametail_valid as *
                const _ as usize } , 349usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( frametail_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . first_part_slot as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( first_part_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . agg_row_slot as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( agg_row_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . temp_slot_1 as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( temp_slot_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggState ) ) . temp_slot_2 as *
                const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggState ) , "::"
                , stringify ! ( temp_slot_2 ) ));
}
impl Clone for WindowAggState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
}
#[test]
fn bindgen_test_layout_UniqueState() {
    assert_eq!(::std::mem::size_of::<UniqueState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( UniqueState ) ));
    assert_eq! (::std::mem::align_of::<UniqueState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( UniqueState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniqueState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UniqueState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniqueState ) ) . eqfunctions as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( UniqueState ) , "::" ,
                stringify ! ( eqfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniqueState ) ) . tempContext as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( UniqueState ) , "::" ,
                stringify ! ( tempContext ) ));
}
impl Clone for UniqueState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool_,
    pub need_to_scan_locally: bool_,
    pub funnel_slot: *mut TupleTableSlot,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub nextreader: ::std::os::raw::c_int,
    pub reader: *mut *mut TupleQueueReader,
}
#[test]
fn bindgen_test_layout_GatherState() {
    assert_eq!(::std::mem::size_of::<GatherState>() , 176usize , concat ! (
               "Size of: " , stringify ! ( GatherState ) ));
    assert_eq! (::std::mem::align_of::<GatherState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GatherState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . initialized as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . need_to_scan_locally as
                * const _ as usize } , 129usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( need_to_scan_locally ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . funnel_slot as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( funnel_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . pei as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( pei ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . nworkers_launched as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( nworkers_launched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . nreaders as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( nreaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . nextreader as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( nextreader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherState ) ) . reader as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherState ) , "::" ,
                stringify ! ( reader ) ));
}
impl Clone for GatherState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GMReaderTupleBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct GatherMergeState {
    pub ps: PlanState,
    pub initialized: bool_,
    pub gm_initialized: bool_,
    pub need_to_scan_locally: bool_,
    pub tupDesc: TupleDesc,
    pub gm_nkeys: ::std::os::raw::c_int,
    pub gm_sortkeys: SortSupport,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub gm_slots: *mut *mut TupleTableSlot,
    pub reader: *mut *mut TupleQueueReader,
    pub gm_tuple_buffers: *mut GMReaderTupleBuffer,
    pub gm_heap: *mut binaryheap,
}
#[test]
fn bindgen_test_layout_GatherMergeState() {
    assert_eq!(::std::mem::size_of::<GatherMergeState>() , 208usize , concat !
               ( "Size of: " , stringify ! ( GatherMergeState ) ));
    assert_eq! (::std::mem::align_of::<GatherMergeState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( GatherMergeState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . initialized as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . gm_initialized as
                * const _ as usize } , 129usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( gm_initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) .
                need_to_scan_locally as * const _ as usize } , 130usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( need_to_scan_locally ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . tupDesc as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( tupDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . gm_nkeys as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( gm_nkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . gm_sortkeys as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( gm_sortkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . pei as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( pei ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . nworkers_launched
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( nworkers_launched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . nreaders as *
                const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( nreaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . gm_slots as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( gm_slots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . reader as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( reader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . gm_tuple_buffers
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( gm_tuple_buffers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergeState ) ) . gm_heap as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergeState ) ,
                "::" , stringify ! ( gm_heap ) ));
}
impl Clone for GatherMergeState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
}
#[test]
fn bindgen_test_layout_HashState() {
    assert_eq!(::std::mem::size_of::<HashState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( HashState ) ));
    assert_eq! (::std::mem::align_of::<HashState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HashState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashState ) ) . ps as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HashState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashState ) ) . hashtable as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( HashState ) , "::" ,
                stringify ! ( hashtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashState ) ) . hashkeys as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( HashState ) , "::" ,
                stringify ! ( hashkeys ) ));
}
impl Clone for HashState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpStatePerGroupData {
    _unused: [u8; 0],
}
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Copy)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool_,
    pub numOutput: ::std::os::raw::c_long,
    pub tempContext: MemoryContext,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool_,
    pub hashiter: TupleHashIterator,
}
#[test]
fn bindgen_test_layout_SetOpState() {
    assert_eq!(::std::mem::size_of::<SetOpState>() , 216usize , concat ! (
               "Size of: " , stringify ! ( SetOpState ) ));
    assert_eq! (::std::mem::align_of::<SetOpState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SetOpState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . ps as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . eqfunctions as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( eqfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . hashfunctions as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( hashfunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . setop_done as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( setop_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . numOutput as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( numOutput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . tempContext as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( tempContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . pergroup as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( pergroup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . grp_firstTuple as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( grp_firstTuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . hashtable as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( hashtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . tableContext as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( tableContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . table_filled as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( table_filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpState ) ) . hashiter as * const _ as
                usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpState ) , "::" ,
                stringify ! ( hashiter ) ));
}
impl Clone for SetOpState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
    pub lr_curtuples: *mut HeapTuple,
    pub lr_ntables: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRowsState() {
    assert_eq!(::std::mem::size_of::<LockRowsState>() , 200usize , concat ! (
               "Size of: " , stringify ! ( LockRowsState ) ));
    assert_eq! (::std::mem::align_of::<LockRowsState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockRowsState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsState ) ) . ps as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsState ) , "::"
                , stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsState ) ) . lr_arowMarks as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsState ) , "::"
                , stringify ! ( lr_arowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsState ) ) . lr_epqstate as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsState ) , "::"
                , stringify ! ( lr_epqstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsState ) ) . lr_curtuples as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsState ) , "::"
                , stringify ! ( lr_curtuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsState ) ) . lr_ntables as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsState ) , "::"
                , stringify ! ( lr_ntables ) ));
}
impl Clone for LockRowsState {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LimitStateCond {
    LIMIT_INITIAL = 0,
    LIMIT_RESCAN = 1,
    LIMIT_EMPTY = 2,
    LIMIT_INWINDOW = 3,
    LIMIT_SUBPLANEOF = 4,
    LIMIT_WINDOWEND = 5,
    LIMIT_WINDOWSTART = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool_,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_LimitState() {
    assert_eq!(::std::mem::size_of::<LimitState>() , 184usize , concat ! (
               "Size of: " , stringify ! ( LimitState ) ));
    assert_eq! (::std::mem::align_of::<LimitState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LimitState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . ps as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( ps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . limitOffset as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( limitOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . limitCount as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( limitCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . count as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . noCount as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( noCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . lstate as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( lstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . position as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitState ) ) . subSlot as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitState ) , "::" ,
                stringify ! ( subSlot ) ));
}
impl Clone for LimitState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Value {
    pub type_: NodeTag,
    pub val: Value_ValUnion,
}
#[repr(C)]
#[derive(Copy)]
pub union Value_ValUnion {
    pub ival: ::std::os::raw::c_long,
    pub str: *mut ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Value_ValUnion() {
    assert_eq!(::std::mem::size_of::<Value_ValUnion>() , 8usize , concat ! (
               "Size of: " , stringify ! ( Value_ValUnion ) ));
    assert_eq! (::std::mem::align_of::<Value_ValUnion>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Value_ValUnion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Value_ValUnion ) ) . ival as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Value_ValUnion ) , "::"
                , stringify ! ( ival ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Value_ValUnion ) ) . str as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Value_ValUnion ) , "::"
                , stringify ! ( str ) ));
}
impl Clone for Value_ValUnion {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(::std::mem::size_of::<Value>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Value ) ));
    assert_eq! (::std::mem::align_of::<Value>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Value ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Value ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Value ) ) . val as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( Value ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for Value {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn makeInteger(i: ::std::os::raw::c_long) -> *mut Value;
}
extern "C" {
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
}
extern "C" {
    pub fn makeString(str: *mut ::std::os::raw::c_char) -> *mut Value;
}
extern "C" {
    pub fn makeBitString(str: *mut ::std::os::raw::c_char) -> *mut Value;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OverridingKind {
    OVERRIDING_NOT_SET = 0,
    OVERRIDING_USER_VALUE = 1,
    OVERRIDING_SYSTEM_VALUE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum QuerySource {
    QSRC_ORIGINAL = 0,
    QSRC_PARSER = 1,
    QSRC_INSTEAD_RULE = 2,
    QSRC_QUAL_INSTEAD_RULE = 3,
    QSRC_NON_INSTEAD_RULE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SortByDir {
    SORTBY_DEFAULT = 0,
    SORTBY_ASC = 1,
    SORTBY_DESC = 2,
    SORTBY_USING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SortByNulls {
    SORTBY_NULLS_DEFAULT = 0,
    SORTBY_NULLS_FIRST = 1,
    SORTBY_NULLS_LAST = 2,
}
pub type AclMode = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint32,
    pub canSetTag: bool_,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool_,
    pub hasWindowFuncs: bool_,
    pub hasTargetSRFs: bool_,
    pub hasSubLinks: bool_,
    pub hasDistinctOn: bool_,
    pub hasRecursive: bool_,
    pub hasModifyingCTE: bool_,
    pub hasForUpdate: bool_,
    pub hasRowSecurity: bool_,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub override_: OverridingKind,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Query() {
    assert_eq!(::std::mem::size_of::<Query>() , 208usize , concat ! (
               "Size of: " , stringify ! ( Query ) ));
    assert_eq! (::std::mem::align_of::<Query>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . commandType as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( commandType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . querySource as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( querySource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . queryId as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( queryId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . canSetTag as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( canSetTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . utilityStmt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( utilityStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . resultRelation as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( resultRelation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasAggs as * const _ as usize
                } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasAggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasWindowFuncs as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasWindowFuncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasTargetSRFs as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasTargetSRFs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasSubLinks as * const _ as
                usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasSubLinks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasDistinctOn as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasDistinctOn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasRecursive as * const _ as
                usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasRecursive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasModifyingCTE as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasModifyingCTE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasForUpdate as * const _ as
                usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasForUpdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . hasRowSecurity as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( hasRowSecurity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . cteList as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( cteList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . rtable as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( rtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . jointree as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( jointree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . targetList as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( targetList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . override_ as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( override_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . onConflict as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( onConflict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . returningList as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( returningList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . groupClause as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( groupClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . groupingSets as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( groupingSets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . havingQual as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( havingQual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . windowClause as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( windowClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . distinctClause as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( distinctClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . sortClause as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( sortClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . limitOffset as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( limitOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . limitCount as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( limitCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . rowMarks as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . setOperations as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( setOperations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . constraintDeps as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( constraintDeps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . withCheckOptions as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( withCheckOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . stmt_location as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( stmt_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Query ) ) . stmt_len as * const _ as
                usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( Query ) , "::" ,
                stringify ! ( stmt_len ) ));
}
impl Clone for Query {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool_,
    pub pct_type: bool_,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TypeName() {
    assert_eq!(::std::mem::size_of::<TypeName>() , 56usize , concat ! (
               "Size of: " , stringify ! ( TypeName ) ));
    assert_eq! (::std::mem::align_of::<TypeName>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TypeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . names as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . typeOid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( typeOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . setof as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( setof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . pct_type as * const _ as
                usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( pct_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . typmods as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( typmods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . typemod as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( typemod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . arrayBounds as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( arrayBounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeName ) ) . location as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeName ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for TypeName {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ColumnRef() {
    assert_eq!(::std::mem::size_of::<ColumnRef>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ColumnRef ) ));
    assert_eq! (::std::mem::align_of::<ColumnRef>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ColumnRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnRef ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnRef ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnRef ) ) . fields as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnRef ) , "::" ,
                stringify ! ( fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnRef ) ) . location as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnRef ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for ColumnRef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ParamRef() {
    assert_eq!(::std::mem::size_of::<ParamRef>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ParamRef ) ));
    assert_eq! (::std::mem::align_of::<ParamRef>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ParamRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamRef ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamRef ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamRef ) ) . number as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamRef ) , "::" ,
                stringify ! ( number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamRef ) ) . location as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamRef ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for ParamRef {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum A_Expr_Kind {
    AEXPR_OP = 0,
    AEXPR_OP_ANY = 1,
    AEXPR_OP_ALL = 2,
    AEXPR_DISTINCT = 3,
    AEXPR_NOT_DISTINCT = 4,
    AEXPR_NULLIF = 5,
    AEXPR_OF = 6,
    AEXPR_IN = 7,
    AEXPR_LIKE = 8,
    AEXPR_ILIKE = 9,
    AEXPR_SIMILAR = 10,
    AEXPR_BETWEEN = 11,
    AEXPR_NOT_BETWEEN = 12,
    AEXPR_BETWEEN_SYM = 13,
    AEXPR_NOT_BETWEEN_SYM = 14,
    AEXPR_PAREN = 15,
}
#[repr(C)]
#[derive(Copy)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_Expr() {
    assert_eq!(::std::mem::size_of::<A_Expr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( A_Expr ) ));
    assert_eq! (::std::mem::align_of::<A_Expr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( A_Expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Expr ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Expr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Expr ) ) . kind as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Expr ) , "::" ,
                stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Expr ) ) . name as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Expr ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Expr ) ) . lexpr as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Expr ) , "::" ,
                stringify ! ( lexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Expr ) ) . rexpr as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Expr ) , "::" ,
                stringify ! ( rexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Expr ) ) . location as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Expr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for A_Expr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_Const() {
    assert_eq!(::std::mem::size_of::<A_Const>() , 32usize , concat ! (
               "Size of: " , stringify ! ( A_Const ) ));
    assert_eq! (::std::mem::align_of::<A_Const>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( A_Const ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Const ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Const ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Const ) ) . val as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Const ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Const ) ) . location as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Const ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for A_Const {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TypeCast() {
    assert_eq!(::std::mem::size_of::<TypeCast>() , 32usize , concat ! (
               "Size of: " , stringify ! ( TypeCast ) ));
    assert_eq! (::std::mem::align_of::<TypeCast>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TypeCast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeCast ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeCast ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeCast ) ) . arg as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeCast ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeCast ) ) . typeName as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeCast ) , "::" ,
                stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TypeCast ) ) . location as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TypeCast ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for TypeCast {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CollateClause() {
    assert_eq!(::std::mem::size_of::<CollateClause>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CollateClause ) ));
    assert_eq! (::std::mem::align_of::<CollateClause>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CollateClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateClause ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateClause ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateClause ) , "::"
                , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateClause ) ) . collname as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateClause ) , "::"
                , stringify ! ( collname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CollateClause ) ) . location as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CollateClause ) , "::"
                , stringify ! ( location ) ));
}
impl Clone for CollateClause {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RoleSpecType {
    ROLESPEC_CSTRING = 0,
    ROLESPEC_CURRENT_USER = 1,
    ROLESPEC_SESSION_USER = 2,
    ROLESPEC_PUBLIC = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RoleSpec() {
    assert_eq!(::std::mem::size_of::<RoleSpec>() , 24usize , concat ! (
               "Size of: " , stringify ! ( RoleSpec ) ));
    assert_eq! (::std::mem::align_of::<RoleSpec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RoleSpec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RoleSpec ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RoleSpec ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RoleSpec ) ) . roletype as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RoleSpec ) , "::" ,
                stringify ! ( roletype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RoleSpec ) ) . rolename as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RoleSpec ) , "::" ,
                stringify ! ( rolename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RoleSpec ) ) . location as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RoleSpec ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for RoleSpec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: bool_,
    pub agg_star: bool_,
    pub agg_distinct: bool_,
    pub func_variadic: bool_,
    pub over: *mut WindowDef,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FuncCall() {
    assert_eq!(::std::mem::size_of::<FuncCall>() , 64usize , concat ! (
               "Size of: " , stringify ! ( FuncCall ) ));
    assert_eq! (::std::mem::align_of::<FuncCall>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FuncCall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . funcname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( funcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . args as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . agg_order as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( agg_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . agg_filter as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( agg_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . agg_within_group as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( agg_within_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . agg_star as * const _ as
                usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( agg_star ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . agg_distinct as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( agg_distinct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . func_variadic as * const _
                as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( func_variadic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . over as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( over ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FuncCall ) ) . location as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FuncCall ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for FuncCall {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct A_Star {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_A_Star() {
    assert_eq!(::std::mem::size_of::<A_Star>() , 4usize , concat ! (
               "Size of: " , stringify ! ( A_Star ) ));
    assert_eq! (::std::mem::align_of::<A_Star>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( A_Star ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Star ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Star ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for A_Star {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool_,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
#[test]
fn bindgen_test_layout_A_Indices() {
    assert_eq!(::std::mem::size_of::<A_Indices>() , 24usize , concat ! (
               "Size of: " , stringify ! ( A_Indices ) ));
    assert_eq! (::std::mem::align_of::<A_Indices>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( A_Indices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indices ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indices ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indices ) ) . is_slice as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indices ) , "::" ,
                stringify ! ( is_slice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indices ) ) . lidx as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indices ) , "::" ,
                stringify ! ( lidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indices ) ) . uidx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indices ) , "::" ,
                stringify ! ( uidx ) ));
}
impl Clone for A_Indices {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
#[test]
fn bindgen_test_layout_A_Indirection() {
    assert_eq!(::std::mem::size_of::<A_Indirection>() , 24usize , concat ! (
               "Size of: " , stringify ! ( A_Indirection ) ));
    assert_eq! (::std::mem::align_of::<A_Indirection>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( A_Indirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indirection ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indirection ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indirection ) ) . arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indirection ) , "::"
                , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_Indirection ) ) . indirection as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( A_Indirection ) , "::"
                , stringify ! ( indirection ) ));
}
impl Clone for A_Indirection {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_ArrayExpr() {
    assert_eq!(::std::mem::size_of::<A_ArrayExpr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( A_ArrayExpr ) ));
    assert_eq! (::std::mem::align_of::<A_ArrayExpr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( A_ArrayExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_ArrayExpr ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( A_ArrayExpr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_ArrayExpr ) ) . elements as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( A_ArrayExpr ) , "::" ,
                stringify ! ( elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const A_ArrayExpr ) ) . location as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( A_ArrayExpr ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for A_ArrayExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ResTarget() {
    assert_eq!(::std::mem::size_of::<ResTarget>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ResTarget ) ));
    assert_eq! (::std::mem::align_of::<ResTarget>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ResTarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResTarget ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ResTarget ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResTarget ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ResTarget ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResTarget ) ) . indirection as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ResTarget ) , "::" ,
                stringify ! ( indirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResTarget ) ) . val as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ResTarget ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResTarget ) ) . location as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ResTarget ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for ResTarget {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: *mut Node,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MultiAssignRef() {
    assert_eq!(::std::mem::size_of::<MultiAssignRef>() , 24usize , concat ! (
               "Size of: " , stringify ! ( MultiAssignRef ) ));
    assert_eq! (::std::mem::align_of::<MultiAssignRef>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MultiAssignRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MultiAssignRef ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MultiAssignRef ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MultiAssignRef ) ) . source as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MultiAssignRef ) , "::"
                , stringify ! ( source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MultiAssignRef ) ) . colno as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MultiAssignRef ) , "::"
                , stringify ! ( colno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MultiAssignRef ) ) . ncolumns as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( MultiAssignRef ) , "::"
                , stringify ! ( ncolumns ) ));
}
impl Clone for MultiAssignRef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SortBy() {
    assert_eq!(::std::mem::size_of::<SortBy>() , 40usize , concat ! (
               "Size of: " , stringify ! ( SortBy ) ));
    assert_eq! (::std::mem::align_of::<SortBy>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SortBy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortBy ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SortBy ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortBy ) ) . node as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SortBy ) , "::" ,
                stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortBy ) ) . sortby_dir as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SortBy ) , "::" ,
                stringify ! ( sortby_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortBy ) ) . sortby_nulls as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SortBy ) , "::" ,
                stringify ! ( sortby_nulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortBy ) ) . useOp as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SortBy ) , "::" ,
                stringify ! ( useOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortBy ) ) . location as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SortBy ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for SortBy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowDef() {
    assert_eq!(::std::mem::size_of::<WindowDef>() , 72usize , concat ! (
               "Size of: " , stringify ! ( WindowDef ) ));
    assert_eq! (::std::mem::align_of::<WindowDef>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WindowDef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . refname as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( refname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . partitionClause as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( partitionClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . orderClause as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( orderClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . frameOptions as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( frameOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . startOffset as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( startOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . endOffset as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( endOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowDef ) ) . location as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowDef ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for WindowDef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
#[test]
fn bindgen_test_layout_RangeSubselect() {
    assert_eq!(::std::mem::size_of::<RangeSubselect>() , 24usize , concat ! (
               "Size of: " , stringify ! ( RangeSubselect ) ));
    assert_eq! (::std::mem::align_of::<RangeSubselect>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RangeSubselect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeSubselect ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeSubselect ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeSubselect ) ) . lateral as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeSubselect ) , "::"
                , stringify ! ( lateral ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeSubselect ) ) . subquery as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeSubselect ) , "::"
                , stringify ! ( subquery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeSubselect ) ) . alias as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeSubselect ) , "::"
                , stringify ! ( alias ) ));
}
impl Clone for RangeSubselect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub ordinality: bool_,
    pub is_rowsfrom: bool_,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
#[test]
fn bindgen_test_layout_RangeFunction() {
    assert_eq!(::std::mem::size_of::<RangeFunction>() , 32usize , concat ! (
               "Size of: " , stringify ! ( RangeFunction ) ));
    assert_eq! (::std::mem::align_of::<RangeFunction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RangeFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . lateral as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( lateral ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . ordinality as * const
                _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( ordinality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . is_rowsfrom as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( is_rowsfrom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . functions as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . alias as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeFunction ) ) . coldeflist as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeFunction ) , "::"
                , stringify ! ( coldeflist ) ));
}
impl Clone for RangeFunction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeTableFunc {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub namespaces: *mut List,
    pub columns: *mut List,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableFunc() {
    assert_eq!(::std::mem::size_of::<RangeTableFunc>() , 56usize , concat ! (
               "Size of: " , stringify ! ( RangeTableFunc ) ));
    assert_eq! (::std::mem::align_of::<RangeTableFunc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RangeTableFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . lateral as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( lateral ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . docexpr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( docexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . rowexpr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( rowexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . namespaces as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( namespaces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . columns as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( columns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . alias as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFunc ) ) . location as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFunc ) , "::"
                , stringify ! ( location ) ));
}
impl Clone for RangeTableFunc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeTableFuncCol {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub for_ordinality: bool_,
    pub is_not_null: bool_,
    pub colexpr: *mut Node,
    pub coldefexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableFuncCol() {
    assert_eq!(::std::mem::size_of::<RangeTableFuncCol>() , 56usize , concat !
               ( "Size of: " , stringify ! ( RangeTableFuncCol ) ));
    assert_eq! (::std::mem::align_of::<RangeTableFuncCol>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( RangeTableFuncCol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . colname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( colname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . typeName as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . for_ordinality as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( for_ordinality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . is_not_null as *
                const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( is_not_null ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . colexpr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( colexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . coldefexpr as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( coldefexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableFuncCol ) ) . location as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableFuncCol ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for RangeTableFuncCol {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableSample() {
    assert_eq!(::std::mem::size_of::<RangeTableSample>() , 48usize , concat !
               ( "Size of: " , stringify ! ( RangeTableSample ) ));
    assert_eq! (::std::mem::align_of::<RangeTableSample>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( RangeTableSample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableSample ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableSample ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableSample ) ) . relation as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableSample ) ,
                "::" , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableSample ) ) . method as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableSample ) ,
                "::" , stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableSample ) ) . args as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableSample ) ,
                "::" , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableSample ) ) . repeatable as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableSample ) ,
                "::" , stringify ! ( repeatable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTableSample ) ) . location as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTableSample ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for RangeTableSample {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool_,
    pub is_not_null: bool_,
    pub is_from_type: bool_,
    pub is_from_parent: bool_,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub identity: ::std::os::raw::c_char,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ColumnDef() {
    assert_eq!(::std::mem::size_of::<ColumnDef>() , 104usize , concat ! (
               "Size of: " , stringify ! ( ColumnDef ) ));
    assert_eq! (::std::mem::align_of::<ColumnDef>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ColumnDef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . colname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( colname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . typeName as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . inhcount as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( inhcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . is_local as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( is_local ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . is_not_null as * const _
                as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( is_not_null ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . is_from_type as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( is_from_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . is_from_parent as * const
                _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( is_from_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . storage as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . raw_default as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( raw_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . cooked_default as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( cooked_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . identity as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( identity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . collClause as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( collClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . collOid as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( collOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . constraints as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . fdwoptions as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( fdwoptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ColumnDef ) ) . location as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ColumnDef ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for ColumnDef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
#[test]
fn bindgen_test_layout_TableLikeClause() {
    assert_eq!(::std::mem::size_of::<TableLikeClause>() , 24usize , concat ! (
               "Size of: " , stringify ! ( TableLikeClause ) ));
    assert_eq! (::std::mem::align_of::<TableLikeClause>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TableLikeClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableLikeClause ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TableLikeClause ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableLikeClause ) ) . relation as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TableLikeClause ) ,
                "::" , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableLikeClause ) ) . options as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TableLikeClause ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for TableLikeClause {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TableLikeOption {
    CREATE_TABLE_LIKE_DEFAULTS = 1,
    CREATE_TABLE_LIKE_CONSTRAINTS = 2,
    CREATE_TABLE_LIKE_IDENTITY = 4,
    CREATE_TABLE_LIKE_INDEXES = 8,
    CREATE_TABLE_LIKE_STORAGE = 16,
    CREATE_TABLE_LIKE_COMMENTS = 32,
    CREATE_TABLE_LIKE_ALL = 2147483647,
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
#[test]
fn bindgen_test_layout_IndexElem() {
    assert_eq!(::std::mem::size_of::<IndexElem>() , 56usize , concat ! (
               "Size of: " , stringify ! ( IndexElem ) ));
    assert_eq! (::std::mem::align_of::<IndexElem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexElem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . expr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . indexcolname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( indexcolname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . collation as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . opclass as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( opclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . ordering as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( ordering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexElem ) ) . nulls_ordering as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexElem ) , "::" ,
                stringify ! ( nulls_ordering ) ));
}
impl Clone for IndexElem {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DefElemAction {
    DEFELEM_UNSPEC = 0,
    DEFELEM_SET = 1,
    DEFELEM_ADD = 2,
    DEFELEM_DROP = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DefElem() {
    assert_eq!(::std::mem::size_of::<DefElem>() , 40usize , concat ! (
               "Size of: " , stringify ! ( DefElem ) ));
    assert_eq! (::std::mem::align_of::<DefElem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DefElem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefElem ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DefElem ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefElem ) ) . defnamespace as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DefElem ) , "::" ,
                stringify ! ( defnamespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefElem ) ) . defname as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DefElem ) , "::" ,
                stringify ! ( defname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefElem ) ) . arg as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DefElem ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefElem ) ) . defaction as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( DefElem ) , "::" ,
                stringify ! ( defaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefElem ) ) . location as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( DefElem ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for DefElem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
#[test]
fn bindgen_test_layout_LockingClause() {
    assert_eq!(::std::mem::size_of::<LockingClause>() , 24usize , concat ! (
               "Size of: " , stringify ! ( LockingClause ) ));
    assert_eq! (::std::mem::align_of::<LockingClause>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockingClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockingClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockingClause ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockingClause ) ) . lockedRels as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LockingClause ) , "::"
                , stringify ! ( lockedRels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockingClause ) ) . strength as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LockingClause ) , "::"
                , stringify ! ( strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockingClause ) ) . waitPolicy as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( LockingClause ) , "::"
                , stringify ! ( waitPolicy ) ));
}
impl Clone for LockingClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XmlSerialize() {
    assert_eq!(::std::mem::size_of::<XmlSerialize>() , 32usize , concat ! (
               "Size of: " , stringify ! ( XmlSerialize ) ));
    assert_eq! (::std::mem::align_of::<XmlSerialize>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( XmlSerialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlSerialize ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlSerialize ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlSerialize ) ) . xmloption as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlSerialize ) , "::" ,
                stringify ! ( xmloption ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlSerialize ) ) . expr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlSerialize ) , "::" ,
                stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlSerialize ) ) . typeName as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlSerialize ) , "::" ,
                stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XmlSerialize ) ) . location as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( XmlSerialize ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for XmlSerialize {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionElem() {
    assert_eq!(::std::mem::size_of::<PartitionElem>() , 48usize , concat ! (
               "Size of: " , stringify ! ( PartitionElem ) ));
    assert_eq! (::std::mem::align_of::<PartitionElem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PartitionElem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionElem ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionElem ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionElem ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionElem ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionElem ) ) . expr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionElem ) , "::"
                , stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionElem ) ) . collation as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionElem ) , "::"
                , stringify ! ( collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionElem ) ) . opclass as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionElem ) , "::"
                , stringify ! ( opclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionElem ) ) . location as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionElem ) , "::"
                , stringify ! ( location ) ));
}
impl Clone for PartitionElem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionSpec {
    pub type_: NodeTag,
    pub strategy: *mut ::std::os::raw::c_char,
    pub partParams: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionSpec() {
    assert_eq!(::std::mem::size_of::<PartitionSpec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( PartitionSpec ) ));
    assert_eq! (::std::mem::align_of::<PartitionSpec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PartitionSpec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionSpec ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionSpec ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionSpec ) ) . strategy as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionSpec ) , "::"
                , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionSpec ) ) . partParams as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionSpec ) , "::"
                , stringify ! ( partParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionSpec ) ) . location as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionSpec ) , "::"
                , stringify ! ( location ) ));
}
impl Clone for PartitionSpec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionBoundSpec {
    pub type_: NodeTag,
    pub strategy: ::std::os::raw::c_char,
    pub listdatums: *mut List,
    pub lowerdatums: *mut List,
    pub upperdatums: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionBoundSpec() {
    assert_eq!(::std::mem::size_of::<PartitionBoundSpec>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( PartitionBoundSpec ) ));
    assert_eq! (::std::mem::align_of::<PartitionBoundSpec>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( PartitionBoundSpec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionBoundSpec ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionBoundSpec ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionBoundSpec ) ) . strategy as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionBoundSpec ) ,
                "::" , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionBoundSpec ) ) . listdatums as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionBoundSpec ) ,
                "::" , stringify ! ( listdatums ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionBoundSpec ) ) . lowerdatums as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionBoundSpec ) ,
                "::" , stringify ! ( lowerdatums ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionBoundSpec ) ) . upperdatums as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionBoundSpec ) ,
                "::" , stringify ! ( upperdatums ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionBoundSpec ) ) . location as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionBoundSpec ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for PartitionBoundSpec {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PartitionRangeDatumKind {
    PARTITION_RANGE_DATUM_MINVALUE = -1,
    PARTITION_RANGE_DATUM_VALUE = 0,
    PARTITION_RANGE_DATUM_MAXVALUE = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionRangeDatum {
    pub type_: NodeTag,
    pub kind: PartitionRangeDatumKind,
    pub value: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionRangeDatum() {
    assert_eq!(::std::mem::size_of::<PartitionRangeDatum>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( PartitionRangeDatum ) ));
    assert_eq! (::std::mem::align_of::<PartitionRangeDatum>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( PartitionRangeDatum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionRangeDatum ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionRangeDatum ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionRangeDatum ) ) . kind as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionRangeDatum ) ,
                "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionRangeDatum ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionRangeDatum ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionRangeDatum ) ) . location as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionRangeDatum ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for PartitionRangeDatum {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionCmd {
    pub type_: NodeTag,
    pub name: *mut RangeVar,
    pub bound: *mut PartitionBoundSpec,
}
#[test]
fn bindgen_test_layout_PartitionCmd() {
    assert_eq!(::std::mem::size_of::<PartitionCmd>() , 24usize , concat ! (
               "Size of: " , stringify ! ( PartitionCmd ) ));
    assert_eq! (::std::mem::align_of::<PartitionCmd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PartitionCmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionCmd ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionCmd ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionCmd ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionCmd ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionCmd ) ) . bound as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionCmd ) , "::" ,
                stringify ! ( bound ) ));
}
impl Clone for PartitionCmd {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTEKind {
    RTE_RELATION = 0,
    RTE_SUBQUERY = 1,
    RTE_JOIN = 2,
    RTE_FUNCTION = 3,
    RTE_TABLEFUNC = 4,
    RTE_VALUES = 5,
    RTE_CTE = 6,
    RTE_NAMEDTUPLESTORE = 7,
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub tablesample: *mut TableSampleClause,
    pub subquery: *mut Query,
    pub security_barrier: bool_,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub functions: *mut List,
    pub funcordinality: bool_,
    pub tablefunc: *mut TableFunc,
    pub values_lists: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool_,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub enrname: *mut ::std::os::raw::c_char,
    pub enrtuples: f64,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: bool_,
    pub inh: bool_,
    pub inFromCl: bool_,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
#[test]
fn bindgen_test_layout_RangeTblEntry() {
    assert_eq!(::std::mem::size_of::<RangeTblEntry>() , 200usize , concat ! (
               "Size of: " , stringify ! ( RangeTblEntry ) ));
    assert_eq! (::std::mem::align_of::<RangeTblEntry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RangeTblEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . rtekind as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( rtekind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . relid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . relkind as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( relkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . tablesample as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( tablesample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . subquery as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( subquery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . security_barrier as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( security_barrier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . jointype as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( jointype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . joinaliasvars as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( joinaliasvars ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . functions as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . funcordinality as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( funcordinality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . tablefunc as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( tablefunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . values_lists as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( values_lists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . ctename as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( ctename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . ctelevelsup as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( ctelevelsup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . self_reference as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( self_reference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . coltypes as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( coltypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . coltypmods as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( coltypmods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . colcollations as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( colcollations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . enrname as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( enrname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . enrtuples as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( enrtuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . alias as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . eref as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( eref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . lateral as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( lateral ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . inh as * const _ as
                usize } , 153usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( inh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . inFromCl as * const _
                as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( inFromCl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . requiredPerms as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( requiredPerms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . checkAsUser as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( checkAsUser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . selectedCols as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( selectedCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . insertedCols as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( insertedCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . updatedCols as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( updatedCols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblEntry ) ) . securityQuals as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblEntry ) , "::"
                , stringify ! ( securityQuals ) ));
}
impl Clone for RangeTblEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_RangeTblFunction() {
    assert_eq!(::std::mem::size_of::<RangeTblFunction>() , 64usize , concat !
               ( "Size of: " , stringify ! ( RangeTblFunction ) ));
    assert_eq! (::std::mem::align_of::<RangeTblFunction>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( RangeTblFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funcexpr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funcexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funccolcount as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funccolcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funccolnames as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funccolnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funccoltypes as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funccoltypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funccoltypmods as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funccoltypmods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funccolcollations
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funccolcollations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RangeTblFunction ) ) . funcparams as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RangeTblFunction ) ,
                "::" , stringify ! ( funcparams ) ));
}
impl Clone for RangeTblFunction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
#[test]
fn bindgen_test_layout_TableSampleClause() {
    assert_eq!(::std::mem::size_of::<TableSampleClause>() , 24usize , concat !
               ( "Size of: " , stringify ! ( TableSampleClause ) ));
    assert_eq! (::std::mem::align_of::<TableSampleClause>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TableSampleClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableSampleClause ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TableSampleClause ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableSampleClause ) ) . tsmhandler as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TableSampleClause ) ,
                "::" , stringify ! ( tsmhandler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableSampleClause ) ) . args as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TableSampleClause ) ,
                "::" , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TableSampleClause ) ) . repeatable as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TableSampleClause ) ,
                "::" , stringify ! ( repeatable ) ));
}
impl Clone for TableSampleClause {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WCOKind {
    WCO_VIEW_CHECK = 0,
    WCO_RLS_INSERT_CHECK = 1,
    WCO_RLS_UPDATE_CHECK = 2,
    WCO_RLS_CONFLICT_CHECK = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind,
    pub relname: *mut ::std::os::raw::c_char,
    pub polname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: bool_,
}
#[test]
fn bindgen_test_layout_WithCheckOption() {
    assert_eq!(::std::mem::size_of::<WithCheckOption>() , 40usize , concat ! (
               "Size of: " , stringify ! ( WithCheckOption ) ));
    assert_eq! (::std::mem::align_of::<WithCheckOption>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( WithCheckOption ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithCheckOption ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WithCheckOption ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithCheckOption ) ) . kind as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WithCheckOption ) ,
                "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithCheckOption ) ) . relname as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WithCheckOption ) ,
                "::" , stringify ! ( relname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithCheckOption ) ) . polname as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WithCheckOption ) ,
                "::" , stringify ! ( polname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithCheckOption ) ) . qual as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WithCheckOption ) ,
                "::" , stringify ! ( qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithCheckOption ) ) . cascaded as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WithCheckOption ) ,
                "::" , stringify ! ( cascaded ) ));
}
impl Clone for WithCheckOption {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool_,
    pub hashable: bool_,
}
#[test]
fn bindgen_test_layout_SortGroupClause() {
    assert_eq!(::std::mem::size_of::<SortGroupClause>() , 20usize , concat ! (
               "Size of: " , stringify ! ( SortGroupClause ) ));
    assert_eq! (::std::mem::align_of::<SortGroupClause>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SortGroupClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortGroupClause ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SortGroupClause ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortGroupClause ) ) . tleSortGroupRef as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SortGroupClause ) ,
                "::" , stringify ! ( tleSortGroupRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortGroupClause ) ) . eqop as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SortGroupClause ) ,
                "::" , stringify ! ( eqop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortGroupClause ) ) . sortop as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SortGroupClause ) ,
                "::" , stringify ! ( sortop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortGroupClause ) ) . nulls_first as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SortGroupClause ) ,
                "::" , stringify ! ( nulls_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortGroupClause ) ) . hashable as * const
                _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( SortGroupClause ) ,
                "::" , stringify ! ( hashable ) ));
}
impl Clone for SortGroupClause {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GroupingSetKind {
    GROUPING_SET_EMPTY = 0,
    GROUPING_SET_SIMPLE = 1,
    GROUPING_SET_ROLLUP = 2,
    GROUPING_SET_CUBE = 3,
    GROUPING_SET_SETS = 4,
}
#[repr(C)]
#[derive(Copy)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind,
    pub content: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GroupingSet() {
    assert_eq!(::std::mem::size_of::<GroupingSet>() , 24usize , concat ! (
               "Size of: " , stringify ! ( GroupingSet ) ));
    assert_eq! (::std::mem::align_of::<GroupingSet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GroupingSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSet ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSet ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSet ) ) . kind as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSet ) , "::" ,
                stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSet ) ) . content as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSet ) , "::" ,
                stringify ! ( content ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSet ) ) . location as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSet ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for GroupingSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub winref: Index,
    pub copiedOrder: bool_,
}
#[test]
fn bindgen_test_layout_WindowClause() {
    assert_eq!(::std::mem::size_of::<WindowClause>() , 72usize , concat ! (
               "Size of: " , stringify ! ( WindowClause ) ));
    assert_eq! (::std::mem::align_of::<WindowClause>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WindowClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . refname as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( refname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . partitionClause as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( partitionClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . orderClause as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( orderClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . frameOptions as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( frameOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . startOffset as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( startOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . endOffset as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( endOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . winref as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( winref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowClause ) ) . copiedOrder as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowClause ) , "::" ,
                stringify ! ( copiedOrder ) ));
}
impl Clone for WindowClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: bool_,
}
#[test]
fn bindgen_test_layout_RowMarkClause() {
    assert_eq!(::std::mem::size_of::<RowMarkClause>() , 20usize , concat ! (
               "Size of: " , stringify ! ( RowMarkClause ) ));
    assert_eq! (::std::mem::align_of::<RowMarkClause>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RowMarkClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowMarkClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RowMarkClause ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowMarkClause ) ) . rti as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RowMarkClause ) , "::"
                , stringify ! ( rti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowMarkClause ) ) . strength as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RowMarkClause ) , "::"
                , stringify ! ( strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowMarkClause ) ) . waitPolicy as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RowMarkClause ) , "::"
                , stringify ! ( waitPolicy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RowMarkClause ) ) . pushedDown as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RowMarkClause ) , "::"
                , stringify ! ( pushedDown ) ));
}
impl Clone for RowMarkClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WithClause() {
    assert_eq!(::std::mem::size_of::<WithClause>() , 24usize , concat ! (
               "Size of: " , stringify ! ( WithClause ) ));
    assert_eq! (::std::mem::align_of::<WithClause>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WithClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WithClause ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithClause ) ) . ctes as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WithClause ) , "::" ,
                stringify ! ( ctes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithClause ) ) . recursive as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WithClause ) , "::" ,
                stringify ! ( recursive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WithClause ) ) . location as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( WithClause ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for WithClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_InferClause() {
    assert_eq!(::std::mem::size_of::<InferClause>() , 40usize , concat ! (
               "Size of: " , stringify ! ( InferClause ) ));
    assert_eq! (::std::mem::align_of::<InferClause>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( InferClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferClause ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( InferClause ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferClause ) ) . indexElems as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( InferClause ) , "::" ,
                stringify ! ( indexElems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferClause ) ) . whereClause as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( InferClause ) , "::" ,
                stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferClause ) ) . conname as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( InferClause ) , "::" ,
                stringify ! ( conname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InferClause ) ) . location as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( InferClause ) , "::" ,
                stringify ! ( location ) ));
}
impl Clone for InferClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OnConflictClause() {
    assert_eq!(::std::mem::size_of::<OnConflictClause>() , 40usize , concat !
               ( "Size of: " , stringify ! ( OnConflictClause ) ));
    assert_eq! (::std::mem::align_of::<OnConflictClause>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( OnConflictClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictClause ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictClause ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictClause ) ) . action as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictClause ) ,
                "::" , stringify ! ( action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictClause ) ) . infer as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictClause ) ,
                "::" , stringify ! ( infer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictClause ) ) . targetList as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictClause ) ,
                "::" , stringify ! ( targetList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictClause ) ) . whereClause as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictClause ) ,
                "::" , stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OnConflictClause ) ) . location as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OnConflictClause ) ,
                "::" , stringify ! ( location ) ));
}
impl Clone for OnConflictClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool_,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
#[test]
fn bindgen_test_layout_CommonTableExpr() {
    assert_eq!(::std::mem::size_of::<CommonTableExpr>() , 80usize , concat ! (
               "Size of: " , stringify ! ( CommonTableExpr ) ));
    assert_eq! (::std::mem::align_of::<CommonTableExpr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CommonTableExpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . ctename as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( ctename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . aliascolnames as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( aliascolnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . ctequery as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( ctequery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . location as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . cterecursive as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( cterecursive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . cterefcount as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( cterefcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . ctecolnames as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( ctecolnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . ctecoltypes as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( ctecoltypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . ctecoltypmods as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( ctecoltypmods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommonTableExpr ) ) . ctecolcollations as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( CommonTableExpr ) ,
                "::" , stringify ! ( ctecolcollations ) ));
}
impl Clone for CommonTableExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TriggerTransition {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub isNew: bool_,
    pub isTable: bool_,
}
#[test]
fn bindgen_test_layout_TriggerTransition() {
    assert_eq!(::std::mem::size_of::<TriggerTransition>() , 24usize , concat !
               ( "Size of: " , stringify ! ( TriggerTransition ) ));
    assert_eq! (::std::mem::align_of::<TriggerTransition>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TriggerTransition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerTransition ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerTransition ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerTransition ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerTransition ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerTransition ) ) . isNew as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerTransition ) ,
                "::" , stringify ! ( isNew ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TriggerTransition ) ) . isTable as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( TriggerTransition ) ,
                "::" , stringify ! ( isTable ) ));
}
impl Clone for TriggerTransition {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RawStmt {
    pub type_: NodeTag,
    pub stmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RawStmt() {
    assert_eq!(::std::mem::size_of::<RawStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( RawStmt ) ));
    assert_eq! (::std::mem::align_of::<RawStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RawStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RawStmt ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RawStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RawStmt ) ) . stmt as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RawStmt ) , "::" ,
                stringify ! ( stmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RawStmt ) ) . stmt_location as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RawStmt ) , "::" ,
                stringify ! ( stmt_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RawStmt ) ) . stmt_len as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RawStmt ) , "::" ,
                stringify ! ( stmt_len ) ));
}
impl Clone for RawStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
    pub override_: OverridingKind,
}
#[test]
fn bindgen_test_layout_InsertStmt() {
    assert_eq!(::std::mem::size_of::<InsertStmt>() , 64usize , concat ! (
               "Size of: " , stringify ! ( InsertStmt ) ));
    assert_eq! (::std::mem::align_of::<InsertStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( InsertStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . cols as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( cols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . selectStmt as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( selectStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . onConflictClause as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( onConflictClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . returningList as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( returningList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . withClause as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( withClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InsertStmt ) ) . override_ as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( InsertStmt ) , "::" ,
                stringify ! ( override_ ) ));
}
impl Clone for InsertStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_DeleteStmt() {
    assert_eq!(::std::mem::size_of::<DeleteStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( DeleteStmt ) ));
    assert_eq! (::std::mem::align_of::<DeleteStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DeleteStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeleteStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DeleteStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeleteStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DeleteStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeleteStmt ) ) . usingClause as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DeleteStmt ) , "::" ,
                stringify ! ( usingClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeleteStmt ) ) . whereClause as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DeleteStmt ) , "::" ,
                stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeleteStmt ) ) . returningList as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( DeleteStmt ) , "::" ,
                stringify ! ( returningList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeleteStmt ) ) . withClause as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( DeleteStmt ) , "::" ,
                stringify ! ( withClause ) ));
}
impl Clone for DeleteStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_UpdateStmt() {
    assert_eq!(::std::mem::size_of::<UpdateStmt>() , 56usize , concat ! (
               "Size of: " , stringify ! ( UpdateStmt ) ));
    assert_eq! (::std::mem::align_of::<UpdateStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( UpdateStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . targetList as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( targetList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . whereClause as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . fromClause as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( fromClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . returningList as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( returningList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdateStmt ) ) . withClause as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdateStmt ) , "::" ,
                stringify ! ( withClause ) ));
}
impl Clone for UpdateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetOperation {
    SETOP_NONE = 0,
    SETOP_UNION = 1,
    SETOP_INTERSECT = 2,
    SETOP_EXCEPT = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: bool_,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
#[test]
fn bindgen_test_layout_SelectStmt() {
    assert_eq!(::std::mem::size_of::<SelectStmt>() , 144usize , concat ! (
               "Size of: " , stringify ! ( SelectStmt ) ));
    assert_eq! (::std::mem::align_of::<SelectStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SelectStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . distinctClause as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( distinctClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . intoClause as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( intoClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . targetList as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( targetList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . fromClause as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( fromClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . whereClause as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . groupClause as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( groupClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . havingClause as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( havingClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . windowClause as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( windowClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . valuesLists as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( valuesLists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . sortClause as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( sortClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . limitOffset as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( limitOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . limitCount as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( limitCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . lockingClause as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( lockingClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . withClause as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( withClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . op as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . all as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . larg as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( larg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectStmt ) ) . rarg as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectStmt ) , "::" ,
                stringify ! ( rarg ) ));
}
impl Clone for SelectStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool_,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
#[test]
fn bindgen_test_layout_SetOperationStmt() {
    assert_eq!(::std::mem::size_of::<SetOperationStmt>() , 64usize , concat !
               ( "Size of: " , stringify ! ( SetOperationStmt ) ));
    assert_eq! (::std::mem::align_of::<SetOperationStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SetOperationStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . op as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . all as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . larg as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( larg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . rarg as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( rarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . colTypes as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( colTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . colTypmods as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( colTypmods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . colCollations as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( colCollations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOperationStmt ) ) . groupClauses as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOperationStmt ) ,
                "::" , stringify ! ( groupClauses ) ));
}
impl Clone for SetOperationStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ObjectType {
    OBJECT_ACCESS_METHOD = 0,
    OBJECT_AGGREGATE = 1,
    OBJECT_AMOP = 2,
    OBJECT_AMPROC = 3,
    OBJECT_ATTRIBUTE = 4,
    OBJECT_CAST = 5,
    OBJECT_COLUMN = 6,
    OBJECT_COLLATION = 7,
    OBJECT_CONVERSION = 8,
    OBJECT_DATABASE = 9,
    OBJECT_DEFAULT = 10,
    OBJECT_DEFACL = 11,
    OBJECT_DOMAIN = 12,
    OBJECT_DOMCONSTRAINT = 13,
    OBJECT_EVENT_TRIGGER = 14,
    OBJECT_EXTENSION = 15,
    OBJECT_FDW = 16,
    OBJECT_FOREIGN_SERVER = 17,
    OBJECT_FOREIGN_TABLE = 18,
    OBJECT_FUNCTION = 19,
    OBJECT_INDEX = 20,
    OBJECT_LANGUAGE = 21,
    OBJECT_LARGEOBJECT = 22,
    OBJECT_MATVIEW = 23,
    OBJECT_OPCLASS = 24,
    OBJECT_OPERATOR = 25,
    OBJECT_OPFAMILY = 26,
    OBJECT_POLICY = 27,
    OBJECT_PUBLICATION = 28,
    OBJECT_PUBLICATION_REL = 29,
    OBJECT_ROLE = 30,
    OBJECT_RULE = 31,
    OBJECT_SCHEMA = 32,
    OBJECT_SEQUENCE = 33,
    OBJECT_SUBSCRIPTION = 34,
    OBJECT_STATISTIC_EXT = 35,
    OBJECT_TABCONSTRAINT = 36,
    OBJECT_TABLE = 37,
    OBJECT_TABLESPACE = 38,
    OBJECT_TRANSFORM = 39,
    OBJECT_TRIGGER = 40,
    OBJECT_TSCONFIGURATION = 41,
    OBJECT_TSDICTIONARY = 42,
    OBJECT_TSPARSER = 43,
    OBJECT_TSTEMPLATE = 44,
    OBJECT_TYPE = 45,
    OBJECT_USER_MAPPING = 46,
    OBJECT_VIEW = 47,
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authrole: *mut RoleSpec,
    pub schemaElts: *mut List,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateSchemaStmt() {
    assert_eq!(::std::mem::size_of::<CreateSchemaStmt>() , 40usize , concat !
               ( "Size of: " , stringify ! ( CreateSchemaStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateSchemaStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CreateSchemaStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSchemaStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSchemaStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSchemaStmt ) ) . schemaname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSchemaStmt ) ,
                "::" , stringify ! ( schemaname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSchemaStmt ) ) . authrole as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSchemaStmt ) ,
                "::" , stringify ! ( authrole ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSchemaStmt ) ) . schemaElts as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSchemaStmt ) ,
                "::" , stringify ! ( schemaElts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSchemaStmt ) ) . if_not_exists as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSchemaStmt ) ,
                "::" , stringify ! ( if_not_exists ) ));
}
impl Clone for CreateSchemaStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DropBehavior { DROP_RESTRICT = 0, DROP_CASCADE = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableStmt() {
    assert_eq!(::std::mem::size_of::<AlterTableStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AlterTableStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterTableStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterTableStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableStmt ) ) . relation as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableStmt ) , "::"
                , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableStmt ) ) . cmds as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableStmt ) , "::"
                , stringify ! ( cmds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableStmt ) ) . relkind as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableStmt ) , "::"
                , stringify ! ( relkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableStmt ) ) . missing_ok as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableStmt ) , "::"
                , stringify ! ( missing_ok ) ));
}
impl Clone for AlterTableStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AlterTableType {
    AT_AddColumn = 0,
    AT_AddColumnRecurse = 1,
    AT_AddColumnToView = 2,
    AT_ColumnDefault = 3,
    AT_DropNotNull = 4,
    AT_SetNotNull = 5,
    AT_SetStatistics = 6,
    AT_SetOptions = 7,
    AT_ResetOptions = 8,
    AT_SetStorage = 9,
    AT_DropColumn = 10,
    AT_DropColumnRecurse = 11,
    AT_AddIndex = 12,
    AT_ReAddIndex = 13,
    AT_AddConstraint = 14,
    AT_AddConstraintRecurse = 15,
    AT_ReAddConstraint = 16,
    AT_AlterConstraint = 17,
    AT_ValidateConstraint = 18,
    AT_ValidateConstraintRecurse = 19,
    AT_ProcessedConstraint = 20,
    AT_AddIndexConstraint = 21,
    AT_DropConstraint = 22,
    AT_DropConstraintRecurse = 23,
    AT_ReAddComment = 24,
    AT_AlterColumnType = 25,
    AT_AlterColumnGenericOptions = 26,
    AT_ChangeOwner = 27,
    AT_ClusterOn = 28,
    AT_DropCluster = 29,
    AT_SetLogged = 30,
    AT_SetUnLogged = 31,
    AT_AddOids = 32,
    AT_AddOidsRecurse = 33,
    AT_DropOids = 34,
    AT_SetTableSpace = 35,
    AT_SetRelOptions = 36,
    AT_ResetRelOptions = 37,
    AT_ReplaceRelOptions = 38,
    AT_EnableTrig = 39,
    AT_EnableAlwaysTrig = 40,
    AT_EnableReplicaTrig = 41,
    AT_DisableTrig = 42,
    AT_EnableTrigAll = 43,
    AT_DisableTrigAll = 44,
    AT_EnableTrigUser = 45,
    AT_DisableTrigUser = 46,
    AT_EnableRule = 47,
    AT_EnableAlwaysRule = 48,
    AT_EnableReplicaRule = 49,
    AT_DisableRule = 50,
    AT_AddInherit = 51,
    AT_DropInherit = 52,
    AT_AddOf = 53,
    AT_DropOf = 54,
    AT_ReplicaIdentity = 55,
    AT_EnableRowSecurity = 56,
    AT_DisableRowSecurity = 57,
    AT_ForceRowSecurity = 58,
    AT_NoForceRowSecurity = 59,
    AT_GenericOptions = 60,
    AT_AttachPartition = 61,
    AT_DetachPartition = 62,
    AT_AddIdentity = 63,
    AT_SetIdentity = 64,
    AT_DropIdentity = 65,
}
#[repr(C)]
#[derive(Copy)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ReplicaIdentityStmt() {
    assert_eq!(::std::mem::size_of::<ReplicaIdentityStmt>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ReplicaIdentityStmt ) ));
    assert_eq! (::std::mem::align_of::<ReplicaIdentityStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ReplicaIdentityStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicaIdentityStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicaIdentityStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicaIdentityStmt ) ) . identity_type
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicaIdentityStmt ) ,
                "::" , stringify ! ( identity_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicaIdentityStmt ) ) . name as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicaIdentityStmt ) ,
                "::" , stringify ! ( name ) ));
}
impl Clone for ReplicaIdentityStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub newowner: *mut RoleSpec,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableCmd() {
    assert_eq!(::std::mem::size_of::<AlterTableCmd>() , 40usize , concat ! (
               "Size of: " , stringify ! ( AlterTableCmd ) ));
    assert_eq! (::std::mem::align_of::<AlterTableCmd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterTableCmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . subtype as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( subtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . newowner as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( newowner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . def as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( def ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . behavior as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableCmd ) ) . missing_ok as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableCmd ) , "::"
                , stringify ! ( missing_ok ) ));
}
impl Clone for AlterTableCmd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterCollationStmt {
    pub type_: NodeTag,
    pub collname: *mut List,
}
#[test]
fn bindgen_test_layout_AlterCollationStmt() {
    assert_eq!(::std::mem::size_of::<AlterCollationStmt>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( AlterCollationStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterCollationStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterCollationStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterCollationStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterCollationStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterCollationStmt ) ) . collname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterCollationStmt ) ,
                "::" , stringify ! ( collname ) ));
}
impl Clone for AlterCollationStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterDomainStmt() {
    assert_eq!(::std::mem::size_of::<AlterDomainStmt>() , 40usize , concat ! (
               "Size of: " , stringify ! ( AlterDomainStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterDomainStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AlterDomainStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . subtype as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( subtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . typeName as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . name as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . def as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( def ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . behavior as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDomainStmt ) ) . missing_ok as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDomainStmt ) ,
                "::" , stringify ! ( missing_ok ) ));
}
impl Clone for AlterDomainStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GrantTargetType {
    ACL_TARGET_OBJECT = 0,
    ACL_TARGET_ALL_IN_SCHEMA = 1,
    ACL_TARGET_DEFAULTS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GrantObjectType {
    ACL_OBJECT_COLUMN = 0,
    ACL_OBJECT_RELATION = 1,
    ACL_OBJECT_SEQUENCE = 2,
    ACL_OBJECT_DATABASE = 3,
    ACL_OBJECT_DOMAIN = 4,
    ACL_OBJECT_FDW = 5,
    ACL_OBJECT_FOREIGN_SERVER = 6,
    ACL_OBJECT_FUNCTION = 7,
    ACL_OBJECT_LANGUAGE = 8,
    ACL_OBJECT_LARGEOBJECT = 9,
    ACL_OBJECT_NAMESPACE = 10,
    ACL_OBJECT_TABLESPACE = 11,
    ACL_OBJECT_TYPE = 12,
}
#[repr(C)]
#[derive(Copy)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool_,
    pub targtype: GrantTargetType,
    pub objtype: GrantObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool_,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_GrantStmt() {
    assert_eq!(::std::mem::size_of::<GrantStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( GrantStmt ) ));
    assert_eq! (::std::mem::align_of::<GrantStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GrantStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . is_grant as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( is_grant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . targtype as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( targtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . objtype as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( objtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . objects as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( objects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . privileges as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( privileges ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . grantees as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( grantees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . grant_option as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( grant_option ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantStmt ) ) . behavior as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantStmt ) , "::" ,
                stringify ! ( behavior ) ));
}
impl Clone for GrantStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ObjectWithArgs {
    pub type_: NodeTag,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub args_unspecified: bool_,
}
#[test]
fn bindgen_test_layout_ObjectWithArgs() {
    assert_eq!(::std::mem::size_of::<ObjectWithArgs>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ObjectWithArgs ) ));
    assert_eq! (::std::mem::align_of::<ObjectWithArgs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ObjectWithArgs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectWithArgs ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectWithArgs ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectWithArgs ) ) . objname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectWithArgs ) , "::"
                , stringify ! ( objname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectWithArgs ) ) . objargs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectWithArgs ) , "::"
                , stringify ! ( objargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectWithArgs ) ) . args_unspecified as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectWithArgs ) , "::"
                , stringify ! ( args_unspecified ) ));
}
impl Clone for ObjectWithArgs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
#[test]
fn bindgen_test_layout_AccessPriv() {
    assert_eq!(::std::mem::size_of::<AccessPriv>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AccessPriv ) ));
    assert_eq! (::std::mem::align_of::<AccessPriv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AccessPriv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AccessPriv ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AccessPriv ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AccessPriv ) ) . priv_name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AccessPriv ) , "::" ,
                stringify ! ( priv_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AccessPriv ) ) . cols as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AccessPriv ) , "::" ,
                stringify ! ( cols ) ));
}
impl Clone for AccessPriv {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool_,
    pub admin_opt: bool_,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_GrantRoleStmt() {
    assert_eq!(::std::mem::size_of::<GrantRoleStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( GrantRoleStmt ) ));
    assert_eq! (::std::mem::align_of::<GrantRoleStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GrantRoleStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . granted_roles as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( granted_roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . grantee_roles as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( grantee_roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . is_grant as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( is_grant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . admin_opt as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( admin_opt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . grantor as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( grantor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GrantRoleStmt ) ) . behavior as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( GrantRoleStmt ) , "::"
                , stringify ! ( behavior ) ));
}
impl Clone for GrantRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
#[test]
fn bindgen_test_layout_AlterDefaultPrivilegesStmt() {
    assert_eq!(::std::mem::size_of::<AlterDefaultPrivilegesStmt>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( AlterDefaultPrivilegesStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterDefaultPrivilegesStmt>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( AlterDefaultPrivilegesStmt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDefaultPrivilegesStmt ) ) . type_ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterDefaultPrivilegesStmt ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDefaultPrivilegesStmt ) ) . options
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterDefaultPrivilegesStmt ) , "::" , stringify ! ( options )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDefaultPrivilegesStmt ) ) . action
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterDefaultPrivilegesStmt ) , "::" , stringify ! ( action )
                ));
}
impl Clone for AlterDefaultPrivilegesStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool_,
    pub is_program: bool_,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CopyStmt() {
    assert_eq!(::std::mem::size_of::<CopyStmt>() , 56usize , concat ! (
               "Size of: " , stringify ! ( CopyStmt ) ));
    assert_eq! (::std::mem::align_of::<CopyStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CopyStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . query as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . attlist as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( attlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . is_from as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( is_from ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . is_program as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( is_program ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . filename as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CopyStmt ) ) . options as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CopyStmt ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for CopyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VariableSetKind {
    VAR_SET_VALUE = 0,
    VAR_SET_DEFAULT = 1,
    VAR_SET_CURRENT = 2,
    VAR_SET_MULTI = 3,
    VAR_RESET = 4,
    VAR_RESET_ALL = 5,
}
#[repr(C)]
#[derive(Copy)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: bool_,
}
#[test]
fn bindgen_test_layout_VariableSetStmt() {
    assert_eq!(::std::mem::size_of::<VariableSetStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( VariableSetStmt ) ));
    assert_eq! (::std::mem::align_of::<VariableSetStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VariableSetStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableSetStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableSetStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableSetStmt ) ) . kind as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableSetStmt ) ,
                "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableSetStmt ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableSetStmt ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableSetStmt ) ) . args as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableSetStmt ) ,
                "::" , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableSetStmt ) ) . is_local as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableSetStmt ) ,
                "::" , stringify ! ( is_local ) ));
}
impl Clone for VariableSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VariableShowStmt() {
    assert_eq!(::std::mem::size_of::<VariableShowStmt>() , 16usize , concat !
               ( "Size of: " , stringify ! ( VariableShowStmt ) ));
    assert_eq! (::std::mem::align_of::<VariableShowStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VariableShowStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableShowStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableShowStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableShowStmt ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableShowStmt ) ,
                "::" , stringify ! ( name ) ));
}
impl Clone for VariableShowStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub partbound: *mut PartitionBoundSpec,
    pub partspec: *mut PartitionSpec,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateStmt() {
    assert_eq!(::std::mem::size_of::<CreateStmt>() , 96usize , concat ! (
               "Size of: " , stringify ! ( CreateStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . tableElts as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( tableElts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . inhRelations as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( inhRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . partbound as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( partbound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . partspec as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( partspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . ofTypename as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( ofTypename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . constraints as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . options as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . oncommit as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( oncommit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . tablespacename as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( tablespacename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStmt ) ) . if_not_exists as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStmt ) , "::" ,
                stringify ! ( if_not_exists ) ));
}
impl Clone for CreateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ConstrType {
    CONSTR_NULL = 0,
    CONSTR_NOTNULL = 1,
    CONSTR_DEFAULT = 2,
    CONSTR_IDENTITY = 3,
    CONSTR_CHECK = 4,
    CONSTR_PRIMARY = 5,
    CONSTR_UNIQUE = 6,
    CONSTR_EXCLUSION = 7,
    CONSTR_FOREIGN = 8,
    CONSTR_ATTR_DEFERRABLE = 9,
    CONSTR_ATTR_NOT_DEFERRABLE = 10,
    CONSTR_ATTR_DEFERRED = 11,
    CONSTR_ATTR_IMMEDIATE = 12,
}
#[repr(C)]
#[derive(Copy)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool_,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub generated_when: ::std::os::raw::c_char,
    pub keys: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: bool_,
    pub initially_valid: bool_,
}
#[test]
fn bindgen_test_layout_Constraint() {
    assert_eq!(::std::mem::size_of::<Constraint>() , 160usize , concat ! (
               "Size of: " , stringify ! ( Constraint ) ));
    assert_eq! (::std::mem::align_of::<Constraint>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . contype as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( contype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . conname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( conname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . deferrable as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( deferrable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . initdeferred as * const
                _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( initdeferred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . location as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . is_no_inherit as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( is_no_inherit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . raw_expr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( raw_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . cooked_expr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( cooked_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . generated_when as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( generated_when ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . keys as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( keys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . exclusions as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( exclusions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . options as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . indexname as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( indexname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . indexspace as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( indexspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . access_method as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( access_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . where_clause as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( where_clause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . pktable as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( pktable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . fk_attrs as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( fk_attrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . pk_attrs as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( pk_attrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . fk_matchtype as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( fk_matchtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . fk_upd_action as * const
                _ as usize } , 137usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( fk_upd_action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . fk_del_action as * const
                _ as usize } , 138usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( fk_del_action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . old_conpfeqop as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( old_conpfeqop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . old_pktable_oid as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( old_pktable_oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . skip_validation as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( skip_validation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Constraint ) ) . initially_valid as *
                const _ as usize } , 157usize , concat ! (
                "Alignment of field: " , stringify ! ( Constraint ) , "::" ,
                stringify ! ( initially_valid ) ));
}
impl Clone for Constraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut RoleSpec,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateTableSpaceStmt() {
    assert_eq!(::std::mem::size_of::<CreateTableSpaceStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( CreateTableSpaceStmt )
               ));
    assert_eq! (::std::mem::align_of::<CreateTableSpaceStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateTableSpaceStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableSpaceStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableSpaceStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableSpaceStmt ) ) . tablespacename
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableSpaceStmt )
                , "::" , stringify ! ( tablespacename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableSpaceStmt ) ) . owner as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableSpaceStmt )
                , "::" , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableSpaceStmt ) ) . location as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableSpaceStmt )
                , "::" , stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableSpaceStmt ) ) . options as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableSpaceStmt )
                , "::" , stringify ! ( options ) ));
}
impl Clone for CreateTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropTableSpaceStmt() {
    assert_eq!(::std::mem::size_of::<DropTableSpaceStmt>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( DropTableSpaceStmt ) ));
    assert_eq! (::std::mem::align_of::<DropTableSpaceStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( DropTableSpaceStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropTableSpaceStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropTableSpaceStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropTableSpaceStmt ) ) . tablespacename
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropTableSpaceStmt ) ,
                "::" , stringify ! ( tablespacename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropTableSpaceStmt ) ) . missing_ok as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropTableSpaceStmt ) ,
                "::" , stringify ! ( missing_ok ) ));
}
impl Clone for DropTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableSpaceOptionsStmt() {
    assert_eq!(::std::mem::size_of::<AlterTableSpaceOptionsStmt>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( AlterTableSpaceOptionsStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterTableSpaceOptionsStmt>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( AlterTableSpaceOptionsStmt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableSpaceOptionsStmt ) ) . type_ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTableSpaceOptionsStmt ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableSpaceOptionsStmt ) ) .
                tablespacename as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTableSpaceOptionsStmt ) , "::" , stringify ! (
                tablespacename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableSpaceOptionsStmt ) ) . options
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTableSpaceOptionsStmt ) , "::" , stringify ! ( options )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableSpaceOptionsStmt ) ) . isReset
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTableSpaceOptionsStmt ) , "::" , stringify ! ( isReset )
                ));
}
impl Clone for AlterTableSpaceOptionsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableMoveAllStmt() {
    assert_eq!(::std::mem::size_of::<AlterTableMoveAllStmt>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( AlterTableMoveAllStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterTableMoveAllStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterTableMoveAllStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableMoveAllStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableMoveAllStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableMoveAllStmt ) ) .
                orig_tablespacename as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AlterTableMoveAllStmt )
                , "::" , stringify ! ( orig_tablespacename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableMoveAllStmt ) ) . objtype as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableMoveAllStmt )
                , "::" , stringify ! ( objtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableMoveAllStmt ) ) . roles as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableMoveAllStmt )
                , "::" , stringify ! ( roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableMoveAllStmt ) ) .
                new_tablespacename as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AlterTableMoveAllStmt )
                , "::" , stringify ! ( new_tablespacename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTableMoveAllStmt ) ) . nowait as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTableMoveAllStmt )
                , "::" , stringify ! ( nowait ) ));
}
impl Clone for AlterTableMoveAllStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateExtensionStmt() {
    assert_eq!(::std::mem::size_of::<CreateExtensionStmt>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( CreateExtensionStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateExtensionStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateExtensionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateExtensionStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateExtensionStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateExtensionStmt ) ) . extname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateExtensionStmt ) ,
                "::" , stringify ! ( extname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateExtensionStmt ) ) . if_not_exists
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateExtensionStmt ) ,
                "::" , stringify ! ( if_not_exists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateExtensionStmt ) ) . options as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateExtensionStmt ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for CreateExtensionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterExtensionStmt() {
    assert_eq!(::std::mem::size_of::<AlterExtensionStmt>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( AlterExtensionStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterExtensionStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterExtensionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterExtensionStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionStmt ) ) . extname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterExtensionStmt ) ,
                "::" , stringify ! ( extname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterExtensionStmt ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for AlterExtensionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub object: *mut Node,
}
#[test]
fn bindgen_test_layout_AlterExtensionContentsStmt() {
    assert_eq!(::std::mem::size_of::<AlterExtensionContentsStmt>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( AlterExtensionContentsStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterExtensionContentsStmt>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( AlterExtensionContentsStmt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionContentsStmt ) ) . type_ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterExtensionContentsStmt ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionContentsStmt ) ) . extname
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterExtensionContentsStmt ) , "::" , stringify ! ( extname )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionContentsStmt ) ) . action
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterExtensionContentsStmt ) , "::" , stringify ! ( action )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionContentsStmt ) ) . objtype
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterExtensionContentsStmt ) , "::" , stringify ! ( objtype )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterExtensionContentsStmt ) ) . object
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterExtensionContentsStmt ) , "::" , stringify ! ( object )
                ));
}
impl Clone for AlterExtensionContentsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateFdwStmt() {
    assert_eq!(::std::mem::size_of::<CreateFdwStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CreateFdwStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateFdwStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateFdwStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFdwStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFdwStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFdwStmt ) ) . fdwname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFdwStmt ) , "::"
                , stringify ! ( fdwname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFdwStmt ) ) . func_options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFdwStmt ) , "::"
                , stringify ! ( func_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFdwStmt ) ) . options as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFdwStmt ) , "::"
                , stringify ! ( options ) ));
}
impl Clone for CreateFdwStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterFdwStmt() {
    assert_eq!(::std::mem::size_of::<AlterFdwStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AlterFdwStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterFdwStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterFdwStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFdwStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFdwStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFdwStmt ) ) . fdwname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFdwStmt ) , "::" ,
                stringify ! ( fdwname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFdwStmt ) ) . func_options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFdwStmt ) , "::" ,
                stringify ! ( func_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFdwStmt ) ) . options as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFdwStmt ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for AlterFdwStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateForeignServerStmt() {
    assert_eq!(::std::mem::size_of::<CreateForeignServerStmt>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( CreateForeignServerStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateForeignServerStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateForeignServerStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) . servername
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) . servertype
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( servertype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) . version as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) . fdwname as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( fdwname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) .
                if_not_exists as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( if_not_exists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignServerStmt ) ) . options as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignServerStmt
                ) , "::" , stringify ! ( options ) ));
}
impl Clone for CreateForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: bool_,
}
#[test]
fn bindgen_test_layout_AlterForeignServerStmt() {
    assert_eq!(::std::mem::size_of::<AlterForeignServerStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( AlterForeignServerStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterForeignServerStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterForeignServerStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterForeignServerStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterForeignServerStmt
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterForeignServerStmt ) ) . servername
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterForeignServerStmt
                ) , "::" , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterForeignServerStmt ) ) . version as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterForeignServerStmt
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterForeignServerStmt ) ) . options as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterForeignServerStmt
                ) , "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterForeignServerStmt ) ) . has_version
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterForeignServerStmt
                ) , "::" , stringify ! ( has_version ) ));
}
impl Clone for AlterForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateForeignTableStmt() {
    assert_eq!(::std::mem::size_of::<CreateForeignTableStmt>() , 112usize ,
               concat ! ( "Size of: " , stringify ! ( CreateForeignTableStmt )
               ));
    assert_eq! (::std::mem::align_of::<CreateForeignTableStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateForeignTableStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignTableStmt ) ) . base as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignTableStmt
                ) , "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignTableStmt ) ) . servername
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignTableStmt
                ) , "::" , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateForeignTableStmt ) ) . options as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateForeignTableStmt
                ) , "::" , stringify ! ( options ) ));
}
impl Clone for CreateForeignTableStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateUserMappingStmt() {
    assert_eq!(::std::mem::size_of::<CreateUserMappingStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( CreateUserMappingStmt )
               ));
    assert_eq! (::std::mem::align_of::<CreateUserMappingStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateUserMappingStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateUserMappingStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateUserMappingStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateUserMappingStmt ) ) . user as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateUserMappingStmt )
                , "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateUserMappingStmt ) ) . servername as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateUserMappingStmt )
                , "::" , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateUserMappingStmt ) ) . if_not_exists
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateUserMappingStmt )
                , "::" , stringify ! ( if_not_exists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateUserMappingStmt ) ) . options as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateUserMappingStmt )
                , "::" , stringify ! ( options ) ));
}
impl Clone for CreateUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterUserMappingStmt() {
    assert_eq!(::std::mem::size_of::<AlterUserMappingStmt>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( AlterUserMappingStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterUserMappingStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterUserMappingStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterUserMappingStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterUserMappingStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterUserMappingStmt ) ) . user as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterUserMappingStmt )
                , "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterUserMappingStmt ) ) . servername as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterUserMappingStmt )
                , "::" , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterUserMappingStmt ) ) . options as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterUserMappingStmt )
                , "::" , stringify ! ( options ) ));
}
impl Clone for AlterUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropUserMappingStmt() {
    assert_eq!(::std::mem::size_of::<DropUserMappingStmt>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( DropUserMappingStmt ) ));
    assert_eq! (::std::mem::align_of::<DropUserMappingStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( DropUserMappingStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropUserMappingStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropUserMappingStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropUserMappingStmt ) ) . user as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropUserMappingStmt ) ,
                "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropUserMappingStmt ) ) . servername as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropUserMappingStmt ) ,
                "::" , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropUserMappingStmt ) ) . missing_ok as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DropUserMappingStmt ) ,
                "::" , stringify ! ( missing_ok ) ));
}
impl Clone for DropUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ImportForeignSchemaType {
    FDW_IMPORT_SCHEMA_ALL = 0,
    FDW_IMPORT_SCHEMA_LIMIT_TO = 1,
    FDW_IMPORT_SCHEMA_EXCEPT = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: *mut ::std::os::raw::c_char,
    pub remote_schema: *mut ::std::os::raw::c_char,
    pub local_schema: *mut ::std::os::raw::c_char,
    pub list_type: ImportForeignSchemaType,
    pub table_list: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ImportForeignSchemaStmt() {
    assert_eq!(::std::mem::size_of::<ImportForeignSchemaStmt>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( ImportForeignSchemaStmt ) ));
    assert_eq! (::std::mem::align_of::<ImportForeignSchemaStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ImportForeignSchemaStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) . server_name
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( server_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) .
                remote_schema as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( remote_schema ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) .
                local_schema as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( local_schema ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) . list_type
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( list_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) . table_list
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( table_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ImportForeignSchemaStmt ) ) . options as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ImportForeignSchemaStmt
                ) , "::" , stringify ! ( options ) ));
}
impl Clone for ImportForeignSchemaStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::std::os::raw::c_char,
    pub permissive: bool_,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
#[test]
fn bindgen_test_layout_CreatePolicyStmt() {
    assert_eq!(::std::mem::size_of::<CreatePolicyStmt>() , 64usize , concat !
               ( "Size of: " , stringify ! ( CreatePolicyStmt ) ));
    assert_eq! (::std::mem::align_of::<CreatePolicyStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CreatePolicyStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . policy_name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( policy_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . table as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . cmd_name as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( cmd_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . permissive as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( permissive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . roles as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . qual as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePolicyStmt ) ) . with_check as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePolicyStmt ) ,
                "::" , stringify ! ( with_check ) ));
}
impl Clone for CreatePolicyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
#[test]
fn bindgen_test_layout_AlterPolicyStmt() {
    assert_eq!(::std::mem::size_of::<AlterPolicyStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( AlterPolicyStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterPolicyStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AlterPolicyStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPolicyStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPolicyStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPolicyStmt ) ) . policy_name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPolicyStmt ) ,
                "::" , stringify ! ( policy_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPolicyStmt ) ) . table as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPolicyStmt ) ,
                "::" , stringify ! ( table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPolicyStmt ) ) . roles as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPolicyStmt ) ,
                "::" , stringify ! ( roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPolicyStmt ) ) . qual as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPolicyStmt ) ,
                "::" , stringify ! ( qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPolicyStmt ) ) . with_check as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPolicyStmt ) ,
                "::" , stringify ! ( with_check ) ));
}
impl Clone for AlterPolicyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: *mut ::std::os::raw::c_char,
    pub handler_name: *mut List,
    pub amtype: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CreateAmStmt() {
    assert_eq!(::std::mem::size_of::<CreateAmStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CreateAmStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateAmStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateAmStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateAmStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateAmStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateAmStmt ) ) . amname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateAmStmt ) , "::" ,
                stringify ! ( amname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateAmStmt ) ) . handler_name as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateAmStmt ) , "::" ,
                stringify ! ( handler_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateAmStmt ) ) . amtype as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateAmStmt ) , "::" ,
                stringify ! ( amtype ) ));
}
impl Clone for CreateAmStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool_,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: bool_,
    pub transitionRels: *mut List,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub constrrel: *mut RangeVar,
}
#[test]
fn bindgen_test_layout_CreateTrigStmt() {
    assert_eq!(::std::mem::size_of::<CreateTrigStmt>() , 96usize , concat ! (
               "Size of: " , stringify ! ( CreateTrigStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateTrigStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateTrigStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . trigname as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( trigname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . relation as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . funcname as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( funcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . args as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . row as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . timing as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( timing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . events as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . columns as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( columns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . whenClause as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( whenClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . isconstraint as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( isconstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . transitionRels as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( transitionRels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . deferrable as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( deferrable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . initdeferred as *
                const _ as usize } , 81usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( initdeferred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTrigStmt ) ) . constrrel as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTrigStmt ) , "::"
                , stringify ! ( constrrel ) ));
}
impl Clone for CreateTrigStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
#[test]
fn bindgen_test_layout_CreateEventTrigStmt() {
    assert_eq!(::std::mem::size_of::<CreateEventTrigStmt>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( CreateEventTrigStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateEventTrigStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateEventTrigStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEventTrigStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEventTrigStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEventTrigStmt ) ) . trigname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEventTrigStmt ) ,
                "::" , stringify ! ( trigname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEventTrigStmt ) ) . eventname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEventTrigStmt ) ,
                "::" , stringify ! ( eventname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEventTrigStmt ) ) . whenclause as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEventTrigStmt ) ,
                "::" , stringify ! ( whenclause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEventTrigStmt ) ) . funcname as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEventTrigStmt ) ,
                "::" , stringify ! ( funcname ) ));
}
impl Clone for CreateEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AlterEventTrigStmt() {
    assert_eq!(::std::mem::size_of::<AlterEventTrigStmt>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( AlterEventTrigStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterEventTrigStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterEventTrigStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEventTrigStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEventTrigStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEventTrigStmt ) ) . trigname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEventTrigStmt ) ,
                "::" , stringify ! ( trigname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEventTrigStmt ) ) . tgenabled as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEventTrigStmt ) ,
                "::" , stringify ! ( tgenabled ) ));
}
impl Clone for AlterEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool_,
}
#[test]
fn bindgen_test_layout_CreatePLangStmt() {
    assert_eq!(::std::mem::size_of::<CreatePLangStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( CreatePLangStmt ) ));
    assert_eq! (::std::mem::align_of::<CreatePLangStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CreatePLangStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . replace as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( replace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . plname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( plname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . plhandler as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( plhandler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . plinline as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( plinline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . plvalidator as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( plvalidator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePLangStmt ) ) . pltrusted as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePLangStmt ) ,
                "::" , stringify ! ( pltrusted ) ));
}
impl Clone for CreatePLangStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RoleStmtType {
    ROLESTMT_ROLE = 0,
    ROLESTMT_USER = 1,
    ROLESTMT_GROUP = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateRoleStmt() {
    assert_eq!(::std::mem::size_of::<CreateRoleStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CreateRoleStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateRoleStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateRoleStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRoleStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRoleStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRoleStmt ) ) . stmt_type as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRoleStmt ) , "::"
                , stringify ! ( stmt_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRoleStmt ) ) . role as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRoleStmt ) , "::"
                , stringify ! ( role ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRoleStmt ) ) . options as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRoleStmt ) , "::"
                , stringify ! ( options ) ));
}
impl Clone for CreateRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AlterRoleStmt() {
    assert_eq!(::std::mem::size_of::<AlterRoleStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AlterRoleStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterRoleStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterRoleStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleStmt ) ) . role as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleStmt ) , "::"
                , stringify ! ( role ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleStmt ) ) . options as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleStmt ) , "::"
                , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleStmt ) ) . action as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleStmt ) , "::"
                , stringify ! ( action ) ));
}
impl Clone for AlterRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterRoleSetStmt() {
    assert_eq!(::std::mem::size_of::<AlterRoleSetStmt>() , 32usize , concat !
               ( "Size of: " , stringify ! ( AlterRoleSetStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterRoleSetStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AlterRoleSetStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleSetStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleSetStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleSetStmt ) ) . role as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleSetStmt ) ,
                "::" , stringify ! ( role ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleSetStmt ) ) . database as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleSetStmt ) ,
                "::" , stringify ! ( database ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterRoleSetStmt ) ) . setstmt as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterRoleSetStmt ) ,
                "::" , stringify ! ( setstmt ) ));
}
impl Clone for AlterRoleSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropRoleStmt() {
    assert_eq!(::std::mem::size_of::<DropRoleStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( DropRoleStmt ) ));
    assert_eq! (::std::mem::align_of::<DropRoleStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DropRoleStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropRoleStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropRoleStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropRoleStmt ) ) . roles as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropRoleStmt ) , "::" ,
                stringify ! ( roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropRoleStmt ) ) . missing_ok as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropRoleStmt ) , "::" ,
                stringify ! ( missing_ok ) ));
}
impl Clone for DropRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub for_identity: bool_,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateSeqStmt() {
    assert_eq!(::std::mem::size_of::<CreateSeqStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CreateSeqStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateSeqStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateSeqStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSeqStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSeqStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSeqStmt ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSeqStmt ) , "::"
                , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSeqStmt ) ) . options as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSeqStmt ) , "::"
                , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSeqStmt ) ) . ownerId as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSeqStmt ) , "::"
                , stringify ! ( ownerId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSeqStmt ) ) . for_identity as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSeqStmt ) , "::"
                , stringify ! ( for_identity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSeqStmt ) ) . if_not_exists as *
                const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSeqStmt ) , "::"
                , stringify ! ( if_not_exists ) ));
}
impl Clone for CreateSeqStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub for_identity: bool_,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterSeqStmt() {
    assert_eq!(::std::mem::size_of::<AlterSeqStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AlterSeqStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterSeqStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterSeqStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSeqStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSeqStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSeqStmt ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSeqStmt ) , "::" ,
                stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSeqStmt ) ) . options as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSeqStmt ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSeqStmt ) ) . for_identity as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSeqStmt ) , "::" ,
                stringify ! ( for_identity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSeqStmt ) ) . missing_ok as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSeqStmt ) , "::" ,
                stringify ! ( missing_ok ) ));
}
impl Clone for AlterSeqStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool_,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_DefineStmt() {
    assert_eq!(::std::mem::size_of::<DefineStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( DefineStmt ) ));
    assert_eq! (::std::mem::align_of::<DefineStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DefineStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . kind as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . oldstyle as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( oldstyle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . defnames as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( defnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . args as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . definition as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( definition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DefineStmt ) ) . if_not_exists as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( DefineStmt ) , "::" ,
                stringify ! ( if_not_exists ) ));
}
impl Clone for DefineStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
#[test]
fn bindgen_test_layout_CreateDomainStmt() {
    assert_eq!(::std::mem::size_of::<CreateDomainStmt>() , 40usize , concat !
               ( "Size of: " , stringify ! ( CreateDomainStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateDomainStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CreateDomainStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateDomainStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateDomainStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateDomainStmt ) ) . domainname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateDomainStmt ) ,
                "::" , stringify ! ( domainname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateDomainStmt ) ) . typeName as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateDomainStmt ) ,
                "::" , stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateDomainStmt ) ) . collClause as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateDomainStmt ) ,
                "::" , stringify ! ( collClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateDomainStmt ) ) . constraints as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateDomainStmt ) ,
                "::" , stringify ! ( constraints ) ));
}
impl Clone for CreateDomainStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool_,
}
#[test]
fn bindgen_test_layout_CreateOpClassStmt() {
    assert_eq!(::std::mem::size_of::<CreateOpClassStmt>() , 56usize , concat !
               ( "Size of: " , stringify ! ( CreateOpClassStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateOpClassStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CreateOpClassStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . opclassname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( opclassname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . opfamilyname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( opfamilyname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . amname as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( amname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . datatype as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( datatype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . items as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( items ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassStmt ) ) . isDefault as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassStmt ) ,
                "::" , stringify ! ( isDefault ) ));
}
impl Clone for CreateOpClassStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut ObjectWithArgs,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
#[test]
fn bindgen_test_layout_CreateOpClassItem() {
    assert_eq!(::std::mem::size_of::<CreateOpClassItem>() , 48usize , concat !
               ( "Size of: " , stringify ! ( CreateOpClassItem ) ));
    assert_eq! (::std::mem::align_of::<CreateOpClassItem>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CreateOpClassItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . itemtype as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( itemtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . number as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . order_family as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( order_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . class_args as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( class_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpClassItem ) ) . storedtype as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpClassItem ) ,
                "::" , stringify ! ( storedtype ) ));
}
impl Clone for CreateOpClassItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CreateOpFamilyStmt() {
    assert_eq!(::std::mem::size_of::<CreateOpFamilyStmt>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( CreateOpFamilyStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateOpFamilyStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CreateOpFamilyStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpFamilyStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpFamilyStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpFamilyStmt ) ) . opfamilyname as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpFamilyStmt ) ,
                "::" , stringify ! ( opfamilyname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateOpFamilyStmt ) ) . amname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateOpFamilyStmt ) ,
                "::" , stringify ! ( amname ) ));
}
impl Clone for CreateOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: bool_,
    pub items: *mut List,
}
#[test]
fn bindgen_test_layout_AlterOpFamilyStmt() {
    assert_eq!(::std::mem::size_of::<AlterOpFamilyStmt>() , 40usize , concat !
               ( "Size of: " , stringify ! ( AlterOpFamilyStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterOpFamilyStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterOpFamilyStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOpFamilyStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOpFamilyStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOpFamilyStmt ) ) . opfamilyname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOpFamilyStmt ) ,
                "::" , stringify ! ( opfamilyname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOpFamilyStmt ) ) . amname as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOpFamilyStmt ) ,
                "::" , stringify ! ( amname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOpFamilyStmt ) ) . isDrop as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOpFamilyStmt ) ,
                "::" , stringify ! ( isDrop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOpFamilyStmt ) ) . items as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOpFamilyStmt ) ,
                "::" , stringify ! ( items ) ));
}
impl Clone for AlterOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
    pub concurrent: bool_,
}
#[test]
fn bindgen_test_layout_DropStmt() {
    assert_eq!(::std::mem::size_of::<DropStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( DropStmt ) ));
    assert_eq! (::std::mem::align_of::<DropStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DropStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropStmt ) ) . objects as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropStmt ) , "::" ,
                stringify ! ( objects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropStmt ) ) . removeType as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropStmt ) , "::" ,
                stringify ! ( removeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropStmt ) ) . behavior as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( DropStmt ) , "::" ,
                stringify ! ( behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropStmt ) ) . missing_ok as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DropStmt ) , "::" ,
                stringify ! ( missing_ok ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropStmt ) ) . concurrent as * const _ as
                usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( DropStmt ) , "::" ,
                stringify ! ( concurrent ) ));
}
impl Clone for DropStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool_,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_TruncateStmt() {
    assert_eq!(::std::mem::size_of::<TruncateStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( TruncateStmt ) ));
    assert_eq! (::std::mem::align_of::<TruncateStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TruncateStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TruncateStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TruncateStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TruncateStmt ) ) . relations as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TruncateStmt ) , "::" ,
                stringify ! ( relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TruncateStmt ) ) . restart_seqs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TruncateStmt ) , "::" ,
                stringify ! ( restart_seqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TruncateStmt ) ) . behavior as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( TruncateStmt ) , "::" ,
                stringify ! ( behavior ) ));
}
impl Clone for TruncateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub comment: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CommentStmt() {
    assert_eq!(::std::mem::size_of::<CommentStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CommentStmt ) ));
    assert_eq! (::std::mem::align_of::<CommentStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CommentStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommentStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CommentStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommentStmt ) ) . objtype as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CommentStmt ) , "::" ,
                stringify ! ( objtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommentStmt ) ) . object as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CommentStmt ) , "::" ,
                stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommentStmt ) ) . comment as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CommentStmt ) , "::" ,
                stringify ! ( comment ) ));
}
impl Clone for CommentStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SecLabelStmt() {
    assert_eq!(::std::mem::size_of::<SecLabelStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( SecLabelStmt ) ));
    assert_eq! (::std::mem::align_of::<SecLabelStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SecLabelStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SecLabelStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SecLabelStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SecLabelStmt ) ) . objtype as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SecLabelStmt ) , "::" ,
                stringify ! ( objtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SecLabelStmt ) ) . object as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SecLabelStmt ) , "::" ,
                stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SecLabelStmt ) ) . provider as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SecLabelStmt ) , "::" ,
                stringify ! ( provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SecLabelStmt ) ) . label as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SecLabelStmt ) , "::" ,
                stringify ! ( label ) ));
}
impl Clone for SecLabelStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
#[test]
fn bindgen_test_layout_DeclareCursorStmt() {
    assert_eq!(::std::mem::size_of::<DeclareCursorStmt>() , 32usize , concat !
               ( "Size of: " , stringify ! ( DeclareCursorStmt ) ));
    assert_eq! (::std::mem::align_of::<DeclareCursorStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( DeclareCursorStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeclareCursorStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DeclareCursorStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeclareCursorStmt ) ) . portalname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DeclareCursorStmt ) ,
                "::" , stringify ! ( portalname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeclareCursorStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DeclareCursorStmt ) ,
                "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeclareCursorStmt ) ) . query as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DeclareCursorStmt ) ,
                "::" , stringify ! ( query ) ));
}
impl Clone for DeclareCursorStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ClosePortalStmt() {
    assert_eq!(::std::mem::size_of::<ClosePortalStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ClosePortalStmt ) ));
    assert_eq! (::std::mem::align_of::<ClosePortalStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ClosePortalStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ClosePortalStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ClosePortalStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ClosePortalStmt ) ) . portalname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ClosePortalStmt ) ,
                "::" , stringify ! ( portalname ) ));
}
impl Clone for ClosePortalStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FetchDirection {
    FETCH_FORWARD = 0,
    FETCH_BACKWARD = 1,
    FETCH_ABSOLUTE = 2,
    FETCH_RELATIVE = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: bool_,
}
#[test]
fn bindgen_test_layout_FetchStmt() {
    assert_eq!(::std::mem::size_of::<FetchStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FetchStmt ) ));
    assert_eq! (::std::mem::align_of::<FetchStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FetchStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FetchStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FetchStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FetchStmt ) ) . direction as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FetchStmt ) , "::" ,
                stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FetchStmt ) ) . howMany as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FetchStmt ) , "::" ,
                stringify ! ( howMany ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FetchStmt ) ) . portalname as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FetchStmt ) , "::" ,
                stringify ! ( portalname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FetchStmt ) ) . ismove as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FetchStmt ) , "::" ,
                stringify ! ( ismove ) ));
}
impl Clone for FetchStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: bool_,
    pub primary: bool_,
    pub isconstraint: bool_,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub transformed: bool_,
    pub concurrent: bool_,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_IndexStmt() {
    assert_eq!(::std::mem::size_of::<IndexStmt>() , 96usize , concat ! (
               "Size of: " , stringify ! ( IndexStmt ) ));
    assert_eq! (::std::mem::align_of::<IndexStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . idxname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( idxname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . relation as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . accessMethod as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( accessMethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . tableSpace as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( tableSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . indexParams as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( indexParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . options as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . whereClause as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . excludeOpNames as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( excludeOpNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . idxcomment as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( idxcomment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . indexOid as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( indexOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . oldNode as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( oldNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . unique as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . primary as * const _ as
                usize } , 89usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( primary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . isconstraint as * const _
                as usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( isconstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . deferrable as * const _
                as usize } , 91usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( deferrable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . initdeferred as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( initdeferred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . transformed as * const _
                as usize } , 93usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( transformed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . concurrent as * const _
                as usize } , 94usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( concurrent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexStmt ) ) . if_not_exists as * const
                _ as usize } , 95usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexStmt ) , "::" ,
                stringify ! ( if_not_exists ) ));
}
impl Clone for IndexStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stat_types: *mut List,
    pub exprs: *mut List,
    pub relations: *mut List,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateStatsStmt() {
    assert_eq!(::std::mem::size_of::<CreateStatsStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( CreateStatsStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateStatsStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CreateStatsStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStatsStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStatsStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStatsStmt ) ) . defnames as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStatsStmt ) ,
                "::" , stringify ! ( defnames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStatsStmt ) ) . stat_types as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStatsStmt ) ,
                "::" , stringify ! ( stat_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStatsStmt ) ) . exprs as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStatsStmt ) ,
                "::" , stringify ! ( exprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStatsStmt ) ) . relations as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStatsStmt ) ,
                "::" , stringify ! ( relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateStatsStmt ) ) . if_not_exists as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateStatsStmt ) ,
                "::" , stringify ! ( if_not_exists ) ));
}
impl Clone for CreateStatsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub withClause: *mut List,
}
#[test]
fn bindgen_test_layout_CreateFunctionStmt() {
    assert_eq!(::std::mem::size_of::<CreateFunctionStmt>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( CreateFunctionStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateFunctionStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CreateFunctionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . replace as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( replace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . funcname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( funcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . parameters as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . returnType as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( returnType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . options as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateFunctionStmt ) ) . withClause as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateFunctionStmt ) ,
                "::" , stringify ! ( withClause ) ));
}
impl Clone for CreateFunctionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FunctionParameterMode {
    FUNC_PARAM_IN = 105,
    FUNC_PARAM_OUT = 111,
    FUNC_PARAM_INOUT = 98,
    FUNC_PARAM_VARIADIC = 118,
    FUNC_PARAM_TABLE = 116,
}
#[repr(C)]
#[derive(Copy)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
#[test]
fn bindgen_test_layout_FunctionParameter() {
    assert_eq!(::std::mem::size_of::<FunctionParameter>() , 40usize , concat !
               ( "Size of: " , stringify ! ( FunctionParameter ) ));
    assert_eq! (::std::mem::align_of::<FunctionParameter>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FunctionParameter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionParameter ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionParameter ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionParameter ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionParameter ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionParameter ) ) . argType as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionParameter ) ,
                "::" , stringify ! ( argType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionParameter ) ) . mode as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionParameter ) ,
                "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionParameter ) ) . defexpr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionParameter ) ,
                "::" , stringify ! ( defexpr ) ));
}
impl Clone for FunctionParameter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub func: *mut ObjectWithArgs,
    pub actions: *mut List,
}
#[test]
fn bindgen_test_layout_AlterFunctionStmt() {
    assert_eq!(::std::mem::size_of::<AlterFunctionStmt>() , 24usize , concat !
               ( "Size of: " , stringify ! ( AlterFunctionStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterFunctionStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterFunctionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFunctionStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFunctionStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFunctionStmt ) ) . func as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFunctionStmt ) ,
                "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterFunctionStmt ) ) . actions as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterFunctionStmt ) ,
                "::" , stringify ! ( actions ) ));
}
impl Clone for AlterFunctionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
#[test]
fn bindgen_test_layout_DoStmt() {
    assert_eq!(::std::mem::size_of::<DoStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( DoStmt ) ));
    assert_eq! (::std::mem::align_of::<DoStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DoStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DoStmt ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DoStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DoStmt ) ) . args as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DoStmt ) , "::" ,
                stringify ! ( args ) ));
}
impl Clone for DoStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool_,
}
#[test]
fn bindgen_test_layout_InlineCodeBlock() {
    assert_eq!(::std::mem::size_of::<InlineCodeBlock>() , 24usize , concat ! (
               "Size of: " , stringify ! ( InlineCodeBlock ) ));
    assert_eq! (::std::mem::align_of::<InlineCodeBlock>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( InlineCodeBlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InlineCodeBlock ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( InlineCodeBlock ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InlineCodeBlock ) ) . source_text as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( InlineCodeBlock ) ,
                "::" , stringify ! ( source_text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InlineCodeBlock ) ) . langOid as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( InlineCodeBlock ) ,
                "::" , stringify ! ( langOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const InlineCodeBlock ) ) . langIsTrusted as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( InlineCodeBlock ) ,
                "::" , stringify ! ( langIsTrusted ) ));
}
impl Clone for InlineCodeBlock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_RenameStmt() {
    assert_eq!(::std::mem::size_of::<RenameStmt>() , 56usize , concat ! (
               "Size of: " , stringify ! ( RenameStmt ) ));
    assert_eq! (::std::mem::align_of::<RenameStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RenameStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . renameType as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( renameType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . relationType as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( relationType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . relation as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . object as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . subname as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( subname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . newname as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( newname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . behavior as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenameStmt ) ) . missing_ok as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( RenameStmt ) , "::" ,
                stringify ! ( missing_ok ) ));
}
impl Clone for RenameStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub extname: *mut Value,
}
#[test]
fn bindgen_test_layout_AlterObjectDependsStmt() {
    assert_eq!(::std::mem::size_of::<AlterObjectDependsStmt>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( AlterObjectDependsStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterObjectDependsStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterObjectDependsStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectDependsStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectDependsStmt
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectDependsStmt ) ) . objectType
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectDependsStmt
                ) , "::" , stringify ! ( objectType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectDependsStmt ) ) . relation as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectDependsStmt
                ) , "::" , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectDependsStmt ) ) . object as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectDependsStmt
                ) , "::" , stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectDependsStmt ) ) . extname as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectDependsStmt
                ) , "::" , stringify ! ( extname ) ));
}
impl Clone for AlterObjectDependsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterObjectSchemaStmt() {
    assert_eq!(::std::mem::size_of::<AlterObjectSchemaStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( AlterObjectSchemaStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterObjectSchemaStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterObjectSchemaStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectSchemaStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectSchemaStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectSchemaStmt ) ) . objectType as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectSchemaStmt )
                , "::" , stringify ! ( objectType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectSchemaStmt ) ) . relation as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectSchemaStmt )
                , "::" , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectSchemaStmt ) ) . object as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectSchemaStmt )
                , "::" , stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectSchemaStmt ) ) . newschema as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectSchemaStmt )
                , "::" , stringify ! ( newschema ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterObjectSchemaStmt ) ) . missing_ok as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterObjectSchemaStmt )
                , "::" , stringify ! ( missing_ok ) ));
}
impl Clone for AlterObjectSchemaStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newowner: *mut RoleSpec,
}
#[test]
fn bindgen_test_layout_AlterOwnerStmt() {
    assert_eq!(::std::mem::size_of::<AlterOwnerStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AlterOwnerStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterOwnerStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterOwnerStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOwnerStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOwnerStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOwnerStmt ) ) . objectType as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOwnerStmt ) , "::"
                , stringify ! ( objectType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOwnerStmt ) ) . relation as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOwnerStmt ) , "::"
                , stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOwnerStmt ) ) . object as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOwnerStmt ) , "::"
                , stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOwnerStmt ) ) . newowner as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOwnerStmt ) , "::"
                , stringify ! ( newowner ) ));
}
impl Clone for AlterOwnerStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: *mut ObjectWithArgs,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterOperatorStmt() {
    assert_eq!(::std::mem::size_of::<AlterOperatorStmt>() , 24usize , concat !
               ( "Size of: " , stringify ! ( AlterOperatorStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterOperatorStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterOperatorStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOperatorStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOperatorStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOperatorStmt ) ) . opername as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOperatorStmt ) ,
                "::" , stringify ! ( opername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterOperatorStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterOperatorStmt ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for AlterOperatorStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: bool_,
    pub actions: *mut List,
    pub replace: bool_,
}
#[test]
fn bindgen_test_layout_RuleStmt() {
    assert_eq!(::std::mem::size_of::<RuleStmt>() , 56usize , concat ! (
               "Size of: " , stringify ! ( RuleStmt ) ));
    assert_eq! (::std::mem::align_of::<RuleStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RuleStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . rulename as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( rulename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . whereClause as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( whereClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . event as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . instead as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( instead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . actions as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( actions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleStmt ) ) . replace as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleStmt ) , "::" ,
                stringify ! ( replace ) ));
}
impl Clone for RuleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotifyStmt() {
    assert_eq!(::std::mem::size_of::<NotifyStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( NotifyStmt ) ));
    assert_eq! (::std::mem::align_of::<NotifyStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( NotifyStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotifyStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NotifyStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotifyStmt ) ) . conditionname as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NotifyStmt ) , "::" ,
                stringify ! ( conditionname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotifyStmt ) ) . payload as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( NotifyStmt ) , "::" ,
                stringify ! ( payload ) ));
}
impl Clone for NotifyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ListenStmt() {
    assert_eq!(::std::mem::size_of::<ListenStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ListenStmt ) ));
    assert_eq! (::std::mem::align_of::<ListenStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ListenStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListenStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ListenStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ListenStmt ) ) . conditionname as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ListenStmt ) , "::" ,
                stringify ! ( conditionname ) ));
}
impl Clone for ListenStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_UnlistenStmt() {
    assert_eq!(::std::mem::size_of::<UnlistenStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( UnlistenStmt ) ));
    assert_eq! (::std::mem::align_of::<UnlistenStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( UnlistenStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UnlistenStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UnlistenStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UnlistenStmt ) ) . conditionname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( UnlistenStmt ) , "::" ,
                stringify ! ( conditionname ) ));
}
impl Clone for UnlistenStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TransactionStmtKind {
    TRANS_STMT_BEGIN = 0,
    TRANS_STMT_START = 1,
    TRANS_STMT_COMMIT = 2,
    TRANS_STMT_ROLLBACK = 3,
    TRANS_STMT_SAVEPOINT = 4,
    TRANS_STMT_RELEASE = 5,
    TRANS_STMT_ROLLBACK_TO = 6,
    TRANS_STMT_PREPARE = 7,
    TRANS_STMT_COMMIT_PREPARED = 8,
    TRANS_STMT_ROLLBACK_PREPARED = 9,
}
#[repr(C)]
#[derive(Copy)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub gid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_TransactionStmt() {
    assert_eq!(::std::mem::size_of::<TransactionStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( TransactionStmt ) ));
    assert_eq! (::std::mem::align_of::<TransactionStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TransactionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TransactionStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TransactionStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TransactionStmt ) ) . kind as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TransactionStmt ) ,
                "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TransactionStmt ) ) . options as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TransactionStmt ) ,
                "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TransactionStmt ) ) . gid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TransactionStmt ) ,
                "::" , stringify ! ( gid ) ));
}
impl Clone for TransactionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
#[test]
fn bindgen_test_layout_CompositeTypeStmt() {
    assert_eq!(::std::mem::size_of::<CompositeTypeStmt>() , 24usize , concat !
               ( "Size of: " , stringify ! ( CompositeTypeStmt ) ));
    assert_eq! (::std::mem::align_of::<CompositeTypeStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CompositeTypeStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CompositeTypeStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CompositeTypeStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CompositeTypeStmt ) ) . typevar as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CompositeTypeStmt ) ,
                "::" , stringify ! ( typevar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CompositeTypeStmt ) ) . coldeflist as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CompositeTypeStmt ) ,
                "::" , stringify ! ( coldeflist ) ));
}
impl Clone for CompositeTypeStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
#[test]
fn bindgen_test_layout_CreateEnumStmt() {
    assert_eq!(::std::mem::size_of::<CreateEnumStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CreateEnumStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateEnumStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateEnumStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEnumStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEnumStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEnumStmt ) ) . typeName as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEnumStmt ) , "::"
                , stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateEnumStmt ) ) . vals as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateEnumStmt ) , "::"
                , stringify ! ( vals ) ));
}
impl Clone for CreateEnumStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
#[test]
fn bindgen_test_layout_CreateRangeStmt() {
    assert_eq!(::std::mem::size_of::<CreateRangeStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CreateRangeStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateRangeStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CreateRangeStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRangeStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRangeStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRangeStmt ) ) . typeName as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRangeStmt ) ,
                "::" , stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateRangeStmt ) ) . params as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateRangeStmt ) ,
                "::" , stringify ! ( params ) ));
}
impl Clone for CreateRangeStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub oldVal: *mut ::std::os::raw::c_char,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: bool_,
    pub skipIfNewValExists: bool_,
}
#[test]
fn bindgen_test_layout_AlterEnumStmt() {
    assert_eq!(::std::mem::size_of::<AlterEnumStmt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( AlterEnumStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterEnumStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AlterEnumStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . typeName as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( typeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . oldVal as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( oldVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . newVal as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( newVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . newValNeighbor as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( newValNeighbor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . newValIsAfter as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( newValIsAfter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterEnumStmt ) ) . skipIfNewValExists as
                * const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterEnumStmt ) , "::"
                , stringify ! ( skipIfNewValExists ) ));
}
impl Clone for AlterEnumStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ViewCheckOption {
    NO_CHECK_OPTION = 0,
    LOCAL_CHECK_OPTION = 1,
    CASCADED_CHECK_OPTION = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool_,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
#[test]
fn bindgen_test_layout_ViewStmt() {
    assert_eq!(::std::mem::size_of::<ViewStmt>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ViewStmt ) ));
    assert_eq! (::std::mem::align_of::<ViewStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ViewStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . view as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( view ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . aliases as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . query as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . replace as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( replace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . options as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewStmt ) ) . withCheckOption as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewStmt ) , "::" ,
                stringify ! ( withCheckOption ) ));
}
impl Clone for ViewStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_LoadStmt() {
    assert_eq!(::std::mem::size_of::<LoadStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( LoadStmt ) ));
    assert_eq! (::std::mem::align_of::<LoadStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LoadStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LoadStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LoadStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LoadStmt ) ) . filename as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LoadStmt ) , "::" ,
                stringify ! ( filename ) ));
}
impl Clone for LoadStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreatedbStmt() {
    assert_eq!(::std::mem::size_of::<CreatedbStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( CreatedbStmt ) ));
    assert_eq! (::std::mem::align_of::<CreatedbStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreatedbStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatedbStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatedbStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatedbStmt ) ) . dbname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatedbStmt ) , "::" ,
                stringify ! ( dbname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatedbStmt ) ) . options as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatedbStmt ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for CreatedbStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterDatabaseStmt() {
    assert_eq!(::std::mem::size_of::<AlterDatabaseStmt>() , 24usize , concat !
               ( "Size of: " , stringify ! ( AlterDatabaseStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterDatabaseStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AlterDatabaseStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDatabaseStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDatabaseStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDatabaseStmt ) ) . dbname as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDatabaseStmt ) ,
                "::" , stringify ! ( dbname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDatabaseStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDatabaseStmt ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for AlterDatabaseStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterDatabaseSetStmt() {
    assert_eq!(::std::mem::size_of::<AlterDatabaseSetStmt>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( AlterDatabaseSetStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterDatabaseSetStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterDatabaseSetStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDatabaseSetStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDatabaseSetStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDatabaseSetStmt ) ) . dbname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDatabaseSetStmt )
                , "::" , stringify ! ( dbname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterDatabaseSetStmt ) ) . setstmt as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterDatabaseSetStmt )
                , "::" , stringify ! ( setstmt ) ));
}
impl Clone for AlterDatabaseSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropdbStmt() {
    assert_eq!(::std::mem::size_of::<DropdbStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( DropdbStmt ) ));
    assert_eq! (::std::mem::align_of::<DropdbStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DropdbStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropdbStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropdbStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropdbStmt ) ) . dbname as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropdbStmt ) , "::" ,
                stringify ! ( dbname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropdbStmt ) ) . missing_ok as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropdbStmt ) , "::" ,
                stringify ! ( missing_ok ) ));
}
impl Clone for DropdbStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterSystemStmt() {
    assert_eq!(::std::mem::size_of::<AlterSystemStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( AlterSystemStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterSystemStmt>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AlterSystemStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSystemStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSystemStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSystemStmt ) ) . setstmt as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSystemStmt ) ,
                "::" , stringify ! ( setstmt ) ));
}
impl Clone for AlterSystemStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub verbose: bool_,
}
#[test]
fn bindgen_test_layout_ClusterStmt() {
    assert_eq!(::std::mem::size_of::<ClusterStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ClusterStmt ) ));
    assert_eq! (::std::mem::align_of::<ClusterStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ClusterStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ClusterStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ClusterStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ClusterStmt ) ) . relation as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ClusterStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ClusterStmt ) ) . indexname as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ClusterStmt ) , "::" ,
                stringify ! ( indexname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ClusterStmt ) ) . verbose as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ClusterStmt ) , "::" ,
                stringify ! ( verbose ) ));
}
impl Clone for ClusterStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VacuumOption {
    VACOPT_VACUUM = 1,
    VACOPT_ANALYZE = 2,
    VACOPT_VERBOSE = 4,
    VACOPT_FREEZE = 8,
    VACOPT_FULL = 16,
    VACOPT_NOWAIT = 32,
    VACOPT_SKIPTOAST = 64,
    VACOPT_DISABLE_PAGE_SKIPPING = 128,
}
#[repr(C)]
#[derive(Copy)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: ::std::os::raw::c_int,
    pub relation: *mut RangeVar,
    pub va_cols: *mut List,
}
#[test]
fn bindgen_test_layout_VacuumStmt() {
    assert_eq!(::std::mem::size_of::<VacuumStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( VacuumStmt ) ));
    assert_eq! (::std::mem::align_of::<VacuumStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VacuumStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VacuumStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VacuumStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VacuumStmt ) ) . options as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VacuumStmt ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VacuumStmt ) ) . relation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VacuumStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VacuumStmt ) ) . va_cols as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VacuumStmt ) , "::" ,
                stringify ! ( va_cols ) ));
}
impl Clone for VacuumStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ExplainStmt() {
    assert_eq!(::std::mem::size_of::<ExplainStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ExplainStmt ) ));
    assert_eq! (::std::mem::align_of::<ExplainStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExplainStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExplainStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExplainStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExplainStmt ) ) . query as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExplainStmt ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExplainStmt ) ) . options as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExplainStmt ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for ExplainStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: bool_,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateTableAsStmt() {
    assert_eq!(::std::mem::size_of::<CreateTableAsStmt>() , 32usize , concat !
               ( "Size of: " , stringify ! ( CreateTableAsStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateTableAsStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CreateTableAsStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableAsStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableAsStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableAsStmt ) ) . query as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableAsStmt ) ,
                "::" , stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableAsStmt ) ) . into as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableAsStmt ) ,
                "::" , stringify ! ( into ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableAsStmt ) ) . relkind as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableAsStmt ) ,
                "::" , stringify ! ( relkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableAsStmt ) ) . is_select_into as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableAsStmt ) ,
                "::" , stringify ! ( is_select_into ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTableAsStmt ) ) . if_not_exists as
                * const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTableAsStmt ) ,
                "::" , stringify ! ( if_not_exists ) ));
}
impl Clone for CreateTableAsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool_,
    pub skipData: bool_,
    pub relation: *mut RangeVar,
}
#[test]
fn bindgen_test_layout_RefreshMatViewStmt() {
    assert_eq!(::std::mem::size_of::<RefreshMatViewStmt>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( RefreshMatViewStmt ) ));
    assert_eq! (::std::mem::align_of::<RefreshMatViewStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( RefreshMatViewStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RefreshMatViewStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RefreshMatViewStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RefreshMatViewStmt ) ) . concurrent as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RefreshMatViewStmt ) ,
                "::" , stringify ! ( concurrent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RefreshMatViewStmt ) ) . skipData as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( RefreshMatViewStmt ) ,
                "::" , stringify ! ( skipData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RefreshMatViewStmt ) ) . relation as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RefreshMatViewStmt ) ,
                "::" , stringify ! ( relation ) ));
}
impl Clone for RefreshMatViewStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_CheckPointStmt() {
    assert_eq!(::std::mem::size_of::<CheckPointStmt>() , 4usize , concat ! (
               "Size of: " , stringify ! ( CheckPointStmt ) ));
    assert_eq! (::std::mem::align_of::<CheckPointStmt>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CheckPointStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckPointStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckPointStmt ) , "::"
                , stringify ! ( type_ ) ));
}
impl Clone for CheckPointStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DiscardMode {
    DISCARD_ALL = 0,
    DISCARD_PLANS = 1,
    DISCARD_SEQUENCES = 2,
    DISCARD_TEMP = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
#[test]
fn bindgen_test_layout_DiscardStmt() {
    assert_eq!(::std::mem::size_of::<DiscardStmt>() , 8usize , concat ! (
               "Size of: " , stringify ! ( DiscardStmt ) ));
    assert_eq! (::std::mem::align_of::<DiscardStmt>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( DiscardStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DiscardStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DiscardStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DiscardStmt ) ) . target as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( DiscardStmt ) , "::" ,
                stringify ! ( target ) ));
}
impl Clone for DiscardStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool_,
}
#[test]
fn bindgen_test_layout_LockStmt() {
    assert_eq!(::std::mem::size_of::<LockStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( LockStmt ) ));
    assert_eq! (::std::mem::align_of::<LockStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockStmt ) ) . relations as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LockStmt ) , "::" ,
                stringify ! ( relations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockStmt ) ) . mode as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LockStmt ) , "::" ,
                stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockStmt ) ) . nowait as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( LockStmt ) , "::" ,
                stringify ! ( nowait ) ));
}
impl Clone for LockStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool_,
}
#[test]
fn bindgen_test_layout_ConstraintsSetStmt() {
    assert_eq!(::std::mem::size_of::<ConstraintsSetStmt>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( ConstraintsSetStmt ) ));
    assert_eq! (::std::mem::align_of::<ConstraintsSetStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ConstraintsSetStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConstraintsSetStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ConstraintsSetStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConstraintsSetStmt ) ) . constraints as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ConstraintsSetStmt ) ,
                "::" , stringify ! ( constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ConstraintsSetStmt ) ) . deferred as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ConstraintsSetStmt ) ,
                "::" , stringify ! ( deferred ) ));
}
impl Clone for ConstraintsSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ReindexObjectType {
    REINDEX_OBJECT_INDEX = 0,
    REINDEX_OBJECT_TABLE = 1,
    REINDEX_OBJECT_SCHEMA = 2,
    REINDEX_OBJECT_SYSTEM = 3,
    REINDEX_OBJECT_DATABASE = 4,
}
#[repr(C)]
#[derive(Copy)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ReindexStmt() {
    assert_eq!(::std::mem::size_of::<ReindexStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ReindexStmt ) ));
    assert_eq! (::std::mem::align_of::<ReindexStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ReindexStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReindexStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReindexStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReindexStmt ) ) . kind as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ReindexStmt ) , "::" ,
                stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReindexStmt ) ) . relation as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReindexStmt ) , "::" ,
                stringify ! ( relation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReindexStmt ) ) . name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ReindexStmt ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReindexStmt ) ) . options as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ReindexStmt ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for ReindexStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: bool_,
}
#[test]
fn bindgen_test_layout_CreateConversionStmt() {
    assert_eq!(::std::mem::size_of::<CreateConversionStmt>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( CreateConversionStmt )
               ));
    assert_eq! (::std::mem::align_of::<CreateConversionStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateConversionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateConversionStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateConversionStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateConversionStmt ) ) .
                conversion_name as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateConversionStmt )
                , "::" , stringify ! ( conversion_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateConversionStmt ) ) .
                for_encoding_name as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( CreateConversionStmt )
                , "::" , stringify ! ( for_encoding_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateConversionStmt ) ) .
                to_encoding_name as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( CreateConversionStmt )
                , "::" , stringify ! ( to_encoding_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateConversionStmt ) ) . func_name as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateConversionStmt )
                , "::" , stringify ! ( func_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateConversionStmt ) ) . def as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateConversionStmt )
                , "::" , stringify ! ( def ) ));
}
impl Clone for CreateConversionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut ObjectWithArgs,
    pub context: CoercionContext,
    pub inout: bool_,
}
#[test]
fn bindgen_test_layout_CreateCastStmt() {
    assert_eq!(::std::mem::size_of::<CreateCastStmt>() , 40usize , concat ! (
               "Size of: " , stringify ! ( CreateCastStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateCastStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CreateCastStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateCastStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateCastStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateCastStmt ) ) . sourcetype as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateCastStmt ) , "::"
                , stringify ! ( sourcetype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateCastStmt ) ) . targettype as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateCastStmt ) , "::"
                , stringify ! ( targettype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateCastStmt ) ) . func as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateCastStmt ) , "::"
                , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateCastStmt ) ) . context as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateCastStmt ) , "::"
                , stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateCastStmt ) ) . inout as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateCastStmt ) , "::"
                , stringify ! ( inout ) ));
}
impl Clone for CreateCastStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub type_name: *mut TypeName,
    pub lang: *mut ::std::os::raw::c_char,
    pub fromsql: *mut ObjectWithArgs,
    pub tosql: *mut ObjectWithArgs,
}
#[test]
fn bindgen_test_layout_CreateTransformStmt() {
    assert_eq!(::std::mem::size_of::<CreateTransformStmt>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( CreateTransformStmt ) ));
    assert_eq! (::std::mem::align_of::<CreateTransformStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateTransformStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTransformStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTransformStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTransformStmt ) ) . replace as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTransformStmt ) ,
                "::" , stringify ! ( replace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTransformStmt ) ) . type_name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTransformStmt ) ,
                "::" , stringify ! ( type_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTransformStmt ) ) . lang as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTransformStmt ) ,
                "::" , stringify ! ( lang ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTransformStmt ) ) . fromsql as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTransformStmt ) ,
                "::" , stringify ! ( fromsql ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateTransformStmt ) ) . tosql as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateTransformStmt ) ,
                "::" , stringify ! ( tosql ) ));
}
impl Clone for CreateTransformStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
#[test]
fn bindgen_test_layout_PrepareStmt() {
    assert_eq!(::std::mem::size_of::<PrepareStmt>() , 32usize , concat ! (
               "Size of: " , stringify ! ( PrepareStmt ) ));
    assert_eq! (::std::mem::align_of::<PrepareStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PrepareStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PrepareStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PrepareStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PrepareStmt ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PrepareStmt ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PrepareStmt ) ) . argtypes as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PrepareStmt ) , "::" ,
                stringify ! ( argtypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PrepareStmt ) ) . query as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PrepareStmt ) , "::" ,
                stringify ! ( query ) ));
}
impl Clone for PrepareStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
#[test]
fn bindgen_test_layout_ExecuteStmt() {
    assert_eq!(::std::mem::size_of::<ExecuteStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ExecuteStmt ) ));
    assert_eq! (::std::mem::align_of::<ExecuteStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ExecuteStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecuteStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecuteStmt ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecuteStmt ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecuteStmt ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExecuteStmt ) ) . params as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ExecuteStmt ) , "::" ,
                stringify ! ( params ) ));
}
impl Clone for ExecuteStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DeallocateStmt() {
    assert_eq!(::std::mem::size_of::<DeallocateStmt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( DeallocateStmt ) ));
    assert_eq! (::std::mem::align_of::<DeallocateStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DeallocateStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeallocateStmt ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DeallocateStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DeallocateStmt ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DeallocateStmt ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for DeallocateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_DropOwnedStmt() {
    assert_eq!(::std::mem::size_of::<DropOwnedStmt>() , 24usize , concat ! (
               "Size of: " , stringify ! ( DropOwnedStmt ) ));
    assert_eq! (::std::mem::align_of::<DropOwnedStmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DropOwnedStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropOwnedStmt ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropOwnedStmt ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropOwnedStmt ) ) . roles as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropOwnedStmt ) , "::"
                , stringify ! ( roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropOwnedStmt ) ) . behavior as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropOwnedStmt ) , "::"
                , stringify ! ( behavior ) ));
}
impl Clone for DropOwnedStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut RoleSpec,
}
#[test]
fn bindgen_test_layout_ReassignOwnedStmt() {
    assert_eq!(::std::mem::size_of::<ReassignOwnedStmt>() , 24usize , concat !
               ( "Size of: " , stringify ! ( ReassignOwnedStmt ) ));
    assert_eq! (::std::mem::align_of::<ReassignOwnedStmt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ReassignOwnedStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReassignOwnedStmt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReassignOwnedStmt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReassignOwnedStmt ) ) . roles as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReassignOwnedStmt ) ,
                "::" , stringify ! ( roles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReassignOwnedStmt ) ) . newrole as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ReassignOwnedStmt ) ,
                "::" , stringify ! ( newrole ) ));
}
impl Clone for ReassignOwnedStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterTSDictionaryStmt() {
    assert_eq!(::std::mem::size_of::<AlterTSDictionaryStmt>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( AlterTSDictionaryStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterTSDictionaryStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterTSDictionaryStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSDictionaryStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTSDictionaryStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSDictionaryStmt ) ) . dictname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTSDictionaryStmt )
                , "::" , stringify ! ( dictname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSDictionaryStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterTSDictionaryStmt )
                , "::" , stringify ! ( options ) ));
}
impl Clone for AlterTSDictionaryStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AlterTSConfigType {
    ALTER_TSCONFIG_ADD_MAPPING = 0,
    ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = 1,
    ALTER_TSCONFIG_REPLACE_DICT = 2,
    ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = 3,
    ALTER_TSCONFIG_DROP_MAPPING = 4,
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool_,
    pub replace: bool_,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterTSConfigurationStmt() {
    assert_eq!(::std::mem::size_of::<AlterTSConfigurationStmt>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( AlterTSConfigurationStmt ) ));
    assert_eq! (::std::mem::align_of::<AlterTSConfigurationStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterTSConfigurationStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . kind as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . cfgname as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( cfgname )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . tokentype
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( tokentype )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . dicts as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( dicts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . override_
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( override_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . replace as
                * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( replace )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterTSConfigurationStmt ) ) . missing_ok
                as * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! (
                AlterTSConfigurationStmt ) , "::" , stringify ! ( missing_ok )
                ));
}
impl Clone for AlterTSConfigurationStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreatePublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub tables: *mut List,
    pub for_all_tables: bool_,
}
#[test]
fn bindgen_test_layout_CreatePublicationStmt() {
    assert_eq!(::std::mem::size_of::<CreatePublicationStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( CreatePublicationStmt )
               ));
    assert_eq! (::std::mem::align_of::<CreatePublicationStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreatePublicationStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePublicationStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePublicationStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePublicationStmt ) ) . pubname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePublicationStmt )
                , "::" , stringify ! ( pubname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePublicationStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePublicationStmt )
                , "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePublicationStmt ) ) . tables as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePublicationStmt )
                , "::" , stringify ! ( tables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreatePublicationStmt ) ) .
                for_all_tables as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreatePublicationStmt )
                , "::" , stringify ! ( for_all_tables ) ));
}
impl Clone for CreatePublicationStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterPublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub tables: *mut List,
    pub for_all_tables: bool_,
    pub tableAction: DefElemAction,
}
#[test]
fn bindgen_test_layout_AlterPublicationStmt() {
    assert_eq!(::std::mem::size_of::<AlterPublicationStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( AlterPublicationStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterPublicationStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterPublicationStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPublicationStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPublicationStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPublicationStmt ) ) . pubname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPublicationStmt )
                , "::" , stringify ! ( pubname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPublicationStmt ) ) . options as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPublicationStmt )
                , "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPublicationStmt ) ) . tables as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPublicationStmt )
                , "::" , stringify ! ( tables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPublicationStmt ) ) . for_all_tables
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPublicationStmt )
                , "::" , stringify ! ( for_all_tables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterPublicationStmt ) ) . tableAction as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterPublicationStmt )
                , "::" , stringify ! ( tableAction ) ));
}
impl Clone for AlterPublicationStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CreateSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateSubscriptionStmt() {
    assert_eq!(::std::mem::size_of::<CreateSubscriptionStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( CreateSubscriptionStmt )
               ));
    assert_eq! (::std::mem::align_of::<CreateSubscriptionStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CreateSubscriptionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSubscriptionStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSubscriptionStmt
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSubscriptionStmt ) ) . subname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSubscriptionStmt
                ) , "::" , stringify ! ( subname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSubscriptionStmt ) ) . conninfo as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSubscriptionStmt
                ) , "::" , stringify ! ( conninfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSubscriptionStmt ) ) . publication
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSubscriptionStmt
                ) , "::" , stringify ! ( publication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CreateSubscriptionStmt ) ) . options as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CreateSubscriptionStmt
                ) , "::" , stringify ! ( options ) ));
}
impl Clone for CreateSubscriptionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AlterSubscriptionType {
    ALTER_SUBSCRIPTION_OPTIONS = 0,
    ALTER_SUBSCRIPTION_CONNECTION = 1,
    ALTER_SUBSCRIPTION_PUBLICATION = 2,
    ALTER_SUBSCRIPTION_REFRESH = 3,
    ALTER_SUBSCRIPTION_ENABLED = 4,
}
#[repr(C)]
#[derive(Copy)]
pub struct AlterSubscriptionStmt {
    pub type_: NodeTag,
    pub kind: AlterSubscriptionType,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterSubscriptionStmt() {
    assert_eq!(::std::mem::size_of::<AlterSubscriptionStmt>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( AlterSubscriptionStmt )
               ));
    assert_eq! (::std::mem::align_of::<AlterSubscriptionStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AlterSubscriptionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSubscriptionStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSubscriptionStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSubscriptionStmt ) ) . kind as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSubscriptionStmt )
                , "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSubscriptionStmt ) ) . subname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSubscriptionStmt )
                , "::" , stringify ! ( subname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSubscriptionStmt ) ) . conninfo as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSubscriptionStmt )
                , "::" , stringify ! ( conninfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSubscriptionStmt ) ) . publication
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSubscriptionStmt )
                , "::" , stringify ! ( publication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AlterSubscriptionStmt ) ) . options as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AlterSubscriptionStmt )
                , "::" , stringify ! ( options ) ));
}
impl Clone for AlterSubscriptionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DropSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_DropSubscriptionStmt() {
    assert_eq!(::std::mem::size_of::<DropSubscriptionStmt>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( DropSubscriptionStmt )
               ));
    assert_eq! (::std::mem::align_of::<DropSubscriptionStmt>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( DropSubscriptionStmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropSubscriptionStmt ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DropSubscriptionStmt )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropSubscriptionStmt ) ) . subname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DropSubscriptionStmt )
                , "::" , stringify ! ( subname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropSubscriptionStmt ) ) . missing_ok as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DropSubscriptionStmt )
                , "::" , stringify ! ( missing_ok ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DropSubscriptionStmt ) ) . behavior as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( DropSubscriptionStmt )
                , "::" , stringify ! ( behavior ) ));
}
impl Clone for DropSubscriptionStmt {
    fn clone(&self) -> Self { *self }
}
pub type Relids = *mut Bitmapset;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CostSelector { STARTUP_COST = 0, TOTAL_COST = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[test]
fn bindgen_test_layout_QualCost() {
    assert_eq!(::std::mem::size_of::<QualCost>() , 16usize , concat ! (
               "Size of: " , stringify ! ( QualCost ) ));
    assert_eq! (::std::mem::align_of::<QualCost>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( QualCost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const QualCost ) ) . startup as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( QualCost ) , "::" ,
                stringify ! ( startup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const QualCost ) ) . per_tuple as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( QualCost ) , "::" ,
                stringify ! ( per_tuple ) ));
}
impl Clone for QualCost {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AggClauseCosts {
    pub numAggs: ::std::os::raw::c_int,
    pub numOrderedAggs: ::std::os::raw::c_int,
    pub hasNonPartial: bool_,
    pub hasNonSerial: bool_,
    pub transCost: QualCost,
    pub finalCost: Cost,
    pub transitionSpace: Size,
}
#[test]
fn bindgen_test_layout_AggClauseCosts() {
    assert_eq!(::std::mem::size_of::<AggClauseCosts>() , 48usize , concat ! (
               "Size of: " , stringify ! ( AggClauseCosts ) ));
    assert_eq! (::std::mem::align_of::<AggClauseCosts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AggClauseCosts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . numAggs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( numAggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . numOrderedAggs as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( numOrderedAggs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . hasNonPartial as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( hasNonPartial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . hasNonSerial as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( hasNonSerial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . transCost as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( transCost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . finalCost as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( finalCost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggClauseCosts ) ) . transitionSpace as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AggClauseCosts ) , "::"
                , stringify ! ( transitionSpace ) ));
}
impl Clone for AggClauseCosts {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UpperRelationKind {
    UPPERREL_SETOP = 0,
    UPPERREL_GROUP_AGG = 1,
    UPPERREL_WINDOW = 2,
    UPPERREL_DISTINCT = 3,
    UPPERREL_ORDERED = 4,
    UPPERREL_FINAL = 5,
}
#[repr(C)]
#[derive(Copy)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: ParamListInfo,
    pub subplans: *mut List,
    pub subroots: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub finalrtable: *mut List,
    pub finalrowmarks: *mut List,
    pub resultRelations: *mut List,
    pub nonleafResultRelations: *mut List,
    pub rootResultRelations: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub nParamExec: ::std::os::raw::c_int,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub lastPlanNodeId: ::std::os::raw::c_int,
    pub transientPlan: bool_,
    pub dependsOnRole: bool_,
    pub parallelModeOK: bool_,
    pub parallelModeNeeded: bool_,
    pub maxParallelHazard: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PlannerGlobal() {
    assert_eq!(::std::mem::size_of::<PlannerGlobal>() , 120usize , concat ! (
               "Size of: " , stringify ! ( PlannerGlobal ) ));
    assert_eq! (::std::mem::align_of::<PlannerGlobal>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PlannerGlobal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . boundParams as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( boundParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . subplans as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( subplans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . subroots as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( subroots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . rewindPlanIDs as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( rewindPlanIDs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . finalrtable as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( finalrtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . finalrowmarks as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( finalrowmarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . resultRelations as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( resultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) .
                nonleafResultRelations as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( nonleafResultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . rootResultRelations
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( rootResultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . relationOids as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( relationOids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . invalItems as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( invalItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . nParamExec as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( nParamExec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . lastPHId as * const _
                as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( lastPHId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . lastRowMarkId as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( lastRowMarkId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . lastPlanNodeId as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( lastPlanNodeId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . transientPlan as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( transientPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . dependsOnRole as *
                const _ as usize } , 113usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( dependsOnRole ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . parallelModeOK as *
                const _ as usize } , 114usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( parallelModeOK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . parallelModeNeeded as
                * const _ as usize } , 115usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( parallelModeNeeded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerGlobal ) ) . maxParallelHazard as
                * const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerGlobal ) , "::"
                , stringify ! ( maxParallelHazard ) ));
}
impl Clone for PlannerGlobal {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RelOptKind {
    RELOPT_BASEREL = 0,
    RELOPT_JOINREL = 1,
    RELOPT_OTHER_MEMBER_REL = 2,
    RELOPT_UPPER_REL = 3,
    RELOPT_DEADREL = 4,
}
#[repr(C)]
#[derive(Copy)]
pub struct RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind,
    pub relids: Relids,
    pub rows: f64,
    pub consider_startup: bool_,
    pub consider_param_startup: bool_,
    pub consider_parallel: bool_,
    pub reltarget: *mut PathTarget,
    pub pathlist: *mut List,
    pub ppilist: *mut List,
    pub partial_pathlist: *mut List,
    pub cheapest_startup_path: *mut Path,
    pub cheapest_total_path: *mut Path,
    pub cheapest_unique_path: *mut Path,
    pub cheapest_parameterized_paths: *mut List,
    pub direct_lateral_relids: Relids,
    pub lateral_relids: Relids,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: *mut Relids,
    pub attr_widths: *mut int32,
    pub lateral_vars: *mut List,
    pub lateral_referencers: Relids,
    pub indexlist: *mut List,
    pub statlist: *mut List,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub allvisfrac: f64,
    pub subroot: *mut PlannerInfo,
    pub subplan_params: *mut List,
    pub rel_parallel_workers: ::std::os::raw::c_int,
    pub serverid: Oid,
    pub userid: Oid,
    pub useridiscurrent: bool_,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_private: *mut ::std::os::raw::c_void,
    pub unique_for_rels: *mut List,
    pub non_unique_for_rels: *mut List,
    pub baserestrictinfo: *mut List,
    pub baserestrictcost: QualCost,
    pub baserestrict_min_security: Index,
    pub joininfo: *mut List,
    pub has_eclass_joins: bool_,
    pub top_parent_relids: Relids,
}
#[test]
fn bindgen_test_layout_RelOptInfo() {
    assert_eq!(::std::mem::size_of::<RelOptInfo>() , 320usize , concat ! (
               "Size of: " , stringify ! ( RelOptInfo ) ));
    assert_eq! (::std::mem::align_of::<RelOptInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RelOptInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . reloptkind as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( reloptkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . relids as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . rows as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . consider_startup as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( consider_startup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . consider_param_startup
                as * const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( consider_param_startup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . consider_parallel as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( consider_parallel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . reltarget as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( reltarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . pathlist as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( pathlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . ppilist as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( ppilist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . partial_pathlist as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( partial_pathlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . cheapest_startup_path as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( cheapest_startup_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . cheapest_total_path as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( cheapest_total_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . cheapest_unique_path as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( cheapest_unique_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) .
                cheapest_parameterized_paths as * const _ as usize } , 88usize
                , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( cheapest_parameterized_paths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . direct_lateral_relids as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( direct_lateral_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . lateral_relids as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( lateral_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . relid as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . reltablespace as * const
                _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( reltablespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . rtekind as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( rtekind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . min_attr as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( min_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . max_attr as * const _ as
                usize } , 126usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( max_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . attr_needed as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( attr_needed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . attr_widths as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( attr_widths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . lateral_vars as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( lateral_vars ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . lateral_referencers as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( lateral_referencers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . indexlist as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( indexlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . statlist as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( statlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . pages as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . tuples as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( tuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . allvisfrac as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( allvisfrac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . subroot as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( subroot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . subplan_params as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( subplan_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . rel_parallel_workers as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( rel_parallel_workers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . serverid as * const _ as
                usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( serverid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . userid as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( userid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . useridiscurrent as *
                const _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( useridiscurrent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . fdwroutine as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( fdwroutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . fdw_private as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( fdw_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . unique_for_rels as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( unique_for_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . non_unique_for_rels as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( non_unique_for_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . baserestrictinfo as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( baserestrictinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . baserestrictcost as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( baserestrictcost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) .
                baserestrict_min_security as * const _ as usize } , 288usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( baserestrict_min_security ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . joininfo as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( joininfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . has_eclass_joins as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( has_eclass_joins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelOptInfo ) ) . top_parent_relids as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( RelOptInfo ) , "::" ,
                stringify ! ( top_parent_relids ) ));
}
impl Clone for RelOptInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: *mut RelOptInfo,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub tree_height: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
    pub indexkeys: *mut ::std::os::raw::c_int,
    pub indexcollations: *mut Oid,
    pub opfamily: *mut Oid,
    pub opcintype: *mut Oid,
    pub sortopfamily: *mut Oid,
    pub reverse_sort: *mut bool_,
    pub nulls_first: *mut bool_,
    pub canreturn: *mut bool_,
    pub relam: Oid,
    pub indexprs: *mut List,
    pub indpred: *mut List,
    pub indextlist: *mut List,
    pub indrestrictinfo: *mut List,
    pub predOK: bool_,
    pub unique: bool_,
    pub immediate: bool_,
    pub hypothetical: bool_,
    pub amcanorderbyop: bool_,
    pub amoptionalkey: bool_,
    pub amsearcharray: bool_,
    pub amsearchnulls: bool_,
    pub amhasgettuple: bool_,
    pub amhasgetbitmap: bool_,
    pub amcanparallel: bool_,
    pub amcostestimate: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_IndexOptInfo() {
    assert_eq!(::std::mem::size_of::<IndexOptInfo>() , 176usize , concat ! (
               "Size of: " , stringify ! ( IndexOptInfo ) ));
    assert_eq! (::std::mem::align_of::<IndexOptInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( IndexOptInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indexoid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indexoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . reltablespace as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( reltablespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . rel as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( rel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . pages as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . tuples as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( tuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . tree_height as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( tree_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . ncolumns as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( ncolumns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indexkeys as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indexkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indexcollations as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indexcollations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . opfamily as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( opfamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . opcintype as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( opcintype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . sortopfamily as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( sortopfamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . reverse_sort as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( reverse_sort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . nulls_first as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( nulls_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . canreturn as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( canreturn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . relam as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( relam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indexprs as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indpred as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indpred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indextlist as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indextlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . indrestrictinfo as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( indrestrictinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . predOK as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( predOK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . unique as * const _ as
                usize } , 153usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . immediate as * const _
                as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( immediate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . hypothetical as *
                const _ as usize } , 155usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( hypothetical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amcanorderbyop as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amcanorderbyop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amoptionalkey as *
                const _ as usize } , 157usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amoptionalkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amsearcharray as *
                const _ as usize } , 158usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amsearcharray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amsearchnulls as *
                const _ as usize } , 159usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amsearchnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amhasgettuple as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amhasgettuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amhasgetbitmap as *
                const _ as usize } , 161usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amhasgetbitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amcanparallel as *
                const _ as usize } , 162usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amcanparallel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IndexOptInfo ) ) . amcostestimate as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( IndexOptInfo ) , "::" ,
                stringify ! ( amcostestimate ) ));
}
impl Clone for IndexOptInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ForeignKeyOptInfo {
    pub type_: NodeTag,
    pub con_relid: Index,
    pub ref_relid: Index,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
    pub nmatched_ec: ::std::os::raw::c_int,
    pub nmatched_rcols: ::std::os::raw::c_int,
    pub nmatched_ri: ::std::os::raw::c_int,
    pub eclass: [*mut EquivalenceClass; 32usize],
    pub rinfos: [*mut List; 32usize],
}
#[test]
fn bindgen_test_layout_ForeignKeyOptInfo() {
    assert_eq!(::std::mem::size_of::<ForeignKeyOptInfo>() , 800usize , concat
               ! ( "Size of: " , stringify ! ( ForeignKeyOptInfo ) ));
    assert_eq! (::std::mem::align_of::<ForeignKeyOptInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ForeignKeyOptInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . con_relid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( con_relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . ref_relid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( ref_relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . nkeys as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( nkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . conkey as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( conkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . confkey as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( confkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . conpfeqop as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( conpfeqop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . nmatched_ec as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( nmatched_ec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . nmatched_rcols as
                * const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( nmatched_rcols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . nmatched_ri as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( nmatched_ri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . eclass as * const
                _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( eclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyOptInfo ) ) . rinfos as * const
                _ as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyOptInfo ) ,
                "::" , stringify ! ( rinfos ) ));
}
impl Clone for ForeignKeyOptInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct StatisticExtInfo {
    pub type_: NodeTag,
    pub statOid: Oid,
    pub rel: *mut RelOptInfo,
    pub kind: ::std::os::raw::c_char,
    pub keys: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_StatisticExtInfo() {
    assert_eq!(::std::mem::size_of::<StatisticExtInfo>() , 32usize , concat !
               ( "Size of: " , stringify ! ( StatisticExtInfo ) ));
    assert_eq! (::std::mem::align_of::<StatisticExtInfo>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( StatisticExtInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StatisticExtInfo ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( StatisticExtInfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StatisticExtInfo ) ) . statOid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( StatisticExtInfo ) ,
                "::" , stringify ! ( statOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StatisticExtInfo ) ) . rel as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( StatisticExtInfo ) ,
                "::" , stringify ! ( rel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StatisticExtInfo ) ) . kind as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( StatisticExtInfo ) ,
                "::" , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StatisticExtInfo ) ) . keys as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( StatisticExtInfo ) ,
                "::" , stringify ! ( keys ) ));
}
impl Clone for StatisticExtInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: *mut List,
    pub ec_collation: Oid,
    pub ec_members: *mut List,
    pub ec_sources: *mut List,
    pub ec_derives: *mut List,
    pub ec_relids: Relids,
    pub ec_has_const: bool_,
    pub ec_has_volatile: bool_,
    pub ec_below_outer_join: bool_,
    pub ec_broken: bool_,
    pub ec_sortref: Index,
    pub ec_min_security: Index,
    pub ec_max_security: Index,
    pub ec_merged: *mut EquivalenceClass,
}
#[test]
fn bindgen_test_layout_EquivalenceClass() {
    assert_eq!(::std::mem::size_of::<EquivalenceClass>() , 80usize , concat !
               ( "Size of: " , stringify ! ( EquivalenceClass ) ));
    assert_eq! (::std::mem::align_of::<EquivalenceClass>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( EquivalenceClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_opfamilies as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_opfamilies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_collation as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_members as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_sources as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_sources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_derives as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_derives ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_relids as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_has_const as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_has_const ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_has_volatile as
                * const _ as usize } , 57usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_has_volatile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) .
                ec_below_outer_join as * const _ as usize } , 58usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_below_outer_join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_broken as *
                const _ as usize } , 59usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_broken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_sortref as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_sortref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_min_security as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_min_security ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_max_security as
                * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_max_security ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceClass ) ) . ec_merged as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceClass ) ,
                "::" , stringify ! ( ec_merged ) ));
}
impl Clone for EquivalenceClass {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: *mut Expr,
    pub em_relids: Relids,
    pub em_nullable_relids: Relids,
    pub em_is_const: bool_,
    pub em_is_child: bool_,
    pub em_datatype: Oid,
}
#[test]
fn bindgen_test_layout_EquivalenceMember() {
    assert_eq!(::std::mem::size_of::<EquivalenceMember>() , 40usize , concat !
               ( "Size of: " , stringify ! ( EquivalenceMember ) ));
    assert_eq! (::std::mem::align_of::<EquivalenceMember>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EquivalenceMember ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) . em_expr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( em_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) . em_relids as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( em_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) .
                em_nullable_relids as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( em_nullable_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) . em_is_const as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( em_is_const ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) . em_is_child as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( em_is_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EquivalenceMember ) ) . em_datatype as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EquivalenceMember ) ,
                "::" , stringify ! ( em_datatype ) ));
}
impl Clone for EquivalenceMember {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: *mut EquivalenceClass,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::std::os::raw::c_int,
    pub pk_nulls_first: bool_,
}
#[test]
fn bindgen_test_layout_PathKey() {
    assert_eq!(::std::mem::size_of::<PathKey>() , 32usize , concat ! (
               "Size of: " , stringify ! ( PathKey ) ));
    assert_eq! (::std::mem::align_of::<PathKey>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PathKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathKey ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PathKey ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathKey ) ) . pk_eclass as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PathKey ) , "::" ,
                stringify ! ( pk_eclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathKey ) ) . pk_opfamily as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PathKey ) , "::" ,
                stringify ! ( pk_opfamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathKey ) ) . pk_strategy as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( PathKey ) , "::" ,
                stringify ! ( pk_strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathKey ) ) . pk_nulls_first as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PathKey ) , "::" ,
                stringify ! ( pk_nulls_first ) ));
}
impl Clone for PathKey {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PathTarget {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub sortgrouprefs: *mut Index,
    pub cost: QualCost,
    pub width: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PathTarget() {
    assert_eq!(::std::mem::size_of::<PathTarget>() , 48usize , concat ! (
               "Size of: " , stringify ! ( PathTarget ) ));
    assert_eq! (::std::mem::align_of::<PathTarget>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PathTarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathTarget ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PathTarget ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathTarget ) ) . exprs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PathTarget ) , "::" ,
                stringify ! ( exprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathTarget ) ) . sortgrouprefs as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PathTarget ) , "::" ,
                stringify ! ( sortgrouprefs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathTarget ) ) . cost as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PathTarget ) , "::" ,
                stringify ! ( cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PathTarget ) ) . width as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PathTarget ) , "::" ,
                stringify ! ( width ) ));
}
impl Clone for PathTarget {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: Relids,
    pub ppi_rows: f64,
    pub ppi_clauses: *mut List,
}
#[test]
fn bindgen_test_layout_ParamPathInfo() {
    assert_eq!(::std::mem::size_of::<ParamPathInfo>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ParamPathInfo ) ));
    assert_eq! (::std::mem::align_of::<ParamPathInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ParamPathInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamPathInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamPathInfo ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamPathInfo ) ) . ppi_req_outer as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamPathInfo ) , "::"
                , stringify ! ( ppi_req_outer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamPathInfo ) ) . ppi_rows as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamPathInfo ) , "::"
                , stringify ! ( ppi_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParamPathInfo ) ) . ppi_clauses as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ParamPathInfo ) , "::"
                , stringify ! ( ppi_clauses ) ));
}
impl Clone for ParamPathInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: *mut RelOptInfo,
    pub pathtarget: *mut PathTarget,
    pub param_info: *mut ParamPathInfo,
    pub parallel_aware: bool_,
    pub parallel_safe: bool_,
    pub parallel_workers: ::std::os::raw::c_int,
    pub rows: f64,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: *mut List,
}
#[test]
fn bindgen_test_layout_Path() {
    assert_eq!(::std::mem::size_of::<Path>() , 72usize , concat ! (
               "Size of: " , stringify ! ( Path ) ));
    assert_eq! (::std::mem::align_of::<Path>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . pathtype as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( pathtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . parent as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . pathtarget as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( pathtarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . param_info as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( param_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . parallel_aware as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( parallel_aware ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . parallel_safe as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( parallel_safe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . parallel_workers as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( parallel_workers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . rows as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . startup_cost as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( startup_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . total_cost as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( total_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Path ) ) . pathkeys as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Path ) , "::" ,
                stringify ! ( pathkeys ) ));
}
impl Clone for Path {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: *mut Path,
}
#[test]
fn bindgen_test_layout_BitmapHeapPath() {
    assert_eq!(::std::mem::size_of::<BitmapHeapPath>() , 80usize , concat ! (
               "Size of: " , stringify ! ( BitmapHeapPath ) ));
    assert_eq! (::std::mem::align_of::<BitmapHeapPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapHeapPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapPath ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapHeapPath ) ) . bitmapqual as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapHeapPath ) , "::"
                , stringify ! ( bitmapqual ) ));
}
impl Clone for BitmapHeapPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
#[test]
fn bindgen_test_layout_BitmapAndPath() {
    assert_eq!(::std::mem::size_of::<BitmapAndPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( BitmapAndPath ) ));
    assert_eq! (::std::mem::align_of::<BitmapAndPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapAndPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAndPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAndPath ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAndPath ) ) . bitmapquals as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAndPath ) , "::"
                , stringify ! ( bitmapquals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapAndPath ) ) . bitmapselectivity as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapAndPath ) , "::"
                , stringify ! ( bitmapselectivity ) ));
}
impl Clone for BitmapAndPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
#[test]
fn bindgen_test_layout_BitmapOrPath() {
    assert_eq!(::std::mem::size_of::<BitmapOrPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( BitmapOrPath ) ));
    assert_eq! (::std::mem::align_of::<BitmapOrPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BitmapOrPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOrPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOrPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOrPath ) ) . bitmapquals as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOrPath ) , "::" ,
                stringify ! ( bitmapquals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BitmapOrPath ) ) . bitmapselectivity as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( BitmapOrPath ) , "::" ,
                stringify ! ( bitmapselectivity ) ));
}
impl Clone for BitmapOrPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: *mut List,
}
#[test]
fn bindgen_test_layout_TidPath() {
    assert_eq!(::std::mem::size_of::<TidPath>() , 80usize , concat ! (
               "Size of: " , stringify ! ( TidPath ) ));
    assert_eq! (::std::mem::align_of::<TidPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TidPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidPath ) ) . path as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TidPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TidPath ) ) . tidquals as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TidPath ) , "::" ,
                stringify ! ( tidquals ) ));
}
impl Clone for TidPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SubqueryScanPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_SubqueryScanPath() {
    assert_eq!(::std::mem::size_of::<SubqueryScanPath>() , 80usize , concat !
               ( "Size of: " , stringify ! ( SubqueryScanPath ) ));
    assert_eq! (::std::mem::align_of::<SubqueryScanPath>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SubqueryScanPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubqueryScanPath ) ) . path as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SubqueryScanPath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SubqueryScanPath ) ) . subpath as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( SubqueryScanPath ) ,
                "::" , stringify ! ( subpath ) ));
}
impl Clone for SubqueryScanPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_outerpath: *mut Path,
    pub fdw_private: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignPath() {
    assert_eq!(::std::mem::size_of::<ForeignPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ForeignPath ) ));
    assert_eq! (::std::mem::align_of::<ForeignPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ForeignPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignPath ) ) . fdw_outerpath as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignPath ) , "::" ,
                stringify ! ( fdw_outerpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignPath ) ) . fdw_private as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignPath ) , "::" ,
                stringify ! ( fdw_private ) ));
}
impl Clone for ForeignPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPathMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct CustomPath {
    pub path: Path,
    pub flags: uint32,
    pub custom_paths: *mut List,
    pub custom_private: *mut List,
    pub methods: *const CustomPathMethods,
}
#[test]
fn bindgen_test_layout_CustomPath() {
    assert_eq!(::std::mem::size_of::<CustomPath>() , 104usize , concat ! (
               "Size of: " , stringify ! ( CustomPath ) ));
    assert_eq! (::std::mem::align_of::<CustomPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CustomPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomPath ) ) . flags as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomPath ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomPath ) ) . custom_paths as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomPath ) , "::" ,
                stringify ! ( custom_paths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomPath ) ) . custom_private as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomPath ) , "::" ,
                stringify ! ( custom_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CustomPath ) ) . methods as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( CustomPath ) , "::" ,
                stringify ! ( methods ) ));
}
impl Clone for CustomPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AppendPath {
    pub path: Path,
    pub partitioned_rels: *mut List,
    pub subpaths: *mut List,
}
#[test]
fn bindgen_test_layout_AppendPath() {
    assert_eq!(::std::mem::size_of::<AppendPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( AppendPath ) ));
    assert_eq! (::std::mem::align_of::<AppendPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AppendPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendPath ) ) . partitioned_rels as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendPath ) , "::" ,
                stringify ! ( partitioned_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendPath ) ) . subpaths as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendPath ) , "::" ,
                stringify ! ( subpaths ) ));
}
impl Clone for AppendPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MergeAppendPath {
    pub path: Path,
    pub partitioned_rels: *mut List,
    pub subpaths: *mut List,
    pub limit_tuples: f64,
}
#[test]
fn bindgen_test_layout_MergeAppendPath() {
    assert_eq!(::std::mem::size_of::<MergeAppendPath>() , 96usize , concat ! (
               "Size of: " , stringify ! ( MergeAppendPath ) ));
    assert_eq! (::std::mem::align_of::<MergeAppendPath>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( MergeAppendPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendPath ) ) . path as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendPath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendPath ) ) . partitioned_rels as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendPath ) ,
                "::" , stringify ! ( partitioned_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendPath ) ) . subpaths as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendPath ) ,
                "::" , stringify ! ( subpaths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeAppendPath ) ) . limit_tuples as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeAppendPath ) ,
                "::" , stringify ! ( limit_tuples ) ));
}
impl Clone for MergeAppendPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ResultPath {
    pub path: Path,
    pub quals: *mut List,
}
#[test]
fn bindgen_test_layout_ResultPath() {
    assert_eq!(::std::mem::size_of::<ResultPath>() , 80usize , concat ! (
               "Size of: " , stringify ! ( ResultPath ) ));
    assert_eq! (::std::mem::align_of::<ResultPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ResultPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ResultPath ) ) . quals as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ResultPath ) , "::" ,
                stringify ! ( quals ) ));
}
impl Clone for ResultPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_MaterialPath() {
    assert_eq!(::std::mem::size_of::<MaterialPath>() , 80usize , concat ! (
               "Size of: " , stringify ! ( MaterialPath ) ));
    assert_eq! (::std::mem::align_of::<MaterialPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MaterialPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MaterialPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MaterialPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MaterialPath ) ) . subpath as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( MaterialPath ) , "::" ,
                stringify ! ( subpath ) ));
}
impl Clone for MaterialPath {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UniquePathMethod {
    UNIQUE_PATH_NOOP = 0,
    UNIQUE_PATH_HASH = 1,
    UNIQUE_PATH_SORT = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub umethod: UniquePathMethod,
    pub in_operators: *mut List,
    pub uniq_exprs: *mut List,
}
#[test]
fn bindgen_test_layout_UniquePath() {
    assert_eq!(::std::mem::size_of::<UniquePath>() , 104usize , concat ! (
               "Size of: " , stringify ! ( UniquePath ) ));
    assert_eq! (::std::mem::align_of::<UniquePath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( UniquePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniquePath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UniquePath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniquePath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( UniquePath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniquePath ) ) . umethod as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( UniquePath ) , "::" ,
                stringify ! ( umethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniquePath ) ) . in_operators as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( UniquePath ) , "::" ,
                stringify ! ( in_operators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UniquePath ) ) . uniq_exprs as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( UniquePath ) , "::" ,
                stringify ! ( uniq_exprs ) ));
}
impl Clone for UniquePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GatherPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub single_copy: bool_,
    pub num_workers: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GatherPath() {
    assert_eq!(::std::mem::size_of::<GatherPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( GatherPath ) ));
    assert_eq! (::std::mem::align_of::<GatherPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GatherPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherPath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherPath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherPath ) ) . single_copy as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherPath ) , "::" ,
                stringify ! ( single_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherPath ) ) . num_workers as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherPath ) , "::" ,
                stringify ! ( num_workers ) ));
}
impl Clone for GatherPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GatherMergePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub num_workers: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GatherMergePath() {
    assert_eq!(::std::mem::size_of::<GatherMergePath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( GatherMergePath ) ));
    assert_eq! (::std::mem::align_of::<GatherMergePath>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( GatherMergePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergePath ) ) . path as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergePath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergePath ) ) . subpath as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergePath ) ,
                "::" , stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GatherMergePath ) ) . num_workers as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( GatherMergePath ) ,
                "::" , stringify ! ( num_workers ) ));
}
impl Clone for GatherMergePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType,
    pub inner_unique: bool_,
    pub outerjoinpath: *mut Path,
    pub innerjoinpath: *mut Path,
    pub joinrestrictinfo: *mut List,
}
#[test]
fn bindgen_test_layout_JoinPath() {
    assert_eq!(::std::mem::size_of::<JoinPath>() , 104usize , concat ! (
               "Size of: " , stringify ! ( JoinPath ) ));
    assert_eq! (::std::mem::align_of::<JoinPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( JoinPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPath ) ) . path as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPath ) ) . jointype as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPath ) , "::" ,
                stringify ! ( jointype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPath ) ) . inner_unique as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPath ) , "::" ,
                stringify ! ( inner_unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPath ) ) . outerjoinpath as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPath ) , "::" ,
                stringify ! ( outerjoinpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPath ) ) . innerjoinpath as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPath ) , "::" ,
                stringify ! ( innerjoinpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPath ) ) . joinrestrictinfo as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPath ) , "::" ,
                stringify ! ( joinrestrictinfo ) ));
}
impl Clone for JoinPath {
    fn clone(&self) -> Self { *self }
}
pub type NestPath = JoinPath;
#[repr(C)]
#[derive(Copy)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: *mut List,
    pub outersortkeys: *mut List,
    pub innersortkeys: *mut List,
    pub skip_mark_restore: bool_,
    pub materialize_inner: bool_,
}
#[test]
fn bindgen_test_layout_MergePath() {
    assert_eq!(::std::mem::size_of::<MergePath>() , 136usize , concat ! (
               "Size of: " , stringify ! ( MergePath ) ));
    assert_eq! (::std::mem::align_of::<MergePath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MergePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergePath ) ) . jpath as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergePath ) , "::" ,
                stringify ! ( jpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergePath ) ) . path_mergeclauses as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( MergePath ) , "::" ,
                stringify ! ( path_mergeclauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergePath ) ) . outersortkeys as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( MergePath ) , "::" ,
                stringify ! ( outersortkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergePath ) ) . innersortkeys as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MergePath ) , "::" ,
                stringify ! ( innersortkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergePath ) ) . skip_mark_restore as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MergePath ) , "::" ,
                stringify ! ( skip_mark_restore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergePath ) ) . materialize_inner as *
                const _ as usize } , 129usize , concat ! (
                "Alignment of field: " , stringify ! ( MergePath ) , "::" ,
                stringify ! ( materialize_inner ) ));
}
impl Clone for MergePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: *mut List,
    pub num_batches: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HashPath() {
    assert_eq!(::std::mem::size_of::<HashPath>() , 120usize , concat ! (
               "Size of: " , stringify ! ( HashPath ) ));
    assert_eq! (::std::mem::align_of::<HashPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HashPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashPath ) ) . jpath as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HashPath ) , "::" ,
                stringify ! ( jpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashPath ) ) . path_hashclauses as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( HashPath ) , "::" ,
                stringify ! ( path_hashclauses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HashPath ) ) . num_batches as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( HashPath ) , "::" ,
                stringify ! ( num_batches ) ));
}
impl Clone for HashPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ProjectionPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub dummypp: bool_,
}
#[test]
fn bindgen_test_layout_ProjectionPath() {
    assert_eq!(::std::mem::size_of::<ProjectionPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ProjectionPath ) ));
    assert_eq! (::std::mem::align_of::<ProjectionPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ProjectionPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectionPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectionPath ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectionPath ) ) . subpath as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectionPath ) , "::"
                , stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectionPath ) ) . dummypp as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectionPath ) , "::"
                , stringify ! ( dummypp ) ));
}
impl Clone for ProjectionPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ProjectSetPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_ProjectSetPath() {
    assert_eq!(::std::mem::size_of::<ProjectSetPath>() , 80usize , concat ! (
               "Size of: " , stringify ! ( ProjectSetPath ) ));
    assert_eq! (::std::mem::align_of::<ProjectSetPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ProjectSetPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetPath ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ProjectSetPath ) ) . subpath as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ProjectSetPath ) , "::"
                , stringify ! ( subpath ) ));
}
impl Clone for ProjectSetPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SortPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_SortPath() {
    assert_eq!(::std::mem::size_of::<SortPath>() , 80usize , concat ! (
               "Size of: " , stringify ! ( SortPath ) ));
    assert_eq! (::std::mem::align_of::<SortPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SortPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortPath ) ) . path as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SortPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SortPath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( SortPath ) , "::" ,
                stringify ! ( subpath ) ));
}
impl Clone for SortPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GroupPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
#[test]
fn bindgen_test_layout_GroupPath() {
    assert_eq!(::std::mem::size_of::<GroupPath>() , 96usize , concat ! (
               "Size of: " , stringify ! ( GroupPath ) ));
    assert_eq! (::std::mem::align_of::<GroupPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( GroupPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupPath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupPath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupPath ) ) . groupClause as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupPath ) , "::" ,
                stringify ! ( groupClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupPath ) ) . qual as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupPath ) , "::" ,
                stringify ! ( qual ) ));
}
impl Clone for GroupPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct UpperUniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub numkeys: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_UpperUniquePath() {
    assert_eq!(::std::mem::size_of::<UpperUniquePath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( UpperUniquePath ) ));
    assert_eq! (::std::mem::align_of::<UpperUniquePath>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( UpperUniquePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpperUniquePath ) ) . path as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UpperUniquePath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpperUniquePath ) ) . subpath as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( UpperUniquePath ) ,
                "::" , stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpperUniquePath ) ) . numkeys as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( UpperUniquePath ) ,
                "::" , stringify ! ( numkeys ) ));
}
impl Clone for UpperUniquePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numGroups: f64,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
#[test]
fn bindgen_test_layout_AggPath() {
    assert_eq!(::std::mem::size_of::<AggPath>() , 112usize , concat ! (
               "Size of: " , stringify ! ( AggPath ) ));
    assert_eq! (::std::mem::align_of::<AggPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AggPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . path as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . aggstrategy as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( aggstrategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . aggsplit as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( aggsplit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . numGroups as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( numGroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . groupClause as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( groupClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AggPath ) ) . qual as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AggPath ) , "::" ,
                stringify ! ( qual ) ));
}
impl Clone for AggPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GroupingSetData {
    pub type_: NodeTag,
    pub set: *mut List,
    pub numGroups: f64,
}
#[test]
fn bindgen_test_layout_GroupingSetData() {
    assert_eq!(::std::mem::size_of::<GroupingSetData>() , 24usize , concat ! (
               "Size of: " , stringify ! ( GroupingSetData ) ));
    assert_eq! (::std::mem::align_of::<GroupingSetData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( GroupingSetData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetData ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetData ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetData ) ) . set as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetData ) ,
                "::" , stringify ! ( set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetData ) ) . numGroups as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetData ) ,
                "::" , stringify ! ( numGroups ) ));
}
impl Clone for GroupingSetData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RollupData {
    pub type_: NodeTag,
    pub groupClause: *mut List,
    pub gsets: *mut List,
    pub gsets_data: *mut List,
    pub numGroups: f64,
    pub hashable: bool_,
    pub is_hashed: bool_,
}
#[test]
fn bindgen_test_layout_RollupData() {
    assert_eq!(::std::mem::size_of::<RollupData>() , 48usize , concat ! (
               "Size of: " , stringify ! ( RollupData ) ));
    assert_eq! (::std::mem::align_of::<RollupData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RollupData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . groupClause as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( groupClause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . gsets as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( gsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . gsets_data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( gsets_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . numGroups as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( numGroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . hashable as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( hashable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RollupData ) ) . is_hashed as * const _
                as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( RollupData ) , "::" ,
                stringify ! ( is_hashed ) ));
}
impl Clone for RollupData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GroupingSetsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub rollups: *mut List,
    pub qual: *mut List,
}
#[test]
fn bindgen_test_layout_GroupingSetsPath() {
    assert_eq!(::std::mem::size_of::<GroupingSetsPath>() , 104usize , concat !
               ( "Size of: " , stringify ! ( GroupingSetsPath ) ));
    assert_eq! (::std::mem::align_of::<GroupingSetsPath>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( GroupingSetsPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetsPath ) ) . path as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetsPath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetsPath ) ) . subpath as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetsPath ) ,
                "::" , stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetsPath ) ) . aggstrategy as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetsPath ) ,
                "::" , stringify ! ( aggstrategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetsPath ) ) . rollups as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetsPath ) ,
                "::" , stringify ! ( rollups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const GroupingSetsPath ) ) . qual as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( GroupingSetsPath ) ,
                "::" , stringify ! ( qual ) ));
}
impl Clone for GroupingSetsPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MinMaxAggPath {
    pub path: Path,
    pub mmaggregates: *mut List,
    pub quals: *mut List,
}
#[test]
fn bindgen_test_layout_MinMaxAggPath() {
    assert_eq!(::std::mem::size_of::<MinMaxAggPath>() , 88usize , concat ! (
               "Size of: " , stringify ! ( MinMaxAggPath ) ));
    assert_eq! (::std::mem::align_of::<MinMaxAggPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MinMaxAggPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggPath ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggPath ) ) . mmaggregates as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggPath ) , "::"
                , stringify ! ( mmaggregates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggPath ) ) . quals as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggPath ) , "::"
                , stringify ! ( quals ) ));
}
impl Clone for MinMaxAggPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowAggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub winclause: *mut WindowClause,
    pub winpathkeys: *mut List,
}
#[test]
fn bindgen_test_layout_WindowAggPath() {
    assert_eq!(::std::mem::size_of::<WindowAggPath>() , 96usize , concat ! (
               "Size of: " , stringify ! ( WindowAggPath ) ));
    assert_eq! (::std::mem::align_of::<WindowAggPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WindowAggPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggPath ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggPath ) ) . subpath as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggPath ) , "::"
                , stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggPath ) ) . winclause as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggPath ) , "::"
                , stringify ! ( winclause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WindowAggPath ) ) . winpathkeys as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( WindowAggPath ) , "::"
                , stringify ! ( winpathkeys ) ));
}
impl Clone for WindowAggPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SetOpPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub distinctList: *mut List,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: f64,
}
#[test]
fn bindgen_test_layout_SetOpPath() {
    assert_eq!(::std::mem::size_of::<SetOpPath>() , 112usize , concat ! (
               "Size of: " , stringify ! ( SetOpPath ) ));
    assert_eq! (::std::mem::align_of::<SetOpPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SetOpPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . cmd as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . strategy as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . distinctList as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( distinctList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . flagColIdx as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( flagColIdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . firstFlag as * const _ as
                usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( firstFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SetOpPath ) ) . numGroups as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( SetOpPath ) , "::" ,
                stringify ! ( numGroups ) ));
}
impl Clone for SetOpPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RecursiveUnionPath {
    pub path: Path,
    pub leftpath: *mut Path,
    pub rightpath: *mut Path,
    pub distinctList: *mut List,
    pub wtParam: ::std::os::raw::c_int,
    pub numGroups: f64,
}
#[test]
fn bindgen_test_layout_RecursiveUnionPath() {
    assert_eq!(::std::mem::size_of::<RecursiveUnionPath>() , 112usize , concat
               ! ( "Size of: " , stringify ! ( RecursiveUnionPath ) ));
    assert_eq! (::std::mem::align_of::<RecursiveUnionPath>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( RecursiveUnionPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionPath ) ) . path as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionPath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionPath ) ) . leftpath as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionPath ) ,
                "::" , stringify ! ( leftpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionPath ) ) . rightpath as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionPath ) ,
                "::" , stringify ! ( rightpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionPath ) ) . distinctList as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionPath ) ,
                "::" , stringify ! ( distinctList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionPath ) ) . wtParam as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionPath ) ,
                "::" , stringify ! ( wtParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RecursiveUnionPath ) ) . numGroups as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( RecursiveUnionPath ) ,
                "::" , stringify ! ( numGroups ) ));
}
impl Clone for RecursiveUnionPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockRowsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRowsPath() {
    assert_eq!(::std::mem::size_of::<LockRowsPath>() , 96usize , concat ! (
               "Size of: " , stringify ! ( LockRowsPath ) ));
    assert_eq! (::std::mem::align_of::<LockRowsPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LockRowsPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsPath ) ) . subpath as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsPath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsPath ) ) . rowMarks as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsPath ) , "::" ,
                stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRowsPath ) ) . epqParam as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRowsPath ) , "::" ,
                stringify ! ( epqParam ) ));
}
impl Clone for LockRowsPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ModifyTablePath {
    pub path: Path,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub nominalRelation: Index,
    pub partitioned_rels: *mut List,
    pub resultRelations: *mut List,
    pub subpaths: *mut List,
    pub subroots: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub rowMarks: *mut List,
    pub onconflict: *mut OnConflictExpr,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ModifyTablePath() {
    assert_eq!(::std::mem::size_of::<ModifyTablePath>() , 160usize , concat !
               ( "Size of: " , stringify ! ( ModifyTablePath ) ));
    assert_eq! (::std::mem::align_of::<ModifyTablePath>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ModifyTablePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . path as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . operation as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . canSetTag as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( canSetTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . nominalRelation as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( nominalRelation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . partitioned_rels as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( partitioned_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . resultRelations as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( resultRelations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . subpaths as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( subpaths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . subroots as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( subroots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) .
                withCheckOptionLists as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( withCheckOptionLists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . returningLists as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( returningLists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . rowMarks as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( rowMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . onconflict as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( onconflict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModifyTablePath ) ) . epqParam as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ModifyTablePath ) ,
                "::" , stringify ! ( epqParam ) ));
}
impl Clone for ModifyTablePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LimitPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
}
#[test]
fn bindgen_test_layout_LimitPath() {
    assert_eq!(::std::mem::size_of::<LimitPath>() , 96usize , concat ! (
               "Size of: " , stringify ! ( LimitPath ) ));
    assert_eq! (::std::mem::align_of::<LimitPath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( LimitPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitPath ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitPath ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitPath ) ) . subpath as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitPath ) , "::" ,
                stringify ! ( subpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitPath ) ) . limitOffset as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitPath ) , "::" ,
                stringify ! ( limitOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LimitPath ) ) . limitCount as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( LimitPath ) , "::" ,
                stringify ! ( limitCount ) ));
}
impl Clone for LimitPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: *mut Expr,
    pub is_pushed_down: bool_,
    pub outerjoin_delayed: bool_,
    pub can_join: bool_,
    pub pseudoconstant: bool_,
    pub leakproof: bool_,
    pub security_level: Index,
    pub clause_relids: Relids,
    pub required_relids: Relids,
    pub outer_relids: Relids,
    pub nullable_relids: Relids,
    pub left_relids: Relids,
    pub right_relids: Relids,
    pub orclause: *mut Expr,
    pub parent_ec: *mut EquivalenceClass,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: *mut List,
    pub left_ec: *mut EquivalenceClass,
    pub right_ec: *mut EquivalenceClass,
    pub left_em: *mut EquivalenceMember,
    pub right_em: *mut EquivalenceMember,
    pub scansel_cache: *mut List,
    pub outer_is_left: bool_,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
}
#[test]
fn bindgen_test_layout_RestrictInfo() {
    assert_eq!(::std::mem::size_of::<RestrictInfo>() , 200usize , concat ! (
               "Size of: " , stringify ! ( RestrictInfo ) ));
    assert_eq! (::std::mem::align_of::<RestrictInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RestrictInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . clause as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( clause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . is_pushed_down as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( is_pushed_down ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . outerjoin_delayed as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( outerjoin_delayed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . can_join as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( can_join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . pseudoconstant as *
                const _ as usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( pseudoconstant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . leakproof as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( leakproof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . security_level as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( security_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . clause_relids as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( clause_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . required_relids as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( required_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . outer_relids as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( outer_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . nullable_relids as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( nullable_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . left_relids as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( left_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . right_relids as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( right_relids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . orclause as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( orclause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . parent_ec as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( parent_ec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . eval_cost as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( eval_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . norm_selec as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( norm_selec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . outer_selec as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( outer_selec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . mergeopfamilies as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( mergeopfamilies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . left_ec as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( left_ec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . right_ec as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( right_ec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . left_em as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( left_em ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . right_em as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( right_em ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . scansel_cache as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( scansel_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . outer_is_left as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( outer_is_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . hashjoinoperator as *
                const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( hashjoinoperator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . left_bucketsize as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( left_bucketsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RestrictInfo ) ) . right_bucketsize as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RestrictInfo ) , "::" ,
                stringify ! ( right_bucketsize ) ));
}
impl Clone for RestrictInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub nulls_first: bool_,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
#[test]
fn bindgen_test_layout_MergeScanSelCache() {
    assert_eq!(::std::mem::size_of::<MergeScanSelCache>() , 48usize , concat !
               ( "Size of: " , stringify ! ( MergeScanSelCache ) ));
    assert_eq! (::std::mem::align_of::<MergeScanSelCache>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( MergeScanSelCache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . opfamily as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( opfamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . collation as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( collation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . strategy as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . nulls_first as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( nulls_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . leftstartsel as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( leftstartsel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . leftendsel as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( leftendsel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . rightstartsel as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( rightstartsel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MergeScanSelCache ) ) . rightendsel as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( MergeScanSelCache ) ,
                "::" , stringify ! ( rightendsel ) ));
}
impl Clone for MergeScanSelCache {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: *mut Expr,
    pub phrels: Relids,
    pub phid: Index,
    pub phlevelsup: Index,
}
#[test]
fn bindgen_test_layout_PlaceHolderVar() {
    assert_eq!(::std::mem::size_of::<PlaceHolderVar>() , 32usize , concat ! (
               "Size of: " , stringify ! ( PlaceHolderVar ) ));
    assert_eq! (::std::mem::align_of::<PlaceHolderVar>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PlaceHolderVar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderVar ) ) . xpr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderVar ) , "::"
                , stringify ! ( xpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderVar ) ) . phexpr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderVar ) , "::"
                , stringify ! ( phexpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderVar ) ) . phrels as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderVar ) , "::"
                , stringify ! ( phrels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderVar ) ) . phid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderVar ) , "::"
                , stringify ! ( phid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderVar ) ) . phlevelsup as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderVar ) , "::"
                , stringify ! ( phlevelsup ) ));
}
impl Clone for PlaceHolderVar {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: Relids,
    pub min_righthand: Relids,
    pub syn_lefthand: Relids,
    pub syn_righthand: Relids,
    pub jointype: JoinType,
    pub lhs_strict: bool_,
    pub delay_upper_joins: bool_,
    pub semi_can_btree: bool_,
    pub semi_can_hash: bool_,
    pub semi_operators: *mut List,
    pub semi_rhs_exprs: *mut List,
}
#[test]
fn bindgen_test_layout_SpecialJoinInfo() {
    assert_eq!(::std::mem::size_of::<SpecialJoinInfo>() , 64usize , concat ! (
               "Size of: " , stringify ! ( SpecialJoinInfo ) ));
    assert_eq! (::std::mem::align_of::<SpecialJoinInfo>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SpecialJoinInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . min_lefthand as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( min_lefthand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . min_righthand as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( min_righthand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . syn_lefthand as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( syn_lefthand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . syn_righthand as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( syn_righthand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . jointype as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( jointype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . lhs_strict as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( lhs_strict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . delay_upper_joins
                as * const _ as usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( delay_upper_joins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . semi_can_btree as *
                const _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( semi_can_btree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . semi_can_hash as *
                const _ as usize } , 47usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( semi_can_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . semi_operators as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( semi_operators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpecialJoinInfo ) ) . semi_rhs_exprs as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SpecialJoinInfo ) ,
                "::" , stringify ! ( semi_rhs_exprs ) ));
}
impl Clone for SpecialJoinInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: *mut List,
    pub parent_reloid: Oid,
}
#[test]
fn bindgen_test_layout_AppendRelInfo() {
    assert_eq!(::std::mem::size_of::<AppendRelInfo>() , 40usize , concat ! (
               "Size of: " , stringify ! ( AppendRelInfo ) ));
    assert_eq! (::std::mem::align_of::<AppendRelInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AppendRelInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . parent_relid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( parent_relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . child_relid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( child_relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . parent_reltype as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( parent_reltype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . child_reltype as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( child_reltype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . translated_vars as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( translated_vars ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppendRelInfo ) ) . parent_reloid as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AppendRelInfo ) , "::"
                , stringify ! ( parent_reloid ) ));
}
impl Clone for AppendRelInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionedChildRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_rels: *mut List,
}
#[test]
fn bindgen_test_layout_PartitionedChildRelInfo() {
    assert_eq!(::std::mem::size_of::<PartitionedChildRelInfo>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( PartitionedChildRelInfo ) ));
    assert_eq! (::std::mem::align_of::<PartitionedChildRelInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( PartitionedChildRelInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionedChildRelInfo ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionedChildRelInfo
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionedChildRelInfo ) ) .
                parent_relid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionedChildRelInfo
                ) , "::" , stringify ! ( parent_relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionedChildRelInfo ) ) . child_rels
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionedChildRelInfo
                ) , "::" , stringify ! ( child_rels ) ));
}
impl Clone for PartitionedChildRelInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: *mut PlaceHolderVar,
    pub ph_eval_at: Relids,
    pub ph_lateral: Relids,
    pub ph_needed: Relids,
    pub ph_width: int32,
}
#[test]
fn bindgen_test_layout_PlaceHolderInfo() {
    assert_eq!(::std::mem::size_of::<PlaceHolderInfo>() , 48usize , concat ! (
               "Size of: " , stringify ! ( PlaceHolderInfo ) ));
    assert_eq! (::std::mem::align_of::<PlaceHolderInfo>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( PlaceHolderInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . phid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( phid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . ph_var as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( ph_var ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . ph_eval_at as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( ph_eval_at ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . ph_lateral as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( ph_lateral ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . ph_needed as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( ph_needed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlaceHolderInfo ) ) . ph_width as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PlaceHolderInfo ) ,
                "::" , stringify ! ( ph_width ) ));
}
impl Clone for PlaceHolderInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: *mut Expr,
    pub subroot: *mut PlannerInfo,
    pub path: *mut Path,
    pub pathcost: Cost,
    pub param: *mut Param,
}
#[test]
fn bindgen_test_layout_MinMaxAggInfo() {
    assert_eq!(::std::mem::size_of::<MinMaxAggInfo>() , 56usize , concat ! (
               "Size of: " , stringify ! ( MinMaxAggInfo ) ));
    assert_eq! (::std::mem::align_of::<MinMaxAggInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MinMaxAggInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . aggfnoid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( aggfnoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . aggsortop as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( aggsortop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . target as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . subroot as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( subroot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . path as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . pathcost as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( pathcost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MinMaxAggInfo ) ) . param as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( MinMaxAggInfo ) , "::"
                , stringify ! ( param ) ));
}
impl Clone for MinMaxAggInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: *mut Node,
    pub paramId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PlannerParamItem() {
    assert_eq!(::std::mem::size_of::<PlannerParamItem>() , 24usize , concat !
               ( "Size of: " , stringify ! ( PlannerParamItem ) ));
    assert_eq! (::std::mem::align_of::<PlannerParamItem>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( PlannerParamItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerParamItem ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerParamItem ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerParamItem ) ) . item as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerParamItem ) ,
                "::" , stringify ! ( item ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PlannerParamItem ) ) . paramId as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PlannerParamItem ) ,
                "::" , stringify ! ( paramId ) ));
}
impl Clone for PlannerParamItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
#[test]
fn bindgen_test_layout_SemiAntiJoinFactors() {
    assert_eq!(::std::mem::size_of::<SemiAntiJoinFactors>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( SemiAntiJoinFactors ) ));
    assert_eq! (::std::mem::align_of::<SemiAntiJoinFactors>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SemiAntiJoinFactors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SemiAntiJoinFactors ) ) .
                outer_match_frac as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SemiAntiJoinFactors ) ,
                "::" , stringify ! ( outer_match_frac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SemiAntiJoinFactors ) ) . match_count as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SemiAntiJoinFactors ) ,
                "::" , stringify ! ( match_count ) ));
}
impl Clone for SemiAntiJoinFactors {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct JoinPathExtraData {
    pub restrictlist: *mut List,
    pub mergeclause_list: *mut List,
    pub inner_unique: bool_,
    pub sjinfo: *mut SpecialJoinInfo,
    pub semifactors: SemiAntiJoinFactors,
    pub param_source_rels: Relids,
}
#[test]
fn bindgen_test_layout_JoinPathExtraData() {
    assert_eq!(::std::mem::size_of::<JoinPathExtraData>() , 56usize , concat !
               ( "Size of: " , stringify ! ( JoinPathExtraData ) ));
    assert_eq! (::std::mem::align_of::<JoinPathExtraData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( JoinPathExtraData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPathExtraData ) ) . restrictlist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPathExtraData ) ,
                "::" , stringify ! ( restrictlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPathExtraData ) ) . mergeclause_list
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPathExtraData ) ,
                "::" , stringify ! ( mergeclause_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPathExtraData ) ) . inner_unique as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPathExtraData ) ,
                "::" , stringify ! ( inner_unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPathExtraData ) ) . sjinfo as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPathExtraData ) ,
                "::" , stringify ! ( sjinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPathExtraData ) ) . semifactors as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPathExtraData ) ,
                "::" , stringify ! ( semifactors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinPathExtraData ) ) . param_source_rels
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinPathExtraData ) ,
                "::" , stringify ! ( param_source_rels ) ));
}
impl Clone for JoinPathExtraData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: f64,
    pub inner_rows: f64,
    pub outer_skip_rows: f64,
    pub inner_skip_rows: f64,
    pub numbuckets: ::std::os::raw::c_int,
    pub numbatches: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JoinCostWorkspace() {
    assert_eq!(::std::mem::size_of::<JoinCostWorkspace>() , 80usize , concat !
               ( "Size of: " , stringify ! ( JoinCostWorkspace ) ));
    assert_eq! (::std::mem::align_of::<JoinCostWorkspace>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( JoinCostWorkspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . startup_cost as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( startup_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . total_cost as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( total_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . run_cost as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( run_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . inner_run_cost as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( inner_run_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) .
                inner_rescan_run_cost as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( inner_rescan_run_cost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . outer_rows as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( outer_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . inner_rows as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( inner_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . outer_skip_rows
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( outer_skip_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . inner_skip_rows
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( inner_skip_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . numbuckets as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( numbuckets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JoinCostWorkspace ) ) . numbatches as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( JoinCostWorkspace ) ,
                "::" , stringify ! ( numbatches ) ));
}
impl Clone for JoinCostWorkspace {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainState {
    _unused: [u8; 0],
}
pub type GetForeignRelSize_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid)>;
pub type GetForeignPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid)>;
pub type GetForeignPlan_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid,
                                               best_path: *mut ForeignPath,
                                               tlist: *mut List,
                                               scan_clauses: *mut List,
                                               outer_plan: *mut Plan)
                              -> *mut ForeignScan>;
pub type BeginForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type IterateForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)
                              -> *mut TupleTableSlot>;
pub type RecheckForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               slot: *mut TupleTableSlot)
                              -> bool_>;
pub type ReScanForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type EndForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignJoinPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               joinrel: *mut RelOptInfo,
                                               outerrel: *mut RelOptInfo,
                                               innerrel: *mut RelOptInfo,
                                               jointype: JoinType,
                                               extra:
                                                   *mut JoinPathExtraData)>;
pub type GetForeignUpperPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               stage: UpperRelationKind,
                                               input_rel: *mut RelOptInfo,
                                               output_rel: *mut RelOptInfo)>;
pub type AddForeignUpdateTargets_function =
    ::std::option::Option<unsafe extern "C" fn(parsetree: *mut Query,
                                               target_rte: *mut RangeTblEntry,
                                               target_relation: Relation)>;
pub type PlanForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               plan: *mut ModifyTable,
                                               resultRelation: Index,
                                               subplan_index:
                                                   ::std::os::raw::c_int)
                              -> *mut List>;
pub type BeginForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(mtstate: *mut ModifyTableState,
                                               rinfo: *mut ResultRelInfo,
                                               fdw_private: *mut List,
                                               subplan_index:
                                                   ::std::os::raw::c_int,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type ExecForeignInsert_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type ExecForeignUpdate_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type ExecForeignDelete_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type EndForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo)>;
pub type IsForeignRelUpdatable_function =
    ::std::option::Option<unsafe extern "C" fn(rel: Relation)
                              -> ::std::os::raw::c_int>;
pub type PlanDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               plan: *mut ModifyTable,
                                               resultRelation: Index,
                                               subplan_index:
                                                   ::std::os::raw::c_int)
                              -> bool_>;
pub type BeginDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type IterateDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)
                              -> *mut TupleTableSlot>;
pub type EndDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignRowMarkType_function =
    ::std::option::Option<unsafe extern "C" fn(rte: *mut RangeTblEntry,
                                               strength: LockClauseStrength)
                              -> RowMarkType>;
pub type RefetchForeignRow_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               erm: *mut ExecRowMark,
                                               rowid: Datum,
                                               updated: *mut bool_)
                              -> HeapTuple>;
pub type ExplainForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               es: *mut ExplainState)>;
pub type ExplainForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(mtstate: *mut ModifyTableState,
                                               rinfo: *mut ResultRelInfo,
                                               fdw_private: *mut List,
                                               subplan_index:
                                                   ::std::os::raw::c_int,
                                               es: *mut ExplainState)>;
pub type ExplainDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               es: *mut ExplainState)>;
pub type AcquireSampleRowsFunc =
    ::std::option::Option<unsafe extern "C" fn(relation: Relation,
                                               elevel: ::std::os::raw::c_int,
                                               rows: *mut HeapTuple,
                                               targrows:
                                                   ::std::os::raw::c_int,
                                               totalrows: *mut f64,
                                               totaldeadrows: *mut f64)
                              -> ::std::os::raw::c_int>;
pub type AnalyzeForeignTable_function =
    ::std::option::Option<unsafe extern "C" fn(relation: Relation,
                                               func:
                                                   *mut AcquireSampleRowsFunc,
                                               totalpages: *mut BlockNumber)
                              -> bool_>;
pub type ImportForeignSchema_function =
    ::std::option::Option<unsafe extern "C" fn(stmt:
                                                   *mut ImportForeignSchemaStmt,
                                               serverOid: Oid) -> *mut List>;
pub type EstimateDSMForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               pcxt: *mut ParallelContext)
                              -> Size>;
pub type InitializeDSMForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               pcxt: *mut ParallelContext,
                                               coordinate:
                                                   *mut ::std::os::raw::c_void)>;
pub type ReInitializeDSMForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               pcxt: *mut ParallelContext,
                                               coordinate:
                                                   *mut ::std::os::raw::c_void)>;
pub type InitializeWorkerForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               toc: *mut shm_toc,
                                               coordinate:
                                                   *mut ::std::os::raw::c_void)>;
pub type ShutdownForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type IsForeignScanParallelSafe_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               rel: *mut RelOptInfo,
                                               rte: *mut RangeTblEntry)
                              -> bool_>;
#[repr(C)]
#[derive(Copy)]
pub struct FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub GetForeignJoinPaths: GetForeignJoinPaths_function,
    pub GetForeignUpperPaths: GetForeignUpperPaths_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub PlanDirectModify: PlanDirectModify_function,
    pub BeginDirectModify: BeginDirectModify_function,
    pub IterateDirectModify: IterateDirectModify_function,
    pub EndDirectModify: EndDirectModify_function,
    pub GetForeignRowMarkType: GetForeignRowMarkType_function,
    pub RefetchForeignRow: RefetchForeignRow_function,
    pub RecheckForeignScan: RecheckForeignScan_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub ExplainDirectModify: ExplainDirectModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
    pub ImportForeignSchema: ImportForeignSchema_function,
    pub IsForeignScanParallelSafe: IsForeignScanParallelSafe_function,
    pub EstimateDSMForeignScan: EstimateDSMForeignScan_function,
    pub InitializeDSMForeignScan: InitializeDSMForeignScan_function,
    pub ReInitializeDSMForeignScan: ReInitializeDSMForeignScan_function,
    pub InitializeWorkerForeignScan: InitializeWorkerForeignScan_function,
    pub ShutdownForeignScan: ShutdownForeignScan_function,
}
#[test]
fn bindgen_test_layout_FdwRoutine() {
    assert_eq!(::std::mem::size_of::<FdwRoutine>() , 288usize , concat ! (
               "Size of: " , stringify ! ( FdwRoutine ) ));
    assert_eq! (::std::mem::align_of::<FdwRoutine>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FdwRoutine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . GetForeignRelSize as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( GetForeignRelSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . GetForeignPaths as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( GetForeignPaths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . GetForeignPlan as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( GetForeignPlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . BeginForeignScan as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( BeginForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . IterateForeignScan as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( IterateForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ReScanForeignScan as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ReScanForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . EndForeignScan as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( EndForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . GetForeignJoinPaths as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( GetForeignJoinPaths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . GetForeignUpperPaths as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( GetForeignUpperPaths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . AddForeignUpdateTargets
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( AddForeignUpdateTargets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . PlanForeignModify as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( PlanForeignModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . BeginForeignModify as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( BeginForeignModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ExecForeignInsert as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ExecForeignInsert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ExecForeignUpdate as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ExecForeignUpdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ExecForeignDelete as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ExecForeignDelete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . EndForeignModify as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( EndForeignModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . IsForeignRelUpdatable as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( IsForeignRelUpdatable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . PlanDirectModify as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( PlanDirectModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . BeginDirectModify as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( BeginDirectModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . IterateDirectModify as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( IterateDirectModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . EndDirectModify as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( EndDirectModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . GetForeignRowMarkType as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( GetForeignRowMarkType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . RefetchForeignRow as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( RefetchForeignRow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . RecheckForeignScan as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( RecheckForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ExplainForeignScan as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ExplainForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ExplainForeignModify as
                * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ExplainForeignModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ExplainDirectModify as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ExplainDirectModify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . AnalyzeForeignTable as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( AnalyzeForeignTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ImportForeignSchema as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ImportForeignSchema ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) .
                IsForeignScanParallelSafe as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( IsForeignScanParallelSafe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . EstimateDSMForeignScan
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( EstimateDSMForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . InitializeDSMForeignScan
                as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( InitializeDSMForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) .
                ReInitializeDSMForeignScan as * const _ as usize } , 264usize
                , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ReInitializeDSMForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) .
                InitializeWorkerForeignScan as * const _ as usize } , 272usize
                , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( InitializeWorkerForeignScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FdwRoutine ) ) . ShutdownForeignScan as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( FdwRoutine ) , "::" ,
                stringify ! ( ShutdownForeignScan ) ));
}
impl Clone for FdwRoutine {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetFdwRoutine(fdwhandler: Oid) -> *mut FdwRoutine;
}
extern "C" {
    pub fn GetForeignServerIdByRelId(relid: Oid) -> Oid;
}
extern "C" {
    pub fn GetFdwRoutineByServerId(serverid: Oid) -> *mut FdwRoutine;
}
extern "C" {
    pub fn GetFdwRoutineByRelId(relid: Oid) -> *mut FdwRoutine;
}
extern "C" {
    pub fn GetFdwRoutineForRelation(relation: Relation, makecopy: bool_)
     -> *mut FdwRoutine;
}
extern "C" {
    pub fn IsImportableForeignTable(tablename: *const ::std::os::raw::c_char,
                                    stmt: *mut ImportForeignSchemaStmt)
     -> bool_;
}
extern "C" {
    pub fn GetExistingLocalJoinPath(joinrel: *mut RelOptInfo) -> *mut Path;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GenericOptionFlags { ServerOpt = 1, UserMappingOpt = 2, FdwOpt = 4, }
#[repr(C)]
#[derive(Copy)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignDataWrapper() {
    assert_eq!(::std::mem::size_of::<ForeignDataWrapper>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( ForeignDataWrapper ) ));
    assert_eq! (::std::mem::align_of::<ForeignDataWrapper>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ForeignDataWrapper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignDataWrapper ) ) . fdwid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignDataWrapper ) ,
                "::" , stringify ! ( fdwid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignDataWrapper ) ) . owner as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignDataWrapper ) ,
                "::" , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignDataWrapper ) ) . fdwname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignDataWrapper ) ,
                "::" , stringify ! ( fdwname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignDataWrapper ) ) . fdwhandler as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignDataWrapper ) ,
                "::" , stringify ! ( fdwhandler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignDataWrapper ) ) . fdwvalidator as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignDataWrapper ) ,
                "::" , stringify ! ( fdwvalidator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignDataWrapper ) ) . options as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignDataWrapper ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for ForeignDataWrapper {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub serverversion: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignServer() {
    assert_eq!(::std::mem::size_of::<ForeignServer>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ForeignServer ) ));
    assert_eq! (::std::mem::align_of::<ForeignServer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ForeignServer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . serverid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( serverid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . fdwid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( fdwid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . owner as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . servername as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( servername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . servertype as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( servertype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . serverversion as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( serverversion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignServer ) ) . options as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignServer ) , "::"
                , stringify ! ( options ) ));
}
impl Clone for ForeignServer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct UserMapping {
    pub umid: Oid,
    pub userid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_UserMapping() {
    assert_eq!(::std::mem::size_of::<UserMapping>() , 24usize , concat ! (
               "Size of: " , stringify ! ( UserMapping ) ));
    assert_eq! (::std::mem::align_of::<UserMapping>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( UserMapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UserMapping ) ) . umid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UserMapping ) , "::" ,
                stringify ! ( umid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UserMapping ) ) . userid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( UserMapping ) , "::" ,
                stringify ! ( userid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UserMapping ) ) . serverid as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( UserMapping ) , "::" ,
                stringify ! ( serverid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UserMapping ) ) . options as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( UserMapping ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for UserMapping {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignTable() {
    assert_eq!(::std::mem::size_of::<ForeignTable>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ForeignTable ) ));
    assert_eq! (::std::mem::align_of::<ForeignTable>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ForeignTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignTable ) ) . relid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignTable ) , "::" ,
                stringify ! ( relid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignTable ) ) . serverid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignTable ) , "::" ,
                stringify ! ( serverid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignTable ) ) . options as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignTable ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for ForeignTable {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetForeignServer(serverid: Oid) -> *mut ForeignServer;
}
extern "C" {
    pub fn GetForeignServerByName(name: *const ::std::os::raw::c_char,
                                  missing_ok: bool_) -> *mut ForeignServer;
}
extern "C" {
    pub fn GetUserMapping(userid: Oid, serverid: Oid) -> *mut UserMapping;
}
extern "C" {
    pub fn GetForeignDataWrapper(fdwid: Oid) -> *mut ForeignDataWrapper;
}
extern "C" {
    pub fn GetForeignDataWrapperByName(name: *const ::std::os::raw::c_char,
                                       missing_ok: bool_)
     -> *mut ForeignDataWrapper;
}
extern "C" {
    pub fn GetForeignTable(relid: Oid) -> *mut ForeignTable;
}
extern "C" {
    pub fn GetForeignColumnOptions(relid: Oid, attnum: AttrNumber)
     -> *mut List;
}
extern "C" {
    pub fn get_foreign_data_wrapper_oid(fdwname:
                                            *const ::std::os::raw::c_char,
                                        missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn get_foreign_server_oid(servername: *const ::std::os::raw::c_char,
                                  missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn compare_path_costs(path1: *mut Path, path2: *mut Path,
                              criterion: CostSelector)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn compare_fractional_path_costs(path1: *mut Path, path2: *mut Path,
                                         fraction: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_cheapest(parent_rel: *mut RelOptInfo);
}
extern "C" {
    pub fn add_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
}
extern "C" {
    pub fn add_path_precheck(parent_rel: *mut RelOptInfo, startup_cost: Cost,
                             total_cost: Cost, pathkeys: *mut List,
                             required_outer: Relids) -> bool_;
}
extern "C" {
    pub fn add_partial_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
}
extern "C" {
    pub fn add_partial_path_precheck(parent_rel: *mut RelOptInfo,
                                     total_cost: Cost, pathkeys: *mut List)
     -> bool_;
}
extern "C" {
    pub fn create_seqscan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               required_outer: Relids,
                               parallel_workers: ::std::os::raw::c_int)
     -> *mut Path;
}
extern "C" {
    pub fn create_samplescan_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_index_path(root: *mut PlannerInfo, index: *mut IndexOptInfo,
                             indexclauses: *mut List,
                             indexclausecols: *mut List,
                             indexorderbys: *mut List,
                             indexorderbycols: *mut List, pathkeys: *mut List,
                             indexscandir: ScanDirection, indexonly: bool_,
                             required_outer: Relids, loop_count: f64,
                             partial_path: bool_) -> *mut IndexPath;
}
extern "C" {
    pub fn create_bitmap_heap_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo,
                                   bitmapqual: *mut Path,
                                   required_outer: Relids, loop_count: f64,
                                   parallel_degree: ::std::os::raw::c_int)
     -> *mut BitmapHeapPath;
}
extern "C" {
    pub fn create_bitmap_and_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  bitmapquals: *mut List)
     -> *mut BitmapAndPath;
}
extern "C" {
    pub fn create_bitmap_or_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 bitmapquals: *mut List) -> *mut BitmapOrPath;
}
extern "C" {
    pub fn create_tidscan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               tidquals: *mut List, required_outer: Relids)
     -> *mut TidPath;
}
extern "C" {
    pub fn create_append_path(rel: *mut RelOptInfo, subpaths: *mut List,
                              required_outer: Relids,
                              parallel_workers: ::std::os::raw::c_int,
                              partitioned_rels: *mut List) -> *mut AppendPath;
}
extern "C" {
    pub fn create_merge_append_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpaths: *mut List,
                                    pathkeys: *mut List,
                                    required_outer: Relids,
                                    partitioned_rels: *mut List)
     -> *mut MergeAppendPath;
}
extern "C" {
    pub fn create_result_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              target: *mut PathTarget,
                              resconstantqual: *mut List) -> *mut ResultPath;
}
extern "C" {
    pub fn create_material_path(rel: *mut RelOptInfo, subpath: *mut Path)
     -> *mut MaterialPath;
}
extern "C" {
    pub fn create_unique_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              subpath: *mut Path,
                              sjinfo: *mut SpecialJoinInfo)
     -> *mut UniquePath;
}
extern "C" {
    pub fn create_gather_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              subpath: *mut Path, target: *mut PathTarget,
                              required_outer: Relids, rows: *mut f64)
     -> *mut GatherPath;
}
extern "C" {
    pub fn create_gather_merge_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    target: *mut PathTarget,
                                    pathkeys: *mut List,
                                    required_outer: Relids, rows: *mut f64)
     -> *mut GatherMergePath;
}
extern "C" {
    pub fn create_subqueryscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    pathkeys: *mut List,
                                    required_outer: Relids)
     -> *mut SubqueryScanPath;
}
extern "C" {
    pub fn create_functionscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, pathkeys: *mut List,
                                    required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_tablexprscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, pathkeys: *mut List,
                                    required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_valuesscan_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_tablefuncscan_path(root: *mut PlannerInfo,
                                     rel: *mut RelOptInfo,
                                     required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_ctescan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_namedtuplestorescan_path(root: *mut PlannerInfo,
                                           rel: *mut RelOptInfo,
                                           required_outer: Relids)
     -> *mut Path;
}
extern "C" {
    pub fn create_worktablescan_path(root: *mut PlannerInfo,
                                     rel: *mut RelOptInfo,
                                     required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_foreignscan_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo,
                                   target: *mut PathTarget, rows: f64,
                                   startup_cost: Cost, total_cost: Cost,
                                   pathkeys: *mut List,
                                   required_outer: Relids,
                                   fdw_outerpath: *mut Path,
                                   fdw_private: *mut List)
     -> *mut ForeignPath;
}
extern "C" {
    pub fn calc_nestloop_required_outer(outer_path: *mut Path,
                                        inner_path: *mut Path) -> Relids;
}
extern "C" {
    pub fn calc_non_nestloop_required_outer(outer_path: *mut Path,
                                            inner_path: *mut Path) -> Relids;
}
extern "C" {
    pub fn create_nestloop_path(root: *mut PlannerInfo,
                                joinrel: *mut RelOptInfo, jointype: JoinType,
                                workspace: *mut JoinCostWorkspace,
                                extra: *mut JoinPathExtraData,
                                outer_path: *mut Path, inner_path: *mut Path,
                                restrict_clauses: *mut List,
                                pathkeys: *mut List, required_outer: Relids)
     -> *mut NestPath;
}
extern "C" {
    pub fn create_mergejoin_path(root: *mut PlannerInfo,
                                 joinrel: *mut RelOptInfo, jointype: JoinType,
                                 workspace: *mut JoinCostWorkspace,
                                 extra: *mut JoinPathExtraData,
                                 outer_path: *mut Path, inner_path: *mut Path,
                                 restrict_clauses: *mut List,
                                 pathkeys: *mut List, required_outer: Relids,
                                 mergeclauses: *mut List,
                                 outersortkeys: *mut List,
                                 innersortkeys: *mut List) -> *mut MergePath;
}
extern "C" {
    pub fn create_hashjoin_path(root: *mut PlannerInfo,
                                joinrel: *mut RelOptInfo, jointype: JoinType,
                                workspace: *mut JoinCostWorkspace,
                                extra: *mut JoinPathExtraData,
                                outer_path: *mut Path, inner_path: *mut Path,
                                restrict_clauses: *mut List,
                                required_outer: Relids,
                                hashclauses: *mut List) -> *mut HashPath;
}
extern "C" {
    pub fn create_projection_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo, subpath: *mut Path,
                                  target: *mut PathTarget)
     -> *mut ProjectionPath;
}
extern "C" {
    pub fn apply_projection_to_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, path: *mut Path,
                                    target: *mut PathTarget) -> *mut Path;
}
extern "C" {
    pub fn create_set_projection_path(root: *mut PlannerInfo,
                                      rel: *mut RelOptInfo,
                                      subpath: *mut Path,
                                      target: *mut PathTarget)
     -> *mut ProjectSetPath;
}
extern "C" {
    pub fn create_sort_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                            subpath: *mut Path, pathkeys: *mut List,
                            limit_tuples: f64) -> *mut SortPath;
}
extern "C" {
    pub fn create_group_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                             subpath: *mut Path, target: *mut PathTarget,
                             groupClause: *mut List, qual: *mut List,
                             numGroups: f64) -> *mut GroupPath;
}
extern "C" {
    pub fn create_upper_unique_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    numCols: ::std::os::raw::c_int,
                                    numGroups: f64) -> *mut UpperUniquePath;
}
extern "C" {
    pub fn create_agg_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                           subpath: *mut Path, target: *mut PathTarget,
                           aggstrategy: AggStrategy, aggsplit: AggSplit,
                           groupClause: *mut List, qual: *mut List,
                           aggcosts: *const AggClauseCosts, numGroups: f64)
     -> *mut AggPath;
}
extern "C" {
    pub fn create_groupingsets_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    target: *mut PathTarget,
                                    having_qual: *mut List,
                                    aggstrategy: AggStrategy,
                                    rollups: *mut List,
                                    agg_costs: *const AggClauseCosts,
                                    numGroups: f64) -> *mut GroupingSetsPath;
}
extern "C" {
    pub fn create_minmaxagg_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 target: *mut PathTarget,
                                 mmaggregates: *mut List, quals: *mut List)
     -> *mut MinMaxAggPath;
}
extern "C" {
    pub fn create_windowagg_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 subpath: *mut Path, target: *mut PathTarget,
                                 windowFuncs: *mut List,
                                 winclause: *mut WindowClause,
                                 winpathkeys: *mut List)
     -> *mut WindowAggPath;
}
extern "C" {
    pub fn create_setop_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                             subpath: *mut Path, cmd: SetOpCmd,
                             strategy: SetOpStrategy, distinctList: *mut List,
                             flagColIdx: AttrNumber,
                             firstFlag: ::std::os::raw::c_int, numGroups: f64,
                             outputRows: f64) -> *mut SetOpPath;
}
extern "C" {
    pub fn create_recursiveunion_path(root: *mut PlannerInfo,
                                      rel: *mut RelOptInfo,
                                      leftpath: *mut Path,
                                      rightpath: *mut Path,
                                      target: *mut PathTarget,
                                      distinctList: *mut List,
                                      wtParam: ::std::os::raw::c_int,
                                      numGroups: f64)
     -> *mut RecursiveUnionPath;
}
extern "C" {
    pub fn create_lockrows_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                subpath: *mut Path, rowMarks: *mut List,
                                epqParam: ::std::os::raw::c_int)
     -> *mut LockRowsPath;
}
extern "C" {
    pub fn create_modifytable_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo, operation: CmdType,
                                   canSetTag: bool_, nominalRelation: Index,
                                   partitioned_rels: *mut List,
                                   resultRelations: *mut List,
                                   subpaths: *mut List, subroots: *mut List,
                                   withCheckOptionLists: *mut List,
                                   returningLists: *mut List,
                                   rowMarks: *mut List,
                                   onconflict: *mut OnConflictExpr,
                                   epqParam: ::std::os::raw::c_int)
     -> *mut ModifyTablePath;
}
extern "C" {
    pub fn create_limit_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                             subpath: *mut Path, limitOffset: *mut Node,
                             limitCount: *mut Node, offset_est: int64,
                             count_est: int64) -> *mut LimitPath;
}
extern "C" {
    pub fn reparameterize_path(root: *mut PlannerInfo, path: *mut Path,
                               required_outer: Relids, loop_count: f64)
     -> *mut Path;
}
extern "C" {
    pub fn setup_simple_rel_arrays(root: *mut PlannerInfo);
}
extern "C" {
    pub fn build_simple_rel(root: *mut PlannerInfo,
                            relid: ::std::os::raw::c_int,
                            parent: *mut RelOptInfo) -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_base_rel(root: *mut PlannerInfo, relid: ::std::os::raw::c_int)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_join_rel(root: *mut PlannerInfo, relids: Relids)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn build_join_rel(root: *mut PlannerInfo, joinrelids: Relids,
                          outer_rel: *mut RelOptInfo,
                          inner_rel: *mut RelOptInfo,
                          sjinfo: *mut SpecialJoinInfo,
                          restrictlist_ptr: *mut *mut List)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn min_join_parameterization(root: *mut PlannerInfo,
                                     joinrelids: Relids,
                                     outer_rel: *mut RelOptInfo,
                                     inner_rel: *mut RelOptInfo) -> Relids;
}
extern "C" {
    pub fn build_empty_join_rel(root: *mut PlannerInfo) -> *mut RelOptInfo;
}
extern "C" {
    pub fn fetch_upper_rel(root: *mut PlannerInfo, kind: UpperRelationKind,
                           relids: Relids) -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_childrel_appendrelinfo(root: *mut PlannerInfo,
                                       rel: *mut RelOptInfo)
     -> *mut AppendRelInfo;
}
extern "C" {
    pub fn find_childrel_parents(root: *mut PlannerInfo, rel: *mut RelOptInfo)
     -> Relids;
}
extern "C" {
    pub fn get_baserel_parampathinfo(root: *mut PlannerInfo,
                                     baserel: *mut RelOptInfo,
                                     required_outer: Relids)
     -> *mut ParamPathInfo;
}
extern "C" {
    pub fn get_joinrel_parampathinfo(root: *mut PlannerInfo,
                                     joinrel: *mut RelOptInfo,
                                     outer_path: *mut Path,
                                     inner_path: *mut Path,
                                     sjinfo: *mut SpecialJoinInfo,
                                     required_outer: Relids,
                                     restrict_clauses: *mut *mut List)
     -> *mut ParamPathInfo;
}
extern "C" {
    pub fn get_appendrel_parampathinfo(appendrel: *mut RelOptInfo,
                                       required_outer: Relids)
     -> *mut ParamPathInfo;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ForceParallelMode {
    FORCE_PARALLEL_OFF = 0,
    FORCE_PARALLEL_ON = 1,
    FORCE_PARALLEL_REGRESS = 2,
}
extern "C" {
    #[link_name = "cursor_tuple_fraction"]
    pub static mut cursor_tuple_fraction: f64;
}
extern "C" {
    #[link_name = "force_parallel_mode"]
    pub static mut force_parallel_mode: ::std::os::raw::c_int;
}
pub type query_pathkeys_callback =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               extra:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn query_planner(root: *mut PlannerInfo, tlist: *mut List,
                         qp_callback: query_pathkeys_callback,
                         qp_extra: *mut ::std::os::raw::c_void)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn preprocess_minmax_aggregates(root: *mut PlannerInfo,
                                        tlist: *mut List);
}
extern "C" {
    pub fn create_plan(root: *mut PlannerInfo, best_path: *mut Path)
     -> *mut Plan;
}
extern "C" {
    pub fn make_foreignscan(qptlist: *mut List, qpqual: *mut List,
                            scanrelid: Index, fdw_exprs: *mut List,
                            fdw_private: *mut List, fdw_scan_tlist: *mut List,
                            fdw_recheck_quals: *mut List,
                            outer_plan: *mut Plan) -> *mut ForeignScan;
}
extern "C" {
    pub fn materialize_finished_plan(subplan: *mut Plan) -> *mut Plan;
}
extern "C" {
    pub fn is_projection_capable_path(path: *mut Path) -> bool_;
}
extern "C" {
    pub fn is_projection_capable_plan(plan: *mut Plan) -> bool_;
}
extern "C" {
    pub fn make_sort_from_sortclauses(sortcls: *mut List, lefttree: *mut Plan)
     -> *mut Sort;
}
extern "C" {
    pub fn make_agg(tlist: *mut List, qual: *mut List,
                    aggstrategy: AggStrategy, aggsplit: AggSplit,
                    numGroupCols: ::std::os::raw::c_int,
                    grpColIdx: *mut AttrNumber, grpOperators: *mut Oid,
                    groupingSets: *mut List, chain: *mut List,
                    dNumGroups: f64, lefttree: *mut Plan) -> *mut Agg;
}
extern "C" {
    pub fn make_limit(lefttree: *mut Plan, limitOffset: *mut Node,
                      limitCount: *mut Node) -> *mut Limit;
}
extern "C" {
    #[link_name = "from_collapse_limit"]
    pub static mut from_collapse_limit: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "join_collapse_limit"]
    pub static mut join_collapse_limit: ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_base_rels_to_query(root: *mut PlannerInfo, jtnode: *mut Node);
}
extern "C" {
    pub fn build_base_rel_tlists(root: *mut PlannerInfo,
                                 final_tlist: *mut List);
}
extern "C" {
    pub fn add_vars_to_targetlist(root: *mut PlannerInfo, vars: *mut List,
                                  where_needed: Relids, create_new_ph: bool_);
}
extern "C" {
    pub fn find_lateral_references(root: *mut PlannerInfo);
}
extern "C" {
    pub fn create_lateral_join_info(root: *mut PlannerInfo);
}
extern "C" {
    pub fn deconstruct_jointree(root: *mut PlannerInfo) -> *mut List;
}
extern "C" {
    pub fn distribute_restrictinfo_to_rels(root: *mut PlannerInfo,
                                           restrictinfo: *mut RestrictInfo);
}
extern "C" {
    pub fn process_implied_equality(root: *mut PlannerInfo, opno: Oid,
                                    collation: Oid, item1: *mut Expr,
                                    item2: *mut Expr, qualscope: Relids,
                                    nullable_relids: Relids,
                                    security_level: Index,
                                    below_outer_join: bool_,
                                    both_const: bool_);
}
extern "C" {
    pub fn build_implied_join_equality(opno: Oid, collation: Oid,
                                       item1: *mut Expr, item2: *mut Expr,
                                       qualscope: Relids,
                                       nullable_relids: Relids,
                                       security_level: Index)
     -> *mut RestrictInfo;
}
extern "C" {
    pub fn match_foreign_keys_to_quals(root: *mut PlannerInfo);
}
extern "C" {
    pub fn remove_useless_joins(root: *mut PlannerInfo, joinlist: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn reduce_unique_semijoins(root: *mut PlannerInfo);
}
extern "C" {
    pub fn query_supports_distinctness(query: *mut Query) -> bool_;
}
extern "C" {
    pub fn query_is_distinct_for(query: *mut Query, colnos: *mut List,
                                 opids: *mut List) -> bool_;
}
extern "C" {
    pub fn innerrel_is_unique(root: *mut PlannerInfo, outerrelids: Relids,
                              innerrel: *mut RelOptInfo, jointype: JoinType,
                              restrictlist: *mut List, force_cache: bool_)
     -> bool_;
}
extern "C" {
    pub fn set_plan_references(root: *mut PlannerInfo, plan: *mut Plan)
     -> *mut Plan;
}
extern "C" {
    pub fn record_plan_function_dependency(root: *mut PlannerInfo,
                                           funcid: Oid);
}
extern "C" {
    pub fn extract_query_dependencies(query: *mut Node,
                                      relationOids: *mut *mut List,
                                      invalItems: *mut *mut List,
                                      hasRowSecurity: *mut bool_);
}
extern "C" {
    pub fn make_restrictinfo(clause: *mut Expr, is_pushed_down: bool_,
                             outerjoin_delayed: bool_, pseudoconstant: bool_,
                             security_level: Index, required_relids: Relids,
                             outer_relids: Relids, nullable_relids: Relids)
     -> *mut RestrictInfo;
}
extern "C" {
    pub fn restriction_is_or_clause(restrictinfo: *mut RestrictInfo) -> bool_;
}
extern "C" {
    pub fn restriction_is_securely_promotable(restrictinfo: *mut RestrictInfo,
                                              rel: *mut RelOptInfo) -> bool_;
}
extern "C" {
    pub fn get_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
}
extern "C" {
    pub fn extract_actual_clauses(restrictinfo_list: *mut List,
                                  pseudoconstant: bool_) -> *mut List;
}
extern "C" {
    pub fn extract_actual_join_clauses(restrictinfo_list: *mut List,
                                       joinquals: *mut *mut List,
                                       otherquals: *mut *mut List);
}
extern "C" {
    pub fn join_clause_is_movable_to(rinfo: *mut RestrictInfo,
                                     baserel: *mut RelOptInfo) -> bool_;
}
extern "C" {
    pub fn join_clause_is_movable_into(rinfo: *mut RestrictInfo,
                                       currentrelids: Relids,
                                       current_and_outer: Relids) -> bool_;
}
extern "C" {
    pub fn byteaout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn eqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn neqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn scalarltsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn scalargtsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn eqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn neqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn scalarltjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn scalargtjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_above_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_below_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn on_pb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn on_ppath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn areasel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn areajoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_contain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timepl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timemi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn intinterval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalrel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timenow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimeeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimeeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalsame(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalct(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalov(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalleneq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervallenne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervallenlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervallengt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervallenle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervallenge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalstart(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timeofday(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstime_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inter_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inter_lb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn index_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn index_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashmacaddr8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hash_aclitem(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bthandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashhandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gisthandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginhandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spghandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brinhandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn amvalidate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_contain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_interpt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_ps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_pb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_ps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_pb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn on_ps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_ppath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn on_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inter_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_append(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_prepend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btarraycmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_cat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashtext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_num_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_num_nonnulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashint2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashint4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashfloat4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashfloat8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashoid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashvarlena(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashoidvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i8tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtoi8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hash_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_indexam_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_index_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_index_column_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i8tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftoi8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn mktinterval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_create(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaGetByte(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaSetByte(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaGetBit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaSetBit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_lb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_cpoly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_dims(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_ndims(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn smgrin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn smgrout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn smgreq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn smgrne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_import(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_export(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_import_with_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervaleq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervallt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_mul_flt4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_div_flt4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn flt4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_mul_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_div_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_mul_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_div_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_mul_flt8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_div_flt8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cashlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cashsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn flt8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_words(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashint8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_open(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_close(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_loread(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lowrite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_lseek(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_creat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_tell(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn on_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn on_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_lb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_unlink(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_inter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_area(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_width(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_height(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_area(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_diagonal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_n_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_n_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_n_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_n_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_n_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_vert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_horiz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_slope(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_construct(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_parallel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_perp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_vertical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_horizontal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_truncate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_point_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclitemin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclitemout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclinsert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclremove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclcontains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclitem_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_step_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_pli(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_mii(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_add_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_div_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstime_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltime_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstime_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_abstime(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_subscripts(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_subscripts_nodir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_fill(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_reltime(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn parse_ident(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn overlaps_timetz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datetime_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int84div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int48div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_fill_with_lower_bounds(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i8tooid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidtoi8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datetimetz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn positionsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn positionjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn contsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn contjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn overlaps_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn makeaclitem(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_timetz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_client_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_client_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_parallel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_perp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_vertical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_horizontal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn points_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pt_contained_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_isclosed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_isopen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_npoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_close(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_open(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_add_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_div_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn construct_point(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_npoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_contain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_area(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_diameter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_radius(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cr_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_pc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pt_contained_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_ls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn close_lseg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_construct_pp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_interpt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nextval_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn currval_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn setval_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbit_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbit_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn biteq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitxor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitnot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitshiftleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitshiftright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitcat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitsubstr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitlength(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitoctetlength(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitfromint4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bittoint4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aclexplode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_mi_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitposition(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitsubstr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn setval3_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_to_number(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn iclikesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn icnlikesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn iclikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn icnlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexeqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn likesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn icregexeqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexnesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nlikesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn icregexnesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn likejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn icregexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn icregexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_ascii_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_ascii_enc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_ascii_encname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int28ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int82ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_numscans(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_idset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_dbid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_userid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_activity(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_numbackends(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_xact_commit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_xact_rollback(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteaeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytealt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteagt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteage(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteane(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteacmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteacat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_substr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteapos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_activity(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstime_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_abstime(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_zone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_izone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_timetz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn aggregate_dummy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitfromint8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bittoint8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_table_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_type_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_function_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_operator_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_opclass_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_conversion_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_activity_start(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_start_backup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stop_backup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_point_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_clear_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn fmgr_internal_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn fmgr_c_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn fmgr_sql_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_reset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_options_to_table(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn postgresql_fdw_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_unnest(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_lt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_le_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_eq_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_gt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_ge_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_ne_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_lt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_le_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_eq_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_gt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_ge_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_ne_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytearecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteasend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bit_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbit_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbit_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn abstimesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn reltimesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tintervalsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetz_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lseg_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn path_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn line_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lastval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_overbelow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_overabove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn box_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_overbelow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_overabove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn poly_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_decompress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_poly_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_poly_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_overbelow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn circle_overabove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_circle_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_circle_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_timezone_abbrevs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xmlexists(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_cmp_prefix(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dasind(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dacosd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datan2d(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsind(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcosd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcotd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stop_backup_v2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn arrayoverlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn arraycontains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn arraycontained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_bgwriter_timed_checkpoints(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_bgwriter_requested_checkpoints(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_bgwriter_buf_written_checkpoints(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_bgwriter_buf_written_clean(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_bgwriter_maxwritten_clean(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_buf_written_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_last_vacuum_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_last_autovacuum_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_last_analyze_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_last_autoanalyze_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn int8_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_wait_event_type(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8inc_any(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8inc_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_blk_read_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_blk_write_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_switch_wal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_current_wal_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_walfile_name_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_walfile_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_current_wal_insert_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_wait_event(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_my_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_is_other_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_timezone_names(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_backend_xact_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_buf_alloc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_live_tuples(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_dead_tuples(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xmlcomment(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texttoxml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xmlvalidate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xmlconcat2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbittypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetztypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timetztypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bittypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bittypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbittypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xmltotext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn table_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn query_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cursor_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn table_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn query_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cursor_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn table_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn query_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xpath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn schema_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn schema_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn schema_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn database_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn database_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn database_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_function_calls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitgetbit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bitsetbit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_listening_channels(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_notify(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_numscans(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_tuples_returned(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_tuples_inserted(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_tuples_hot_updated(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_function_calls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_function_total_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_xact_function_self_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn xpath_exists(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_is_well_formed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_is_well_formed_document(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xml_is_well_formed_content(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_vacuum_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_autovacuum_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_analyze_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_autoanalyze_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_buf_fsync_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_point_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_conflict_tablespace(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_conflict_lock(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_conflict_snapshot(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_conflict_bufferpin(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_conflict_startup_deadlock(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_conflict_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_wal_replay_pause(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_wal_replay_resume(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_is_wal_replay_paused(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_bgwriter_stat_reset_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_tsvector_2args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_sequence_parameters(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_tsquery_5args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_tsquery_consistent_6args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_create_restore_point(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_wal_senders(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn date_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_temp_files(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_temp_bytes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_db_deadlocks(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varbit_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_checkpoint_write_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_checkpoint_sync_time(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_trigger_depth(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_wal_lsn_diff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_remove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_replace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rangesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_lseek64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_tell64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_truncate64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_mod_since_analyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_cardinality(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_archiver(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn width_bucket_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lsn_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttextsortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_step_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_build_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_build_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_ppoly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_position(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_position_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_positions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_circle_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_box_fetch(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_point_fetch(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gist_poly_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_cpoint(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dist_polyp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_config_by_name_missing_ok(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_notification_queue_usage(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_security_active(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_security_active_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_delete(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_delete_idx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_delete_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_set(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidneq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_system_handler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_wal_receiver(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_progress_info(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_filter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_setweight_by_filter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_delete_str(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_unnest(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_delete_arr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_all_file_settings(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_current_wal_flush_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttext_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btbpchar_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_size_bytes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_delete_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_mul_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_div_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_current_if_assigned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_partkeydef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ls_logdir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ls_waldir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ndistinct_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ndistinct_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ndistinct_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ndistinct_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_status(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_safe_snapshot_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_isolation_test_session_is_blocked(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_minmax_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_minmax_add_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_minmax_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_minmax_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_match_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_match(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_hba_file_rules(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_statistics_obj_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_dependencies_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_dependencies_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_dependencies_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_dependencies_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_partition_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_statisticsobjdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_system(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_checkpoint(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_recovery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_import_system_collations(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_collation_actual_version(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_from_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_get(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_get_fragment(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn be_lo_put(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_range_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_range_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_range_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_range_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_range_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_compare_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_jsonb_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_consistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_jsonb_query_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_consistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_triconsistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_triconsistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashenum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8dec(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8dec_any(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_decompress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn networksel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn networkjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_gist_fetch(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_logical_emit_message_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_logical_emit_message_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_insert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_pg_type_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_last_committed_xact(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_array_pg_type_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_toast_pg_type_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_heap_pg_class_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_index_pg_class_oid(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_toast_pg_class_oid(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_pg_enum_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_next_pg_authid_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn binary_upgrade_create_empty_extension(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsqueryin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsqueryout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_strip(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_setweight(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_match_vq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_match_qv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquerysend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsqueryrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_decompress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_tsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_numnode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquerytree(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_rewrite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_rewrite_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsmatchsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsmatchjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_stat1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_stat2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsq_mcontains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsq_mcontained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_decompress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rank_wttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rank_wtt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rank_ttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rank_tt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rankcd_wttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rankcd_wtt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rankcd_ttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_rankcd_tt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_token_type_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_token_type_byname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_parse_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_parse_byname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn prsd_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn prsd_nexttoken(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn prsd_end(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn prsd_headline(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn prsd_lextype(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_cmp_tslexeme(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsimple_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsimple_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsynonym_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsynonym_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dispell_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dispell_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn thesaurus_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn thesaurus_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn plainto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn plainto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_update_trigger_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsvector_update_trigger_bycolumn(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn ts_headline_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ts_parser_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ts_dict_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ts_config_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn get_current_ts_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_match_tt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_match_tq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ts_template_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_reset_shared(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_reset_single_table_counters(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_reset_single_function_counters(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_logical_slot_get_changes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_logical_slot_get_binary_changes(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_logical_slot_peek_changes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_logical_slot_peek_binary_changes(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn to_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_get_snapshot_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_clean_pending_list(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsvector_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_extract_tsquery_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_tsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gtsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_spg_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_spg_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_spg_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_spg_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_spg_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_current_logfile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_current_logfile_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_export_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_is_in_recovery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_is_in_backup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_backup_start_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_collation_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn arraycontsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn arraycontjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_last_wal_receive_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_last_wal_replay_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_div_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cash_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_opfamily_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_last_xact_replay_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_constructor2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_constructor3(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn make_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn make_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_empty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_lower_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_upper_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_lower_inf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_upper_inf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_overlaps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_contains_elem(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_contains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn elem_contained_by_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_contained_by(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_adjacent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_before(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_after(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_minus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_decompress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hash_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4range_canonical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn daterange_canonical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn interval_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn gin_tsquery_triconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn daterange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8range_canonical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tstzrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn mxid_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn acldefault_sql(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn time_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_summarize_new_values(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_object_address(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_izone_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn timestamp_zone_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_gist_fetch(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_summarize_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_desummarize_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_sequence_last_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_contains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_exists(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_exists_any(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_exists_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_agg_array_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_agg_array_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn range_merge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_merge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boxes_bound_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_same_family(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn binary_upgrade_set_record_init_privs(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn regnamespacein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespaceout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regnamespace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespacerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespacesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn point_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regroleout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regrole(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regrolerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regrolesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regrolein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_inclusion_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_inclusion_add_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_inclusion_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn brin_inclusion_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddrtomacaddr8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8tomacaddr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr8_set7bit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_jsonb_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_jsonb_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_jsonb_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_json_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_json_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_json_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ts_headline_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn phraseto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_phrase(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsquery_phrase_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn phraseto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_box_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_box_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_box_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_box_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_box_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_create(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_drop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_session_setup(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_session_reset(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_session_is_setup(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_session_progress(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_xact_setup(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_xact_reset(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_advance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_replication_origin_progress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_show_replication_origin_status(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_stat_get_subscription(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_publication_tables(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_replica_identity_index(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_is_publishable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn parse_bool(value: *const ::std::os::raw::c_char,
                      result: *mut bool_) -> bool_;
}
extern "C" {
    pub fn parse_bool_with_len(value: *const ::std::os::raw::c_char,
                               len: usize, result: *mut bool_) -> bool_;
}
extern "C" {
    pub fn domain_check(value: Datum, isnull: bool_, domainType: Oid,
                        extra: *mut *mut ::std::os::raw::c_void,
                        mcxt: MemoryContext);
}
extern "C" {
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdomainconstraint(datatypeOid: Oid,
                               conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hex_encode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hex_decode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int)
     -> *mut int2vector;
}
extern "C" {
    pub fn namecpy(n1: Name, n2: Name) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn namestrcpy(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn namestrcmp(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_atoi(s: *const ::std::os::raw::c_char,
                   size: ::std::os::raw::c_int, c: ::std::os::raw::c_int)
     -> int32;
}
extern "C" {
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pg_ltoa(l: int32, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pg_lltoa(ll: int64, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pg_ltostr_zeropad(str: *mut ::std::os::raw::c_char, value: int32,
                             minwidth: int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_ltostr(str: *mut ::std::os::raw::c_char, value: int32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_strtouint64(str: *const ::std::os::raw::c_char,
                          endptr: *mut *mut ::std::os::raw::c_char,
                          base: ::std::os::raw::c_int) -> uint64;
}
extern "C" {
    #[link_name = "extra_float_digits"]
    pub static mut extra_float_digits: ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_float8_infinity() -> f64;
}
extern "C" {
    pub fn get_float4_infinity() -> f32;
}
extern "C" {
    pub fn get_float8_nan() -> f64;
}
extern "C" {
    pub fn get_float4_nan() -> f32;
}
extern "C" {
    pub fn is_infinite(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn float8in_internal(num: *mut ::std::os::raw::c_char,
                             endptr_p: *mut *mut ::std::os::raw::c_char,
                             type_name: *const ::std::os::raw::c_char,
                             orig_string: *const ::std::os::raw::c_char)
     -> f64;
}
extern "C" {
    pub fn float8out_internal(num: f64) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn float4_cmp_internal(a: float4, b: float4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn float8_cmp_internal(a: float8, b: float8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int)
     -> *mut oidvector;
}
extern "C" {
    pub fn oidparse(node: *mut Node) -> Oid;
}
extern "C" {
    pub fn oid_cmp(p1: *const ::std::os::raw::c_void,
                   p2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regexp_fixed_prefix(text_re: *mut text, case_insensitive: bool_,
                               collation: Oid, exact: *mut bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "quote_all_identifiers"]
    pub static mut quote_all_identifiers: bool_;
}
extern "C" {
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn quote_qualified_identifier(qualifier:
                                          *const ::std::os::raw::c_char,
                                      ident: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bpchartruelen(s: *mut ::std::os::raw::c_char,
                         len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
}
extern "C" {
    pub fn cstring_to_text_with_len(s: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int) -> *mut text;
}
extern "C" {
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text_to_cstring_buffer(src: *const text,
                                  dst: *mut ::std::os::raw::c_char,
                                  dst_len: usize);
}
extern "C" {
    pub fn xidComparator(arg1: *const ::std::os::raw::c_void,
                         arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_cidr_ntop(af: ::std::os::raw::c_int,
                          src: *const ::std::os::raw::c_void,
                          bits: ::std::os::raw::c_int,
                          dst: *mut ::std::os::raw::c_char, size: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_char,
                         dst: *mut ::std::os::raw::c_void, size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn convert_network_to_scalar(value: Datum, typid: Oid) -> f64;
}
extern "C" {
    pub fn network_scan_first(in_: Datum) -> Datum;
}
extern "C" {
    pub fn network_scan_last(in_: Datum) -> Datum;
}
extern "C" {
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int,
                           addr: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_type_be_qualified(type_oid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_type_with_typemod_qualified(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
}
extern "C" {
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn escape_json(buf: StringInfo, str: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Copy)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
#[test]
fn bindgen_test_layout_OpBtreeInterpretation() {
    assert_eq!(::std::mem::size_of::<OpBtreeInterpretation>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( OpBtreeInterpretation )
               ));
    assert_eq! (::std::mem::align_of::<OpBtreeInterpretation>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( OpBtreeInterpretation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpBtreeInterpretation ) ) . opfamily_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OpBtreeInterpretation )
                , "::" , stringify ! ( opfamily_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpBtreeInterpretation ) ) . strategy as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OpBtreeInterpretation )
                , "::" , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpBtreeInterpretation ) ) . oplefttype as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OpBtreeInterpretation )
                , "::" , stringify ! ( oplefttype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OpBtreeInterpretation ) ) . oprighttype
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( OpBtreeInterpretation )
                , "::" , stringify ! ( oprighttype ) ));
}
impl Clone for OpBtreeInterpretation {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IOFuncSelector {
    IOFunc_input = 0,
    IOFunc_output = 1,
    IOFunc_receive = 2,
    IOFunc_send = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct AttStatsSlot {
    pub staop: Oid,
    pub valuetype: Oid,
    pub values: *mut Datum,
    pub nvalues: ::std::os::raw::c_int,
    pub numbers: *mut float4,
    pub nnumbers: ::std::os::raw::c_int,
    pub values_arr: *mut ::std::os::raw::c_void,
    pub numbers_arr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AttStatsSlot() {
    assert_eq!(::std::mem::size_of::<AttStatsSlot>() , 56usize , concat ! (
               "Size of: " , stringify ! ( AttStatsSlot ) ));
    assert_eq! (::std::mem::align_of::<AttStatsSlot>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AttStatsSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . staop as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( staop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . valuetype as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( valuetype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . values as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . nvalues as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( nvalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . numbers as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( numbers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . nnumbers as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( nnumbers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . values_arr as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( values_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttStatsSlot ) ) . numbers_arr as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AttStatsSlot ) , "::" ,
                stringify ! ( numbers_arr ) ));
}
impl Clone for AttStatsSlot {
    fn clone(&self) -> Self { *self }
}
pub type get_attavgwidth_hook_type =
    ::std::option::Option<unsafe extern "C" fn(relid: Oid, attnum: AttrNumber)
                              -> int32>;
extern "C" {
    #[link_name = "get_attavgwidth_hook"]
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
}
extern "C" {
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> bool_;
}
extern "C" {
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
}
extern "C" {
    pub fn get_op_opfamily_properties(opno: Oid, opfamily: Oid,
                                      ordering_op: bool_,
                                      strategy: *mut ::std::os::raw::c_int,
                                      lefttype: *mut Oid,
                                      righttype: *mut Oid);
}
extern "C" {
    pub fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid,
                               strategy: int16) -> Oid;
}
extern "C" {
    pub fn get_ordering_op_properties(opno: Oid, opfamily: *mut Oid,
                                      opcintype: *mut Oid,
                                      strategy: *mut int16) -> bool_;
}
extern "C" {
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut bool_)
     -> Oid;
}
extern "C" {
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool_)
     -> Oid;
}
extern "C" {
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
}
extern "C" {
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid,
                                         rhs_opno: *mut Oid) -> bool_;
}
extern "C" {
    pub fn get_op_hash_functions(opno: Oid, lhs_procno: *mut RegProcedure,
                                 rhs_procno: *mut RegProcedure) -> bool_;
}
extern "C" {
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
}
extern "C" {
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool_;
}
extern "C" {
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid,
                             procnum: int16) -> Oid;
}
extern "C" {
    pub fn get_attname(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_relid_attribute_name(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_attnum(relid: Oid, attname: *const ::std::os::raw::c_char)
     -> AttrNumber;
}
extern "C" {
    pub fn get_attidentity(relid: Oid, attnum: AttrNumber)
     -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
}
extern "C" {
    pub fn get_atttypmod(relid: Oid, attnum: AttrNumber) -> int32;
}
extern "C" {
    pub fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber,
                                 typid: *mut Oid, typmod: *mut int32,
                                 collid: *mut Oid);
}
extern "C" {
    pub fn get_collation_name(colloid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_constraint_name(conoid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_language_name(langoid: Oid, missing_ok: bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_opclass_family(opclass: Oid) -> Oid;
}
extern "C" {
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
}
extern "C" {
    pub fn get_opcode(opno: Oid) -> RegProcedure;
}
extern "C" {
    pub fn get_opname(opno: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_op_rettype(opno: Oid) -> Oid;
}
extern "C" {
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
}
extern "C" {
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> bool_;
}
extern "C" {
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> bool_;
}
extern "C" {
    pub fn op_strict(opno: Oid) -> bool_;
}
extern "C" {
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_commutator(opno: Oid) -> Oid;
}
extern "C" {
    pub fn get_negator(opno: Oid) -> Oid;
}
extern "C" {
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
}
extern "C" {
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
}
extern "C" {
    pub fn get_func_name(funcid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_func_namespace(funcid: Oid) -> Oid;
}
extern "C" {
    pub fn get_func_rettype(funcid: Oid) -> Oid;
}
extern "C" {
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_func_signature(funcid: Oid, argtypes: *mut *mut Oid,
                              nargs: *mut ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
}
extern "C" {
    pub fn get_func_retset(funcid: Oid) -> bool_;
}
extern "C" {
    pub fn func_strict(funcid: Oid) -> bool_;
}
extern "C" {
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn func_parallel(funcid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_func_leakproof(funcid: Oid) -> bool_;
}
extern "C" {
    pub fn get_func_cost(funcid: Oid) -> float4;
}
extern "C" {
    pub fn get_func_rows(funcid: Oid) -> float4;
}
extern "C" {
    pub fn get_relname_relid(relname: *const ::std::os::raw::c_char,
                             relnamespace: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_name(relid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_rel_namespace(relid: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_type_id(relid: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_persistence(relid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: *mut List)
     -> Oid;
}
extern "C" {
    pub fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: *mut List)
     -> Oid;
}
extern "C" {
    pub fn get_typisdefined(typid: Oid) -> bool_;
}
extern "C" {
    pub fn get_typlen(typid: Oid) -> int16;
}
extern "C" {
    pub fn get_typbyval(typid: Oid) -> bool_;
}
extern "C" {
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16,
                           typbyval: *mut bool_);
}
extern "C" {
    pub fn get_typlenbyvalalign(typid: Oid, typlen: *mut int16,
                                typbyval: *mut bool_,
                                typalign: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
}
extern "C" {
    pub fn get_type_io_data(typid: Oid, which_func: IOFuncSelector,
                            typlen: *mut int16, typbyval: *mut bool_,
                            typalign: *mut ::std::os::raw::c_char,
                            typdelim: *mut ::std::os::raw::c_char,
                            typioparam: *mut Oid, func: *mut Oid);
}
extern "C" {
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_typdefault(typid: Oid) -> *mut Node;
}
extern "C" {
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn type_is_rowtype(typid: Oid) -> bool_;
}
extern "C" {
    pub fn type_is_enum(typid: Oid) -> bool_;
}
extern "C" {
    pub fn type_is_range(typid: Oid) -> bool_;
}
extern "C" {
    pub fn get_type_category_preferred(typid: Oid,
                                       typcategory:
                                           *mut ::std::os::raw::c_char,
                                       typispreferred: *mut bool_);
}
extern "C" {
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_element_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_array_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_promoted_array_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_base_element_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn getTypeInputInfo(type_: Oid, typInput: *mut Oid,
                            typIOParam: *mut Oid);
}
extern "C" {
    pub fn getTypeOutputInfo(type_: Oid, typOutput: *mut Oid,
                             typIsVarlena: *mut bool_);
}
extern "C" {
    pub fn getTypeBinaryInputInfo(type_: Oid, typReceive: *mut Oid,
                                  typIOParam: *mut Oid);
}
extern "C" {
    pub fn getTypeBinaryOutputInfo(type_: Oid, typSend: *mut Oid,
                                   typIsVarlena: *mut bool_);
}
extern "C" {
    pub fn get_typmodin(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_typcollation(typid: Oid) -> Oid;
}
extern "C" {
    pub fn type_is_collatable(typid: Oid) -> bool_;
}
extern "C" {
    pub fn getBaseType(typid: Oid) -> Oid;
}
extern "C" {
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
}
extern "C" {
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
}
extern "C" {
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
}
extern "C" {
    pub fn get_attstatsslot(sslot: *mut AttStatsSlot, statstuple: HeapTuple,
                            reqkind: ::std::os::raw::c_int, reqop: Oid,
                            flags: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn free_attstatsslot(sslot: *mut AttStatsSlot);
}
extern "C" {
    pub fn get_namespace_name(nspid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_namespace_name_or_temp(nspid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
}
pub type RmgrId = uint8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RmgrIds {
    RM_XLOG_ID = 0,
    RM_XACT_ID = 1,
    RM_SMGR_ID = 2,
    RM_CLOG_ID = 3,
    RM_DBASE_ID = 4,
    RM_TBLSPC_ID = 5,
    RM_MULTIXACT_ID = 6,
    RM_RELMAP_ID = 7,
    RM_STANDBY_ID = 8,
    RM_HEAP2_ID = 9,
    RM_HEAP_ID = 10,
    RM_BTREE_ID = 11,
    RM_HASH_ID = 12,
    RM_GIN_ID = 13,
    RM_GIST_ID = 14,
    RM_SEQ_ID = 15,
    RM_SPGIST_ID = 16,
    RM_BRIN_ID = 17,
    RM_COMMIT_TS_ID = 18,
    RM_REPLORIGIN_ID = 19,
    RM_GENERIC_ID = 20,
    RM_LOGICALMSG_ID = 21,
    RM_NEXT_ID = 22,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ForkNumber {
    InvalidForkNumber = -1,
    MAIN_FORKNUM = 0,
    FSM_FORKNUM = 1,
    VISIBILITYMAP_FORKNUM = 2,
    INIT_FORKNUM = 3,
}
extern "C" {
    #[link_name = "forkNames"]
    pub static mut forkNames: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn forkname_to_number(forkName: *const ::std::os::raw::c_char)
     -> ForkNumber;
}
extern "C" {
    pub fn forkname_chars(str: *const ::std::os::raw::c_char,
                          fork: *mut ForkNumber) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetRelationPath(dbNode: Oid, spcNode: Oid, relNode: Oid,
                           backendId: ::std::os::raw::c_int,
                           forkNumber: ForkNumber)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
#[test]
fn bindgen_test_layout_RelFileNode() {
    assert_eq!(::std::mem::size_of::<RelFileNode>() , 12usize , concat ! (
               "Size of: " , stringify ! ( RelFileNode ) ));
    assert_eq! (::std::mem::align_of::<RelFileNode>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RelFileNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelFileNode ) ) . spcNode as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RelFileNode ) , "::" ,
                stringify ! ( spcNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelFileNode ) ) . dbNode as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RelFileNode ) , "::" ,
                stringify ! ( dbNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelFileNode ) ) . relNode as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RelFileNode ) , "::" ,
                stringify ! ( relNode ) ));
}
impl Clone for RelFileNode {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
#[test]
fn bindgen_test_layout_RelFileNodeBackend() {
    assert_eq!(::std::mem::size_of::<RelFileNodeBackend>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( RelFileNodeBackend ) ));
    assert_eq! (::std::mem::align_of::<RelFileNodeBackend>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( RelFileNodeBackend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelFileNodeBackend ) ) . node as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RelFileNodeBackend ) ,
                "::" , stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RelFileNodeBackend ) ) . backend as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RelFileNodeBackend ) ,
                "::" , stringify ! ( backend ) ));
}
impl Clone for RelFileNodeBackend {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn XLogBeginInsert();
}
extern "C" {
    pub fn XLogSetRecordFlags(flags: uint8);
}
extern "C" {
    pub fn XLogInsert(rmid: RmgrId, info: uint8) -> XLogRecPtr;
}
extern "C" {
    pub fn XLogEnsureRecordSpace(nbuffers: ::std::os::raw::c_int,
                                 ndatas: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XLogRegisterData(data: *mut ::std::os::raw::c_char,
                            len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XLogRegisterBuffer(block_id: uint8, buffer: Buffer, flags: uint8);
}
extern "C" {
    pub fn XLogRegisterBlock(block_id: uint8, rnode: *mut RelFileNode,
                             forknum: ForkNumber, blknum: BlockNumber,
                             page: *mut ::std::os::raw::c_char, flags: uint8);
}
extern "C" {
    pub fn XLogRegisterBufData(block_id: uint8,
                               data: *mut ::std::os::raw::c_char,
                               len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XLogResetInsertion();
}
extern "C" {
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> bool_;
}
extern "C" {
    pub fn log_newpage(rnode: *mut RelFileNode, forkNum: ForkNumber,
                       blk: BlockNumber, page: *mut ::std::os::raw::c_char,
                       page_std: bool_) -> XLogRecPtr;
}
extern "C" {
    pub fn log_newpage_buffer(buffer: Buffer, page_std: bool_) -> XLogRecPtr;
}
extern "C" {
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: bool_)
     -> XLogRecPtr;
}
extern "C" {
    pub fn InitXLogInsert();
}
pub type pg_crc32c = uint32;
extern "C" {
    pub fn pg_comp_crc32c_sse42(crc: pg_crc32c,
                                data: *const ::std::os::raw::c_void,
                                len: usize) -> pg_crc32c;
}
extern "C" {
    pub fn pg_comp_crc32c_sb8(crc: pg_crc32c,
                              data: *const ::std::os::raw::c_void, len: usize)
     -> pg_crc32c;
}
extern "C" {
    #[link_name = "pg_comp_crc32c"]
    pub static mut pg_comp_crc32c:
               ::std::option::Option<unsafe extern "C" fn(crc: pg_crc32c,
                                                          data:
                                                              *const ::std::os::raw::c_void,
                                                          len: usize)
                                         -> pg_crc32c>;
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
#[test]
fn bindgen_test_layout_XLogRecord() {
    assert_eq!(::std::mem::size_of::<XLogRecord>() , 24usize , concat ! (
               "Size of: " , stringify ! ( XLogRecord ) ));
    assert_eq! (::std::mem::align_of::<XLogRecord>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( XLogRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecord ) ) . xl_tot_len as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecord ) , "::" ,
                stringify ! ( xl_tot_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecord ) ) . xl_xid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecord ) , "::" ,
                stringify ! ( xl_xid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecord ) ) . xl_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecord ) , "::" ,
                stringify ! ( xl_prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecord ) ) . xl_info as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecord ) , "::" ,
                stringify ! ( xl_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecord ) ) . xl_rmid as * const _ as
                usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecord ) , "::" ,
                stringify ! ( xl_rmid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecord ) ) . xl_crc as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecord ) , "::" ,
                stringify ! ( xl_crc ) ));
}
impl Clone for XLogRecord {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
#[test]
fn bindgen_test_layout_XLogRecordBlockHeader() {
    assert_eq!(::std::mem::size_of::<XLogRecordBlockHeader>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( XLogRecordBlockHeader )
               ));
    assert_eq! (::std::mem::align_of::<XLogRecordBlockHeader>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( XLogRecordBlockHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockHeader ) ) . id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecordBlockHeader )
                , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockHeader ) ) . fork_flags as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecordBlockHeader )
                , "::" , stringify ! ( fork_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockHeader ) ) . data_length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogRecordBlockHeader )
                , "::" , stringify ! ( data_length ) ));
}
impl Clone for XLogRecordBlockHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
#[test]
fn bindgen_test_layout_XLogRecordBlockImageHeader() {
    assert_eq!(::std::mem::size_of::<XLogRecordBlockImageHeader>() , 6usize ,
               concat ! (
               "Size of: " , stringify ! ( XLogRecordBlockImageHeader ) ));
    assert_eq! (::std::mem::align_of::<XLogRecordBlockImageHeader>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( XLogRecordBlockImageHeader )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockImageHeader ) ) . length
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordBlockImageHeader ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockImageHeader ) ) .
                hole_offset as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordBlockImageHeader ) , "::" , stringify ! (
                hole_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockImageHeader ) ) .
                bimg_info as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordBlockImageHeader ) , "::" , stringify ! ( bimg_info
                ) ));
}
impl Clone for XLogRecordBlockImageHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
#[test]
fn bindgen_test_layout_XLogRecordBlockCompressHeader() {
    assert_eq!(::std::mem::size_of::<XLogRecordBlockCompressHeader>() , 2usize
               , concat ! (
               "Size of: " , stringify ! ( XLogRecordBlockCompressHeader ) ));
    assert_eq! (::std::mem::align_of::<XLogRecordBlockCompressHeader>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( XLogRecordBlockCompressHeader
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordBlockCompressHeader ) ) .
                hole_length as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordBlockCompressHeader ) , "::" , stringify ! (
                hole_length ) ));
}
impl Clone for XLogRecordBlockCompressHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
#[test]
fn bindgen_test_layout_XLogRecordDataHeaderShort() {
    assert_eq!(::std::mem::size_of::<XLogRecordDataHeaderShort>() , 2usize ,
               concat ! (
               "Size of: " , stringify ! ( XLogRecordDataHeaderShort ) ));
    assert_eq! (::std::mem::align_of::<XLogRecordDataHeaderShort>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( XLogRecordDataHeaderShort )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordDataHeaderShort ) ) . id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordDataHeaderShort ) , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordDataHeaderShort ) ) .
                data_length as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordDataHeaderShort ) , "::" , stringify ! ( data_length
                ) ));
}
impl Clone for XLogRecordDataHeaderShort {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogRecordDataHeaderLong {
    pub id: uint8,
}
#[test]
fn bindgen_test_layout_XLogRecordDataHeaderLong() {
    assert_eq!(::std::mem::size_of::<XLogRecordDataHeaderLong>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( XLogRecordDataHeaderLong ) ));
    assert_eq! (::std::mem::align_of::<XLogRecordDataHeaderLong>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( XLogRecordDataHeaderLong ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogRecordDataHeaderLong ) ) . id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                XLogRecordDataHeaderLong ) , "::" , stringify ! ( id ) ));
}
impl Clone for XLogRecordDataHeaderLong {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct XLogReaderState {
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: *mut ::std::os::raw::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub decoded_record: *mut XLogRecord,
    pub main_data: *mut ::std::os::raw::c_char,
    pub main_data_len: uint32,
    pub main_data_bufsz: uint32,
    pub record_origin: RepOriginId,
    pub blocks: [DecodedBkpBlock; 33usize],
    pub max_block_id: ::std::os::raw::c_int,
    pub readBuf: *mut ::std::os::raw::c_char,
    pub readLen: uint32,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub currTLI: TimeLineID,
    pub currTLIValidUntil: XLogRecPtr,
    pub nextTLI: TimeLineID,
    pub readRecordBuf: *mut ::std::os::raw::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XLogReaderState() {
    assert_eq!(::std::mem::size_of::<XLogReaderState>() , 2296usize , concat !
               ( "Size of: " , stringify ! ( XLogReaderState ) ));
    assert_eq! (::std::mem::align_of::<XLogReaderState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( XLogReaderState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . read_page as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( read_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . system_identifier
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( system_identifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . private_data as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( private_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . ReadRecPtr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( ReadRecPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . EndRecPtr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( EndRecPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . decoded_record as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( decoded_record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . main_data as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( main_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . main_data_len as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( main_data_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . main_data_bufsz as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( main_data_bufsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . record_origin as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( record_origin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . blocks as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . max_block_id as *
                const _ as usize } , 2184usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( max_block_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readBuf as * const
                _ as usize } , 2192usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readBuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readLen as * const
                _ as usize } , 2200usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readLen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readSegNo as *
                const _ as usize } , 2208usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readSegNo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readOff as * const
                _ as usize } , 2216usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readOff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readPageTLI as *
                const _ as usize } , 2220usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readPageTLI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . latestPagePtr as *
                const _ as usize } , 2224usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( latestPagePtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . latestPageTLI as *
                const _ as usize } , 2232usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( latestPageTLI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . currRecPtr as *
                const _ as usize } , 2240usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( currRecPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . currTLI as * const
                _ as usize } , 2248usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( currTLI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . currTLIValidUntil
                as * const _ as usize } , 2256usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( currTLIValidUntil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . nextTLI as * const
                _ as usize } , 2264usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( nextTLI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readRecordBuf as *
                const _ as usize } , 2272usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readRecordBuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . readRecordBufSize
                as * const _ as usize } , 2280usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( readRecordBufSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const XLogReaderState ) ) . errormsg_buf as *
                const _ as usize } , 2288usize , concat ! (
                "Alignment of field: " , stringify ! ( XLogReaderState ) ,
                "::" , stringify ! ( errormsg_buf ) ));
}
impl Clone for XLogReaderState {
    fn clone(&self) -> Self { *self }
}
pub type XLogPageReadCB =
    ::std::option::Option<unsafe extern "C" fn(xlogreader:
                                                   *mut XLogReaderState,
                                               targetPagePtr: XLogRecPtr,
                                               reqLen: ::std::os::raw::c_int,
                                               targetRecPtr: XLogRecPtr,
                                               readBuf:
                                                   *mut ::std::os::raw::c_char,
                                               pageTLI: *mut TimeLineID)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct DecodedBkpBlock {
    pub in_use: bool_,
    pub rnode: RelFileNode,
    pub forknum: ForkNumber,
    pub blkno: BlockNumber,
    pub flags: uint8,
    pub has_image: bool_,
    pub apply_image: bool_,
    pub bkp_image: *mut ::std::os::raw::c_char,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: bool_,
    pub data: *mut ::std::os::raw::c_char,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
#[test]
fn bindgen_test_layout_DecodedBkpBlock() {
    assert_eq!(::std::mem::size_of::<DecodedBkpBlock>() , 64usize , concat ! (
               "Size of: " , stringify ! ( DecodedBkpBlock ) ));
    assert_eq! (::std::mem::align_of::<DecodedBkpBlock>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( DecodedBkpBlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . in_use as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( in_use ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . rnode as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( rnode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . forknum as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( forknum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . blkno as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( blkno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . flags as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . has_image as *
                const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( has_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . apply_image as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( apply_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . bkp_image as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( bkp_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . hole_offset as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( hole_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . hole_length as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( hole_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . bimg_len as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( bimg_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . bimg_info as *
                const _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( bimg_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . has_data as * const
                _ as usize } , 47usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( has_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . data as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . data_len as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( data_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecodedBkpBlock ) ) . data_bufsz as *
                const _ as usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( DecodedBkpBlock ) ,
                "::" , stringify ! ( data_bufsz ) ));
}
impl Clone for DecodedBkpBlock {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn XLogReaderAllocate(pagereadfunc: XLogPageReadCB,
                              private_data: *mut ::std::os::raw::c_void)
     -> *mut XLogReaderState;
}
extern "C" {
    pub fn XLogReaderFree(state: *mut XLogReaderState);
}
extern "C" {
    pub fn XLogReadRecord(state: *mut XLogReaderState, recptr: XLogRecPtr,
                          errormsg: *mut *mut ::std::os::raw::c_char)
     -> *mut XLogRecord;
}
extern "C" {
    pub fn XLogReaderInvalReadState(state: *mut XLogReaderState);
}
extern "C" {
    pub fn DecodeXLogRecord(state: *mut XLogReaderState,
                            record: *mut XLogRecord,
                            errmsg: *mut *mut ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn RestoreBlockImage(recoder: *mut XLogReaderState, block_id: uint8,
                             dst: *mut ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn XLogRecGetBlockData(record: *mut XLogReaderState, block_id: uint8,
                               len: *mut Size) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XLogRecGetBlockTag(record: *mut XLogReaderState, block_id: uint8,
                              rnode: *mut RelFileNode,
                              forknum: *mut ForkNumber,
                              blknum: *mut BlockNumber) -> bool_;
}
#[repr(C)]
#[derive(Copy)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(::std::mem::size_of::<dirent>() , 280usize , concat ! (
               "Size of: " , stringify ! ( dirent ) ));
    assert_eq! (::std::mem::align_of::<dirent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dirent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_ino as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_off as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_reclen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_reclen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_type as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_name as * const _ as usize
                } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_name ) ));
}
impl Clone for dirent {
    fn clone(&self) -> Self { *self }
}
pub const DT_UNKNOWN: _bindgen_ty_17 = _bindgen_ty_17::DT_UNKNOWN;
pub const DT_FIFO: _bindgen_ty_17 = _bindgen_ty_17::DT_FIFO;
pub const DT_CHR: _bindgen_ty_17 = _bindgen_ty_17::DT_CHR;
pub const DT_DIR: _bindgen_ty_17 = _bindgen_ty_17::DT_DIR;
pub const DT_BLK: _bindgen_ty_17 = _bindgen_ty_17::DT_BLK;
pub const DT_REG: _bindgen_ty_17 = _bindgen_ty_17::DT_REG;
pub const DT_LNK: _bindgen_ty_17 = _bindgen_ty_17::DT_LNK;
pub const DT_SOCK: _bindgen_ty_17 = _bindgen_ty_17::DT_SOCK;
pub const DT_WHT: _bindgen_ty_17 = _bindgen_ty_17::DT_WHT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut dirent,
                     __result: *mut *mut dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(__dir: *const ::std::os::raw::c_char,
                   __namelist: *mut *mut *mut dirent,
                   __selector:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const dirent)
                                                 -> ::std::os::raw::c_int>,
                   __cmp:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut *const dirent,
                                                                  arg2:
                                                                      *mut *const dirent)
                                                 -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(__fd: ::std::os::raw::c_int,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: usize,
                         __basep: *mut __off_t) -> __ssize_t;
}
pub type FileName = *mut ::std::os::raw::c_char;
pub type File = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "max_files_per_process"]
    pub static mut max_files_per_process: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_safe_fds"]
    pub static mut max_safe_fds: ::std::os::raw::c_int;
}
extern "C" {
    pub fn PathNameOpenFile(fileName: FileName,
                            fileFlags: ::std::os::raw::c_int,
                            fileMode: ::std::os::raw::c_int) -> File;
}
extern "C" {
    pub fn OpenTemporaryFile(interXact: bool_) -> File;
}
extern "C" {
    pub fn FileClose(file: File);
}
extern "C" {
    pub fn FilePrefetch(file: File, offset: off_t,
                        amount: ::std::os::raw::c_int,
                        wait_event_info: uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileRead(file: File, buffer: *mut ::std::os::raw::c_char,
                    amount: ::std::os::raw::c_int, wait_event_info: uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileWrite(file: File, buffer: *mut ::std::os::raw::c_char,
                     amount: ::std::os::raw::c_int, wait_event_info: uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileSync(file: File, wait_event_info: uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileSeek(file: File, offset: off_t, whence: ::std::os::raw::c_int)
     -> off_t;
}
extern "C" {
    pub fn FileTruncate(file: File, offset: off_t, wait_event_info: uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileWriteback(file: File, offset: off_t, nbytes: off_t,
                         wait_event_info: uint32);
}
extern "C" {
    pub fn FilePathName(file: File) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn FileGetRawDesc(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileGetRawFlags(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileGetRawMode(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AllocateFile(name: *const ::std::os::raw::c_char,
                        mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn FreeFile(file: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OpenPipeStream(command: *const ::std::os::raw::c_char,
                          mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn ClosePipeStream(file: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AllocateDir(dirname: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn ReadDir(dir: *mut DIR, dirname: *const ::std::os::raw::c_char)
     -> *mut dirent;
}
extern "C" {
    pub fn FreeDir(dir: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OpenTransientFile(fileName: FileName,
                             fileFlags: ::std::os::raw::c_int,
                             fileMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CloseTransientFile(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BasicOpenFile(fileName: FileName, fileFlags: ::std::os::raw::c_int,
                         fileMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InitFileAccess();
}
extern "C" {
    pub fn set_max_safe_fds();
}
extern "C" {
    pub fn closeAllVfds();
}
extern "C" {
    pub fn SetTempTablespaces(tableSpaces: *mut Oid,
                              numSpaces: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TempTablespacesAreSet() -> bool_;
}
extern "C" {
    pub fn GetNextTempTableSpace() -> Oid;
}
extern "C" {
    pub fn AtEOXact_Files();
}
extern "C" {
    pub fn AtEOSubXact_Files(isCommit: bool_, mySubid: SubTransactionId,
                             parentSubid: SubTransactionId);
}
extern "C" {
    pub fn RemovePgTempFiles();
}
extern "C" {
    pub fn pg_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_fsync_no_writethrough(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_fsync_writethrough(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_flush_data(fd: ::std::os::raw::c_int, offset: off_t,
                         amount: off_t);
}
extern "C" {
    pub fn fsync_fname(fname: *const ::std::os::raw::c_char, isdir: bool_);
}
extern "C" {
    pub fn durable_rename(oldfile: *const ::std::os::raw::c_char,
                          newfile: *const ::std::os::raw::c_char,
                          loglevel: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn durable_unlink(fname: *const ::std::os::raw::c_char,
                          loglevel: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn durable_link_or_rename(oldfile: *const ::std::os::raw::c_char,
                                  newfile: *const ::std::os::raw::c_char,
                                  loglevel: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SyncDataDirectory();
}
extern "C" {
    #[link_name = "sync_method"]
    pub static mut sync_method: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ThisTimeLineID"]
    pub static mut ThisTimeLineID: TimeLineID;
}
extern "C" {
    #[link_name = "InRecovery"]
    pub static mut InRecovery: bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HotStandbyState {
    STANDBY_DISABLED = 0,
    STANDBY_INITIALIZED = 1,
    STANDBY_SNAPSHOT_PENDING = 2,
    STANDBY_SNAPSHOT_READY = 3,
}
extern "C" {
    #[link_name = "standbyState"]
    pub static mut standbyState: HotStandbyState;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RecoveryTargetType {
    RECOVERY_TARGET_UNSET = 0,
    RECOVERY_TARGET_XID = 1,
    RECOVERY_TARGET_TIME = 2,
    RECOVERY_TARGET_NAME = 3,
    RECOVERY_TARGET_LSN = 4,
    RECOVERY_TARGET_IMMEDIATE = 5,
}
extern "C" {
    #[link_name = "ProcLastRecPtr"]
    pub static mut ProcLastRecPtr: XLogRecPtr;
}
extern "C" {
    #[link_name = "XactLastRecEnd"]
    pub static mut XactLastRecEnd: XLogRecPtr;
}
extern "C" {
    #[link_name = "XactLastCommitEnd"]
    pub static mut XactLastCommitEnd: XLogRecPtr;
}
extern "C" {
    #[link_name = "reachedConsistency"]
    pub static mut reachedConsistency: bool_;
}
extern "C" {
    #[link_name = "min_wal_size_mb"]
    pub static mut min_wal_size_mb: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_wal_size_mb"]
    pub static mut max_wal_size_mb: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "wal_keep_segments"]
    pub static mut wal_keep_segments: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "XLOGbuffers"]
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "XLogArchiveTimeout"]
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "wal_retrieve_retry_interval"]
    pub static mut wal_retrieve_retry_interval: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "XLogArchiveCommand"]
    pub static mut XLogArchiveCommand: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "EnableHotStandby"]
    pub static mut EnableHotStandby: bool_;
}
extern "C" {
    #[link_name = "fullPageWrites"]
    pub static mut fullPageWrites: bool_;
}
extern "C" {
    #[link_name = "wal_log_hints"]
    pub static mut wal_log_hints: bool_;
}
extern "C" {
    #[link_name = "wal_compression"]
    pub static mut wal_compression: bool_;
}
extern "C" {
    #[link_name = "wal_consistency_checking"]
    pub static mut wal_consistency_checking: *mut bool_;
}
extern "C" {
    #[link_name = "wal_consistency_checking_string"]
    pub static mut wal_consistency_checking_string:
               *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "log_checkpoints"]
    pub static mut log_checkpoints: bool_;
}
extern "C" {
    #[link_name = "CheckPointSegments"]
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ArchiveMode {
    ARCHIVE_MODE_OFF = 0,
    ARCHIVE_MODE_ON = 1,
    ARCHIVE_MODE_ALWAYS = 2,
}
extern "C" {
    #[link_name = "XLogArchiveMode"]
    pub static mut XLogArchiveMode: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WalLevel {
    WAL_LEVEL_MINIMAL = 0,
    WAL_LEVEL_REPLICA = 1,
    WAL_LEVEL_LOGICAL = 2,
}
extern "C" {
    #[link_name = "wal_level"]
    pub static mut wal_level: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
#[test]
fn bindgen_test_layout_CheckpointStatsData() {
    assert_eq!(::std::mem::size_of::<CheckpointStatsData>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( CheckpointStatsData ) ));
    assert_eq! (::std::mem::align_of::<CheckpointStatsData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CheckpointStatsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_start_t as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_start_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_write_t as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_write_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_sync_t as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_sync_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_sync_end_t
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_sync_end_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_end_t as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_end_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) .
                ckpt_bufs_written as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_bufs_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_segs_added
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_segs_added ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) .
                ckpt_segs_removed as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_segs_removed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) .
                ckpt_segs_recycled as * const _ as usize } , 52usize , concat
                ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_segs_recycled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) . ckpt_sync_rels
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_sync_rels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) .
                ckpt_longest_sync as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_longest_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CheckpointStatsData ) ) .
                ckpt_agg_sync_time as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! ( CheckpointStatsData ) ,
                "::" , stringify ! ( ckpt_agg_sync_time ) ));
}
impl Clone for CheckpointStatsData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "CheckpointStats"]
    pub static mut CheckpointStats: CheckpointStatsData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecData {
    _unused: [u8; 0],
}
extern "C" {
    pub fn XLogInsertRecord(rdata: *mut XLogRecData, fpw_lsn: XLogRecPtr,
                            flags: uint8) -> XLogRecPtr;
}
extern "C" {
    pub fn XLogFlush(RecPtr: XLogRecPtr);
}
extern "C" {
    pub fn XLogBackgroundFlush() -> bool_;
}
extern "C" {
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> bool_;
}
extern "C" {
    pub fn XLogFileInit(segno: XLogSegNo, use_existent: *mut bool_,
                        use_lock: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
}
extern "C" {
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
}
extern "C" {
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr);
}
extern "C" {
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
}
extern "C" {
    pub fn xlog_redo(record: *mut XLogReaderState);
}
extern "C" {
    pub fn xlog_desc(buf: StringInfo, record: *mut XLogReaderState);
}
extern "C" {
    pub fn xlog_identify(info: uint8) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn issue_xlog_fsync(fd: ::std::os::raw::c_int, segno: XLogSegNo);
}
extern "C" {
    pub fn RecoveryInProgress() -> bool_;
}
extern "C" {
    pub fn HotStandbyActive() -> bool_;
}
extern "C" {
    pub fn HotStandbyActiveInReplay() -> bool_;
}
extern "C" {
    pub fn XLogInsertAllowed() -> bool_;
}
extern "C" {
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz,
                              fromStream: *mut bool_);
}
extern "C" {
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
}
extern "C" {
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn RecoveryIsPaused() -> bool_;
}
extern "C" {
    pub fn SetRecoveryPause(recoveryPause: bool_);
}
extern "C" {
    pub fn GetLatestXTime() -> TimestampTz;
}
extern "C" {
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
}
extern "C" {
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn UpdateControlFile();
}
extern "C" {
    pub fn GetSystemIdentifier() -> uint64;
}
extern "C" {
    pub fn GetMockAuthenticationNonce() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn DataChecksumsEnabled() -> bool_;
}
extern "C" {
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
}
extern "C" {
    pub fn XLOGShmemSize() -> Size;
}
extern "C" {
    pub fn XLOGShmemInit();
}
extern "C" {
    pub fn BootStrapXLOG();
}
extern "C" {
    pub fn StartupXLOG();
}
extern "C" {
    pub fn ShutdownXLOG(code: ::std::os::raw::c_int, arg: Datum);
}
extern "C" {
    pub fn InitXLOGAccess();
}
extern "C" {
    pub fn CreateCheckPoint(flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CreateRestartPoint(flags: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn XLogPutNextOid(nextOid: Oid);
}
extern "C" {
    pub fn XLogRestorePoint(rpName: *const ::std::os::raw::c_char)
     -> XLogRecPtr;
}
extern "C" {
    pub fn UpdateFullPageWrites();
}
extern "C" {
    pub fn GetFullPageWriteInfo(RedoRecPtr_p: *mut XLogRecPtr,
                                doPageWrites_p: *mut bool_);
}
extern "C" {
    pub fn GetRedoRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetInsertRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetFlushRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetLastImportantRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetNextXidAndEpoch(xid: *mut TransactionId, epoch: *mut uint32);
}
extern "C" {
    pub fn RemovePromoteSignalFiles();
}
extern "C" {
    pub fn CheckPromoteSignal() -> bool_;
}
extern "C" {
    pub fn WakeupRecovery();
}
extern "C" {
    pub fn SetWalWriterSleeping(sleeping: bool_);
}
extern "C" {
    pub fn XLogRequestWalReceiverReply();
}
extern "C" {
    pub fn assign_max_wal_size(newval: ::std::os::raw::c_int,
                               extra: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn assign_checkpoint_completion_target(newval: f64,
                                               extra:
                                                   *mut ::std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SessionBackupState {
    SESSION_BACKUP_NONE = 0,
    SESSION_BACKUP_EXCLUSIVE = 1,
    SESSION_BACKUP_NON_EXCLUSIVE = 2,
}
extern "C" {
    pub fn do_pg_start_backup(backupidstr: *const ::std::os::raw::c_char,
                              fast: bool_, starttli_p: *mut TimeLineID,
                              labelfile: StringInfo, tblspcdir: *mut DIR,
                              tablespaces: *mut *mut List,
                              tblspcmapfile: StringInfo, infotbssize: bool_,
                              needtblspcmapfile: bool_) -> XLogRecPtr;
}
extern "C" {
    pub fn do_pg_stop_backup(labelfile: *mut ::std::os::raw::c_char,
                             waitforarchive: bool_,
                             stoptli_p: *mut TimeLineID) -> XLogRecPtr;
}
extern "C" {
    pub fn do_pg_abort_backup();
}
extern "C" {
    pub fn get_backup_status() -> SessionBackupState;
}
#[repr(C)]
#[derive(Copy)]
pub struct FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: bool_,
    pub relisshared: bool_,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: bool_,
    pub relhaspkey: bool_,
    pub relhasrules: bool_,
    pub relhastriggers: bool_,
    pub relhassubclass: bool_,
    pub relrowsecurity: bool_,
    pub relforcerowsecurity: bool_,
    pub relispopulated: bool_,
    pub relreplident: ::std::os::raw::c_char,
    pub relispartition: bool_,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
#[test]
fn bindgen_test_layout_FormData_pg_class() {
    assert_eq!(::std::mem::size_of::<FormData_pg_class>() , 136usize , concat
               ! ( "Size of: " , stringify ! ( FormData_pg_class ) ));
    assert_eq! (::std::mem::align_of::<FormData_pg_class>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( FormData_pg_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relname as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relnamespace as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relnamespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . reltype as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( reltype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . reloftype as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( reloftype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relowner as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relowner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relam as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relfilenode as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relfilenode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . reltablespace as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( reltablespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relpages as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relpages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . reltuples as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( reltuples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relallvisible as
                * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relallvisible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . reltoastrelid as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( reltoastrelid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relhasindex as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relhasindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relisshared as *
                const _ as usize } , 109usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relisshared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relpersistence as
                * const _ as usize } , 110usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relpersistence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relkind as *
                const _ as usize } , 111usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relkind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relnatts as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relnatts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relchecks as *
                const _ as usize } , 114usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relchecks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relhasoids as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relhasoids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relhaspkey as *
                const _ as usize } , 117usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relhaspkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relhasrules as *
                const _ as usize } , 118usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relhasrules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relhastriggers as
                * const _ as usize } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relhastriggers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relhassubclass as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relhassubclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relrowsecurity as
                * const _ as usize } , 121usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relrowsecurity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) .
                relforcerowsecurity as * const _ as usize } , 122usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relforcerowsecurity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relispopulated as
                * const _ as usize } , 123usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relispopulated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relreplident as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relreplident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relispartition as
                * const _ as usize } , 125usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relispartition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relfrozenxid as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relfrozenxid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_class ) ) . relminmxid as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_class ) ,
                "::" , stringify ! ( relminmxid ) ));
}
impl Clone for FormData_pg_class {
    fn clone(&self) -> Self { *self }
}
pub type Form_pg_class = *mut FormData_pg_class;
extern "C" {
    #[link_name = "no_such_variable"]
    pub static mut no_such_variable: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: bool_,
    pub indisprimary: bool_,
    pub indisexclusion: bool_,
    pub indimmediate: bool_,
    pub indisclustered: bool_,
    pub indisvalid: bool_,
    pub indcheckxmin: bool_,
    pub indisready: bool_,
    pub indislive: bool_,
    pub indisreplident: bool_,
    pub indkey: int2vector,
}
#[test]
fn bindgen_test_layout_FormData_pg_index() {
    assert_eq!(::std::mem::size_of::<FormData_pg_index>() , 44usize , concat !
               ( "Size of: " , stringify ! ( FormData_pg_index ) ));
    assert_eq! (::std::mem::align_of::<FormData_pg_index>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( FormData_pg_index ) ));
}
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ParseExprKind {
    EXPR_KIND_NONE = 0,
    EXPR_KIND_OTHER = 1,
    EXPR_KIND_JOIN_ON = 2,
    EXPR_KIND_JOIN_USING = 3,
    EXPR_KIND_FROM_SUBSELECT = 4,
    EXPR_KIND_FROM_FUNCTION = 5,
    EXPR_KIND_WHERE = 6,
    EXPR_KIND_HAVING = 7,
    EXPR_KIND_FILTER = 8,
    EXPR_KIND_WINDOW_PARTITION = 9,
    EXPR_KIND_WINDOW_ORDER = 10,
    EXPR_KIND_WINDOW_FRAME_RANGE = 11,
    EXPR_KIND_WINDOW_FRAME_ROWS = 12,
    EXPR_KIND_SELECT_TARGET = 13,
    EXPR_KIND_INSERT_TARGET = 14,
    EXPR_KIND_UPDATE_SOURCE = 15,
    EXPR_KIND_UPDATE_TARGET = 16,
    EXPR_KIND_GROUP_BY = 17,
    EXPR_KIND_ORDER_BY = 18,
    EXPR_KIND_DISTINCT_ON = 19,
    EXPR_KIND_LIMIT = 20,
    EXPR_KIND_OFFSET = 21,
    EXPR_KIND_RETURNING = 22,
    EXPR_KIND_VALUES = 23,
    EXPR_KIND_VALUES_SINGLE = 24,
    EXPR_KIND_CHECK_CONSTRAINT = 25,
    EXPR_KIND_DOMAIN_CHECK = 26,
    EXPR_KIND_COLUMN_DEFAULT = 27,
    EXPR_KIND_FUNCTION_DEFAULT = 28,
    EXPR_KIND_INDEX_EXPRESSION = 29,
    EXPR_KIND_INDEX_PREDICATE = 30,
    EXPR_KIND_ALTER_COL_TRANSFORM = 31,
    EXPR_KIND_EXECUTE_PARAMETER = 32,
    EXPR_KIND_TRIGGER_WHEN = 33,
    EXPR_KIND_POLICY = 34,
    EXPR_KIND_PARTITION_EXPRESSION = 35,
}
pub type PreParseColumnRefHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               cref: *mut ColumnRef)
                              -> *mut Node>;
pub type PostParseColumnRefHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               cref: *mut ColumnRef,
                                               var: *mut Node) -> *mut Node>;
pub type ParseParamRefHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               pref: *mut ParamRef)
                              -> *mut Node>;
pub type CoerceParamHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               param: *mut Param,
                                               targetTypeId: Oid,
                                               targetTypeMod: int32,
                                               location:
                                                   ::std::os::raw::c_int)
                              -> *mut Node>;
#[repr(C)]
#[derive(Copy)]
pub struct ParseNamespaceItem {
    pub p_rte: *mut RangeTblEntry,
    pub p_rel_visible: bool_,
    pub p_cols_visible: bool_,
    pub p_lateral_only: bool_,
    pub p_lateral_ok: bool_,
}
#[test]
fn bindgen_test_layout_ParseNamespaceItem() {
    assert_eq!(::std::mem::size_of::<ParseNamespaceItem>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ParseNamespaceItem ) ));
    assert_eq! (::std::mem::align_of::<ParseNamespaceItem>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ParseNamespaceItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseNamespaceItem ) ) . p_rte as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseNamespaceItem ) ,
                "::" , stringify ! ( p_rte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseNamespaceItem ) ) . p_rel_visible as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseNamespaceItem ) ,
                "::" , stringify ! ( p_rel_visible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseNamespaceItem ) ) . p_cols_visible
                as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseNamespaceItem ) ,
                "::" , stringify ! ( p_cols_visible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseNamespaceItem ) ) . p_lateral_only
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseNamespaceItem ) ,
                "::" , stringify ! ( p_lateral_only ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseNamespaceItem ) ) . p_lateral_ok as
                * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseNamespaceItem ) ,
                "::" , stringify ! ( p_lateral_ok ) ));
}
impl Clone for ParseNamespaceItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ParseCallbackState {
    pub pstate: *mut ParseState,
    pub location: ::std::os::raw::c_int,
    pub errcallback: ErrorContextCallback,
}
#[test]
fn bindgen_test_layout_ParseCallbackState() {
    assert_eq!(::std::mem::size_of::<ParseCallbackState>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( ParseCallbackState ) ));
    assert_eq! (::std::mem::align_of::<ParseCallbackState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ParseCallbackState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseCallbackState ) ) . pstate as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseCallbackState ) ,
                "::" , stringify ! ( pstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseCallbackState ) ) . location as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseCallbackState ) ,
                "::" , stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ParseCallbackState ) ) . errcallback as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ParseCallbackState ) ,
                "::" , stringify ! ( errcallback ) ));
}
impl Clone for ParseCallbackState {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn make_parsestate(parentParseState: *mut ParseState)
     -> *mut ParseState;
}
extern "C" {
    pub fn free_parsestate(pstate: *mut ParseState);
}
extern "C" {
    pub fn parser_errposition(pstate: *mut ParseState,
                              location: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setup_parser_errposition_callback(pcbstate:
                                                 *mut ParseCallbackState,
                                             pstate: *mut ParseState,
                                             location: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cancel_parser_errposition_callback(pcbstate:
                                                  *mut ParseCallbackState);
}
extern "C" {
    pub fn make_var(pstate: *mut ParseState, rte: *mut RangeTblEntry,
                    attrno: ::std::os::raw::c_int,
                    location: ::std::os::raw::c_int) -> *mut Var;
}
extern "C" {
    pub fn transformArrayType(arrayType: *mut Oid, arrayTypmod: *mut int32)
     -> Oid;
}
extern "C" {
    pub fn transformArraySubscripts(pstate: *mut ParseState,
                                    arrayBase: *mut Node, arrayType: Oid,
                                    elementType: Oid, arrayTypMod: int32,
                                    indirection: *mut List,
                                    assignFrom: *mut Node) -> *mut ArrayRef;
}
extern "C" {
    pub fn make_const(pstate: *mut ParseState, value: *mut Value,
                      location: ::std::os::raw::c_int) -> *mut Const;
}
pub type EOM_get_flat_size_method =
    ::std::option::Option<unsafe extern "C" fn(eohptr:
                                                   *mut ExpandedObjectHeader)
                              -> Size>;
pub type EOM_flatten_into_method =
    ::std::option::Option<unsafe extern "C" fn(eohptr:
                                                   *mut ExpandedObjectHeader,
                                               result:
                                                   *mut ::std::os::raw::c_void,
                                               allocated_size: Size)>;
#[repr(C)]
#[derive(Copy)]
pub struct ExpandedObjectMethods {
    pub get_flat_size: EOM_get_flat_size_method,
    pub flatten_into: EOM_flatten_into_method,
}
#[test]
fn bindgen_test_layout_ExpandedObjectMethods() {
    assert_eq!(::std::mem::size_of::<ExpandedObjectMethods>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ExpandedObjectMethods )
               ));
    assert_eq! (::std::mem::align_of::<ExpandedObjectMethods>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ExpandedObjectMethods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectMethods ) ) . get_flat_size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectMethods )
                , "::" , stringify ! ( get_flat_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedObjectMethods ) ) . flatten_into
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedObjectMethods )
                , "::" , stringify ! ( flatten_into ) ));
}
impl Clone for ExpandedObjectMethods {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn DatumGetEOHP(d: Datum) -> *mut ExpandedObjectHeader;
}
extern "C" {
    pub fn EOH_init_header(eohptr: *mut ExpandedObjectHeader,
                           methods: *const ExpandedObjectMethods,
                           obj_context: MemoryContext);
}
extern "C" {
    pub fn EOH_get_flat_size(eohptr: *mut ExpandedObjectHeader) -> Size;
}
extern "C" {
    pub fn EOH_flatten_into(eohptr: *mut ExpandedObjectHeader,
                            result: *mut ::std::os::raw::c_void,
                            allocated_size: Size);
}
extern "C" {
    pub fn MakeExpandedObjectReadOnlyInternal(d: Datum) -> Datum;
}
extern "C" {
    pub fn TransferExpandedObject(d: Datum, new_parent: MemoryContext)
     -> Datum;
}
extern "C" {
    pub fn DeleteExpandedObject(d: Datum);
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayType {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
}
#[test]
fn bindgen_test_layout_ArrayType() {
    assert_eq!(::std::mem::size_of::<ArrayType>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ArrayType ) ));
    assert_eq! (::std::mem::align_of::<ArrayType>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ArrayType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayType ) ) . vl_len_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayType ) , "::" ,
                stringify ! ( vl_len_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayType ) ) . ndim as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayType ) , "::" ,
                stringify ! ( ndim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayType ) ) . dataoffset as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayType ) , "::" ,
                stringify ! ( dataoffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayType ) ) . elemtype as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayType ) , "::" ,
                stringify ! ( elemtype ) ));
}
impl Clone for ArrayType {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExpandedArrayHeader {
    pub hdr: ExpandedObjectHeader,
    pub ea_magic: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: *mut ::std::os::raw::c_int,
    pub lbound: *mut ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool_,
    pub typalign: ::std::os::raw::c_char,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool_,
    pub dvalueslen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub flat_size: Size,
    pub fvalue: *mut ArrayType,
    pub fstartptr: *mut ::std::os::raw::c_char,
    pub fendptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ExpandedArrayHeader() {
    assert_eq!(::std::mem::size_of::<ExpandedArrayHeader>() , 136usize ,
               concat ! ( "Size of: " , stringify ! ( ExpandedArrayHeader )
               ));
    assert_eq! (::std::mem::align_of::<ExpandedArrayHeader>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ExpandedArrayHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . hdr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . ea_magic as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( ea_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . ndims as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( ndims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . dims as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( dims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . lbound as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( lbound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . element_type as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( element_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . typlen as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( typlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . typbyval as *
                const _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( typbyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . typalign as *
                const _ as usize } , 79usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( typalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . dvalues as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( dvalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . dnulls as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( dnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . dvalueslen as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( dvalueslen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . nelems as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( nelems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . flat_size as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( flat_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . fvalue as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( fvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . fstartptr as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( fstartptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ExpandedArrayHeader ) ) . fendptr as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ExpandedArrayHeader ) ,
                "::" , stringify ! ( fendptr ) ));
}
impl Clone for ExpandedArrayHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union AnyArrayType {
    pub flt: ArrayType,
    pub xpn: ExpandedArrayHeader,
    _bindgen_union_align: [u64; 17usize],
}
#[test]
fn bindgen_test_layout_AnyArrayType() {
    assert_eq!(::std::mem::size_of::<AnyArrayType>() , 136usize , concat ! (
               "Size of: " , stringify ! ( AnyArrayType ) ));
    assert_eq! (::std::mem::align_of::<AnyArrayType>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AnyArrayType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AnyArrayType ) ) . flt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AnyArrayType ) , "::" ,
                stringify ! ( flt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AnyArrayType ) ) . xpn as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AnyArrayType ) , "::" ,
                stringify ! ( xpn ) ));
}
impl Clone for AnyArrayType {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayBuildState {
    pub mcontext: MemoryContext,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool_,
    pub alen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool_,
    pub typalign: ::std::os::raw::c_char,
    pub private_cxt: bool_,
}
#[test]
fn bindgen_test_layout_ArrayBuildState() {
    assert_eq!(::std::mem::size_of::<ArrayBuildState>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ArrayBuildState ) ));
    assert_eq! (::std::mem::align_of::<ArrayBuildState>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ArrayBuildState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . mcontext as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . dvalues as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( dvalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . dnulls as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( dnulls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . alen as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( alen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . nelems as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( nelems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . element_type as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( element_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . typlen as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( typlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . typbyval as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( typbyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . typalign as * const
                _ as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( typalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildState ) ) . private_cxt as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildState ) ,
                "::" , stringify ! ( private_cxt ) ));
}
impl Clone for ArrayBuildState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayBuildStateArr {
    pub mcontext: MemoryContext,
    pub data: *mut ::std::os::raw::c_char,
    pub nullbitmap: *mut bits8,
    pub abytes: ::std::os::raw::c_int,
    pub nbytes: ::std::os::raw::c_int,
    pub aitems: ::std::os::raw::c_int,
    pub nitems: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: [::std::os::raw::c_int; 6usize],
    pub lbs: [::std::os::raw::c_int; 6usize],
    pub array_type: Oid,
    pub element_type: Oid,
    pub private_cxt: bool_,
}
#[test]
fn bindgen_test_layout_ArrayBuildStateArr() {
    assert_eq!(::std::mem::size_of::<ArrayBuildStateArr>() , 104usize , concat
               ! ( "Size of: " , stringify ! ( ArrayBuildStateArr ) ));
    assert_eq! (::std::mem::align_of::<ArrayBuildStateArr>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ArrayBuildStateArr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . mcontext as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . data as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . nullbitmap as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( nullbitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . abytes as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( abytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . nbytes as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( nbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . aitems as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( aitems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . nitems as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( nitems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . ndims as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( ndims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . dims as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( dims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . lbs as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( lbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . array_type as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( array_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . element_type as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( element_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateArr ) ) . private_cxt as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateArr ) ,
                "::" , stringify ! ( private_cxt ) ));
}
impl Clone for ArrayBuildStateArr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayBuildStateAny {
    pub scalarstate: *mut ArrayBuildState,
    pub arraystate: *mut ArrayBuildStateArr,
}
#[test]
fn bindgen_test_layout_ArrayBuildStateAny() {
    assert_eq!(::std::mem::size_of::<ArrayBuildStateAny>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ArrayBuildStateAny ) ));
    assert_eq! (::std::mem::align_of::<ArrayBuildStateAny>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ArrayBuildStateAny ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateAny ) ) . scalarstate as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateAny ) ,
                "::" , stringify ! ( scalarstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayBuildStateAny ) ) . arraystate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayBuildStateAny ) ,
                "::" , stringify ! ( arraystate ) ));
}
impl Clone for ArrayBuildStateAny {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayMetaState {
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool_,
    pub typalign: ::std::os::raw::c_char,
    pub typdelim: ::std::os::raw::c_char,
    pub typioparam: Oid,
    pub typiofunc: Oid,
    pub proc_: FmgrInfo,
}
#[test]
fn bindgen_test_layout_ArrayMetaState() {
    assert_eq!(::std::mem::size_of::<ArrayMetaState>() , 72usize , concat ! (
               "Size of: " , stringify ! ( ArrayMetaState ) ));
    assert_eq! (::std::mem::align_of::<ArrayMetaState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ArrayMetaState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . element_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( element_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . typlen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( typlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . typbyval as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( typbyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . typalign as * const
                _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( typalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . typdelim as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( typdelim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . typioparam as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( typioparam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . typiofunc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( typiofunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMetaState ) ) . proc_ as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMetaState ) , "::"
                , stringify ! ( proc_ ) ));
}
impl Clone for ArrayMetaState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ArrayMapState {
    pub inp_extra: ArrayMetaState,
    pub ret_extra: ArrayMetaState,
}
#[test]
fn bindgen_test_layout_ArrayMapState() {
    assert_eq!(::std::mem::size_of::<ArrayMapState>() , 144usize , concat ! (
               "Size of: " , stringify ! ( ArrayMapState ) ));
    assert_eq! (::std::mem::align_of::<ArrayMapState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ArrayMapState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMapState ) ) . inp_extra as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMapState ) , "::"
                , stringify ! ( inp_extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ArrayMapState ) ) . ret_extra as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ArrayMapState ) , "::"
                , stringify ! ( ret_extra ) ));
}
impl Clone for ArrayMapState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayIteratorData {
    _unused: [u8; 0],
}
pub type ArrayIterator = *mut ArrayIteratorData;
extern "C" {
    #[link_name = "Array_nulls"]
    pub static mut Array_nulls: bool_;
}
extern "C" {
    pub fn CopyArrayEls(array: *mut ArrayType, values: *mut Datum,
                        nulls: *mut bool_, nitems: ::std::os::raw::c_int,
                        typlen: ::std::os::raw::c_int, typbyval: bool_,
                        typalign: ::std::os::raw::c_char, freedata: bool_);
}
extern "C" {
    pub fn array_get_element(arraydatum: Datum,
                             nSubscripts: ::std::os::raw::c_int,
                             indx: *mut ::std::os::raw::c_int,
                             arraytyplen: ::std::os::raw::c_int,
                             elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                             elmalign: ::std::os::raw::c_char,
                             isNull: *mut bool_) -> Datum;
}
extern "C" {
    pub fn array_set_element(arraydatum: Datum,
                             nSubscripts: ::std::os::raw::c_int,
                             indx: *mut ::std::os::raw::c_int,
                             dataValue: Datum, isNull: bool_,
                             arraytyplen: ::std::os::raw::c_int,
                             elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                             elmalign: ::std::os::raw::c_char) -> Datum;
}
extern "C" {
    pub fn array_get_slice(arraydatum: Datum,
                           nSubscripts: ::std::os::raw::c_int,
                           upperIndx: *mut ::std::os::raw::c_int,
                           lowerIndx: *mut ::std::os::raw::c_int,
                           upperProvided: *mut bool_,
                           lowerProvided: *mut bool_,
                           arraytyplen: ::std::os::raw::c_int,
                           elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                           elmalign: ::std::os::raw::c_char) -> Datum;
}
extern "C" {
    pub fn array_set_slice(arraydatum: Datum,
                           nSubscripts: ::std::os::raw::c_int,
                           upperIndx: *mut ::std::os::raw::c_int,
                           lowerIndx: *mut ::std::os::raw::c_int,
                           upperProvided: *mut bool_,
                           lowerProvided: *mut bool_, srcArrayDatum: Datum,
                           isNull: bool_, arraytyplen: ::std::os::raw::c_int,
                           elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                           elmalign: ::std::os::raw::c_char) -> Datum;
}
extern "C" {
    pub fn array_ref(array: *mut ArrayType,
                     nSubscripts: ::std::os::raw::c_int,
                     indx: *mut ::std::os::raw::c_int,
                     arraytyplen: ::std::os::raw::c_int,
                     elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                     elmalign: ::std::os::raw::c_char, isNull: *mut bool_)
     -> Datum;
}
extern "C" {
    pub fn array_set(array: *mut ArrayType,
                     nSubscripts: ::std::os::raw::c_int,
                     indx: *mut ::std::os::raw::c_int, dataValue: Datum,
                     isNull: bool_, arraytyplen: ::std::os::raw::c_int,
                     elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                     elmalign: ::std::os::raw::c_char) -> *mut ArrayType;
}
extern "C" {
    pub fn array_map(fcinfo: FunctionCallInfo, retType: Oid,
                     amstate: *mut ArrayMapState) -> Datum;
}
extern "C" {
    pub fn array_bitmap_copy(destbitmap: *mut bits8,
                             destoffset: ::std::os::raw::c_int,
                             srcbitmap: *const bits8,
                             srcoffset: ::std::os::raw::c_int,
                             nitems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn construct_array(elems: *mut Datum, nelems: ::std::os::raw::c_int,
                           elmtype: Oid, elmlen: ::std::os::raw::c_int,
                           elmbyval: bool_, elmalign: ::std::os::raw::c_char)
     -> *mut ArrayType;
}
extern "C" {
    pub fn construct_md_array(elems: *mut Datum, nulls: *mut bool_,
                              ndims: ::std::os::raw::c_int,
                              dims: *mut ::std::os::raw::c_int,
                              lbs: *mut ::std::os::raw::c_int, elmtype: Oid,
                              elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                              elmalign: ::std::os::raw::c_char)
     -> *mut ArrayType;
}
extern "C" {
    pub fn construct_empty_array(elmtype: Oid) -> *mut ArrayType;
}
extern "C" {
    pub fn construct_empty_expanded_array(element_type: Oid,
                                          parentcontext: MemoryContext,
                                          metacache: *mut ArrayMetaState)
     -> *mut ExpandedArrayHeader;
}
extern "C" {
    pub fn deconstruct_array(array: *mut ArrayType, elmtype: Oid,
                             elmlen: ::std::os::raw::c_int, elmbyval: bool_,
                             elmalign: ::std::os::raw::c_char,
                             elemsp: *mut *mut Datum, nullsp: *mut *mut bool_,
                             nelemsp: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn array_contains_nulls(array: *mut ArrayType) -> bool_;
}
extern "C" {
    pub fn initArrayResult(element_type: Oid, rcontext: MemoryContext,
                           subcontext: bool_) -> *mut ArrayBuildState;
}
extern "C" {
    pub fn accumArrayResult(astate: *mut ArrayBuildState, dvalue: Datum,
                            disnull: bool_, element_type: Oid,
                            rcontext: MemoryContext) -> *mut ArrayBuildState;
}
extern "C" {
    pub fn makeArrayResult(astate: *mut ArrayBuildState,
                           rcontext: MemoryContext) -> Datum;
}
extern "C" {
    pub fn makeMdArrayResult(astate: *mut ArrayBuildState,
                             ndims: ::std::os::raw::c_int,
                             dims: *mut ::std::os::raw::c_int,
                             lbs: *mut ::std::os::raw::c_int,
                             rcontext: MemoryContext, release: bool_)
     -> Datum;
}
extern "C" {
    pub fn initArrayResultArr(array_type: Oid, element_type: Oid,
                              rcontext: MemoryContext, subcontext: bool_)
     -> *mut ArrayBuildStateArr;
}
extern "C" {
    pub fn accumArrayResultArr(astate: *mut ArrayBuildStateArr, dvalue: Datum,
                               disnull: bool_, array_type: Oid,
                               rcontext: MemoryContext)
     -> *mut ArrayBuildStateArr;
}
extern "C" {
    pub fn makeArrayResultArr(astate: *mut ArrayBuildStateArr,
                              rcontext: MemoryContext, release: bool_)
     -> Datum;
}
extern "C" {
    pub fn initArrayResultAny(input_type: Oid, rcontext: MemoryContext,
                              subcontext: bool_) -> *mut ArrayBuildStateAny;
}
extern "C" {
    pub fn accumArrayResultAny(astate: *mut ArrayBuildStateAny, dvalue: Datum,
                               disnull: bool_, input_type: Oid,
                               rcontext: MemoryContext)
     -> *mut ArrayBuildStateAny;
}
extern "C" {
    pub fn makeArrayResultAny(astate: *mut ArrayBuildStateAny,
                              rcontext: MemoryContext, release: bool_)
     -> Datum;
}
extern "C" {
    pub fn array_create_iterator(arr: *mut ArrayType,
                                 slice_ndim: ::std::os::raw::c_int,
                                 mstate: *mut ArrayMetaState)
     -> ArrayIterator;
}
extern "C" {
    pub fn array_iterate(iterator: ArrayIterator, value: *mut Datum,
                         isnull: *mut bool_) -> bool_;
}
extern "C" {
    pub fn array_free_iterator(iterator: ArrayIterator);
}
extern "C" {
    pub fn ArrayGetOffset(n: ::std::os::raw::c_int,
                          dim: *const ::std::os::raw::c_int,
                          lb: *const ::std::os::raw::c_int,
                          indx: *const ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ArrayGetOffset0(n: ::std::os::raw::c_int,
                           tup: *const ::std::os::raw::c_int,
                           scale: *const ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ArrayGetNItems(ndim: ::std::os::raw::c_int,
                          dims: *const ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mda_get_range(n: ::std::os::raw::c_int,
                         span: *mut ::std::os::raw::c_int,
                         st: *const ::std::os::raw::c_int,
                         endp: *const ::std::os::raw::c_int);
}
extern "C" {
    pub fn mda_get_prod(n: ::std::os::raw::c_int,
                        range: *const ::std::os::raw::c_int,
                        prod: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn mda_get_offset_values(n: ::std::os::raw::c_int,
                                 dist: *mut ::std::os::raw::c_int,
                                 prod: *const ::std::os::raw::c_int,
                                 span: *const ::std::os::raw::c_int);
}
extern "C" {
    pub fn mda_next_tuple(n: ::std::os::raw::c_int,
                          curr: *mut ::std::os::raw::c_int,
                          span: *const ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ArrayGetIntegerTypmods(arr: *mut ArrayType,
                                  n: *mut ::std::os::raw::c_int)
     -> *mut int32;
}
extern "C" {
    pub fn expand_array(arraydatum: Datum, parentcontext: MemoryContext,
                        metacache: *mut ArrayMetaState) -> Datum;
}
extern "C" {
    pub fn DatumGetExpandedArray(d: Datum) -> *mut ExpandedArrayHeader;
}
extern "C" {
    pub fn DatumGetExpandedArrayX(d: Datum, metacache: *mut ArrayMetaState)
     -> *mut ExpandedArrayHeader;
}
extern "C" {
    pub fn DatumGetAnyArray(d: Datum) -> *mut AnyArrayType;
}
extern "C" {
    pub fn deconstruct_expanded_array(eah: *mut ExpandedArrayHeader);
}
#[repr(C)]
#[derive(Copy)]
pub struct AclItem {
    pub ai_grantee: Oid,
    pub ai_grantor: Oid,
    pub ai_privs: AclMode,
}
#[test]
fn bindgen_test_layout_AclItem() {
    assert_eq!(::std::mem::size_of::<AclItem>() , 12usize , concat ! (
               "Size of: " , stringify ! ( AclItem ) ));
    assert_eq! (::std::mem::align_of::<AclItem>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( AclItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AclItem ) ) . ai_grantee as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AclItem ) , "::" ,
                stringify ! ( ai_grantee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AclItem ) ) . ai_grantor as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AclItem ) , "::" ,
                stringify ! ( ai_grantor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AclItem ) ) . ai_privs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AclItem ) , "::" ,
                stringify ! ( ai_privs ) ));
}
impl Clone for AclItem {
    fn clone(&self) -> Self { *self }
}
pub type Acl = ArrayType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AclMaskHow { ACLMASK_ALL = 0, ACLMASK_ANY = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AclResult {
    ACLCHECK_OK = 0,
    ACLCHECK_NO_PRIV = 1,
    ACLCHECK_NOT_OWNER = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AclObjectKind {
    ACL_KIND_COLUMN = 0,
    ACL_KIND_CLASS = 1,
    ACL_KIND_SEQUENCE = 2,
    ACL_KIND_DATABASE = 3,
    ACL_KIND_PROC = 4,
    ACL_KIND_OPER = 5,
    ACL_KIND_TYPE = 6,
    ACL_KIND_LANGUAGE = 7,
    ACL_KIND_LARGEOBJECT = 8,
    ACL_KIND_NAMESPACE = 9,
    ACL_KIND_OPCLASS = 10,
    ACL_KIND_OPFAMILY = 11,
    ACL_KIND_COLLATION = 12,
    ACL_KIND_CONVERSION = 13,
    ACL_KIND_STATISTICS = 14,
    ACL_KIND_TABLESPACE = 15,
    ACL_KIND_TSDICTIONARY = 16,
    ACL_KIND_TSCONFIGURATION = 17,
    ACL_KIND_FDW = 18,
    ACL_KIND_FOREIGN_SERVER = 19,
    ACL_KIND_EVENT_TRIGGER = 20,
    ACL_KIND_EXTENSION = 21,
    ACL_KIND_PUBLICATION = 22,
    ACL_KIND_SUBSCRIPTION = 23,
    MAX_ACL_KIND = 24,
}
extern "C" {
    pub fn acldefault(objtype: GrantObjectType, ownerId: Oid) -> *mut Acl;
}
extern "C" {
    pub fn get_user_default_acl(objtype: GrantObjectType, ownerId: Oid,
                                nsp_oid: Oid) -> *mut Acl;
}
extern "C" {
    pub fn aclupdate(old_acl: *const Acl, mod_aip: *const AclItem,
                     modechg: ::std::os::raw::c_int, ownerId: Oid,
                     behavior: DropBehavior) -> *mut Acl;
}
extern "C" {
    pub fn aclnewowner(old_acl: *const Acl, oldOwnerId: Oid, newOwnerId: Oid)
     -> *mut Acl;
}
extern "C" {
    pub fn make_empty_acl() -> *mut Acl;
}
extern "C" {
    pub fn aclcopy(orig_acl: *const Acl) -> *mut Acl;
}
extern "C" {
    pub fn aclconcat(left_acl: *const Acl, right_acl: *const Acl) -> *mut Acl;
}
extern "C" {
    pub fn aclmerge(left_acl: *const Acl, right_acl: *const Acl, ownerId: Oid)
     -> *mut Acl;
}
extern "C" {
    pub fn aclitemsort(acl: *mut Acl);
}
extern "C" {
    pub fn aclequal(left_acl: *const Acl, right_acl: *const Acl) -> bool_;
}
extern "C" {
    pub fn aclmask(acl: *const Acl, roleid: Oid, ownerId: Oid, mask: AclMode,
                   how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn aclmembers(acl: *const Acl, roleids: *mut *mut Oid)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn has_privs_of_role(member: Oid, role: Oid) -> bool_;
}
extern "C" {
    pub fn is_member_of_role(member: Oid, role: Oid) -> bool_;
}
extern "C" {
    pub fn is_member_of_role_nosuper(member: Oid, role: Oid) -> bool_;
}
extern "C" {
    pub fn is_admin_of_role(member: Oid, role: Oid) -> bool_;
}
extern "C" {
    pub fn check_is_member_of_role(member: Oid, role: Oid);
}
extern "C" {
    pub fn get_role_oid(rolename: *const ::std::os::raw::c_char,
                        missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn get_role_oid_or_public(rolename: *const ::std::os::raw::c_char)
     -> Oid;
}
extern "C" {
    pub fn get_rolespec_oid(role: *const RoleSpec, missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn check_rolespec_name(role: *const RoleSpec,
                               detail_msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_rolespec_tuple(role: *const RoleSpec) -> HeapTuple;
}
extern "C" {
    pub fn get_rolespec_name(role: *const RoleSpec)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn select_best_grantor(roleId: Oid, privileges: AclMode,
                               acl: *const Acl, ownerId: Oid,
                               grantorId: *mut Oid,
                               grantOptions: *mut AclMode);
}
extern "C" {
    pub fn initialize_acl();
}
extern "C" {
    pub fn ExecuteGrantStmt(stmt: *mut GrantStmt);
}
extern "C" {
    pub fn ExecAlterDefaultPrivilegesStmt(pstate: *mut ParseState,
                                          stmt:
                                              *mut AlterDefaultPrivilegesStmt);
}
extern "C" {
    pub fn RemoveRoleFromObjectACL(roleid: Oid, classid: Oid, objid: Oid);
}
extern "C" {
    pub fn RemoveDefaultACLById(defaclOid: Oid);
}
extern "C" {
    pub fn pg_attribute_aclmask(table_oid: Oid, attnum: AttrNumber,
                                roleid: Oid, mask: AclMode, how: AclMaskHow)
     -> AclMode;
}
extern "C" {
    pub fn pg_class_aclmask(table_oid: Oid, roleid: Oid, mask: AclMode,
                            how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_database_aclmask(db_oid: Oid, roleid: Oid, mask: AclMode,
                               how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_proc_aclmask(proc_oid: Oid, roleid: Oid, mask: AclMode,
                           how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_language_aclmask(lang_oid: Oid, roleid: Oid, mask: AclMode,
                               how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_largeobject_aclmask_snapshot(lobj_oid: Oid, roleid: Oid,
                                           mask: AclMode, how: AclMaskHow,
                                           snapshot: Snapshot) -> AclMode;
}
extern "C" {
    pub fn pg_namespace_aclmask(nsp_oid: Oid, roleid: Oid, mask: AclMode,
                                how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_tablespace_aclmask(spc_oid: Oid, roleid: Oid, mask: AclMode,
                                 how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_foreign_data_wrapper_aclmask(fdw_oid: Oid, roleid: Oid,
                                           mask: AclMode, how: AclMaskHow)
     -> AclMode;
}
extern "C" {
    pub fn pg_foreign_server_aclmask(srv_oid: Oid, roleid: Oid, mask: AclMode,
                                     how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_type_aclmask(type_oid: Oid, roleid: Oid, mask: AclMode,
                           how: AclMaskHow) -> AclMode;
}
extern "C" {
    pub fn pg_attribute_aclcheck(table_oid: Oid, attnum: AttrNumber,
                                 roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    pub fn pg_attribute_aclcheck_all(table_oid: Oid, roleid: Oid,
                                     mode: AclMode, how: AclMaskHow)
     -> AclResult;
}
extern "C" {
    pub fn pg_class_aclcheck(table_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn pg_database_aclcheck(db_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn pg_proc_aclcheck(proc_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn pg_language_aclcheck(lang_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn pg_largeobject_aclcheck_snapshot(lang_oid: Oid, roleid: Oid,
                                            mode: AclMode, snapshot: Snapshot)
     -> AclResult;
}
extern "C" {
    pub fn pg_namespace_aclcheck(nsp_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn pg_tablespace_aclcheck(spc_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn pg_foreign_data_wrapper_aclcheck(fdw_oid: Oid, roleid: Oid,
                                            mode: AclMode) -> AclResult;
}
extern "C" {
    pub fn pg_foreign_server_aclcheck(srv_oid: Oid, roleid: Oid,
                                      mode: AclMode) -> AclResult;
}
extern "C" {
    pub fn pg_type_aclcheck(type_oid: Oid, roleid: Oid, mode: AclMode)
     -> AclResult;
}
extern "C" {
    pub fn aclcheck_error(aclerr: AclResult, objectkind: AclObjectKind,
                          objectname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn aclcheck_error_col(aclerr: AclResult, objectkind: AclObjectKind,
                              objectname: *const ::std::os::raw::c_char,
                              colname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn aclcheck_error_type(aclerr: AclResult, typeOid: Oid);
}
extern "C" {
    pub fn recordExtObjInitPriv(objoid: Oid, classoid: Oid);
}
extern "C" {
    pub fn removeExtObjInitPriv(objoid: Oid, classoid: Oid);
}
extern "C" {
    pub fn pg_class_ownercheck(class_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_type_ownercheck(type_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_oper_ownercheck(oper_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_proc_ownercheck(proc_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_language_ownercheck(lan_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_largeobject_ownercheck(lobj_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_namespace_ownercheck(nsp_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_tablespace_ownercheck(spc_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_opclass_ownercheck(opc_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_opfamily_ownercheck(opf_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_database_ownercheck(db_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_collation_ownercheck(coll_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_conversion_ownercheck(conv_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_ts_dict_ownercheck(dict_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_ts_config_ownercheck(cfg_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_foreign_data_wrapper_ownercheck(srv_oid: Oid, roleid: Oid)
     -> bool_;
}
extern "C" {
    pub fn pg_foreign_server_ownercheck(srv_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_event_trigger_ownercheck(et_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_extension_ownercheck(ext_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_publication_ownercheck(pub_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_subscription_ownercheck(sub_oid: Oid, roleid: Oid) -> bool_;
}
extern "C" {
    pub fn pg_statistics_object_ownercheck(stat_oid: Oid, roleid: Oid)
     -> bool_;
}
extern "C" {
    pub fn has_createrole_privilege(roleid: Oid) -> bool_;
}
extern "C" {
    pub fn has_bypassrls_privilege(roleid: Oid) -> bool_;
}
#[repr(C)]
#[derive(Copy)]
pub struct ObjectAddress {
    pub classId: Oid,
    pub objectId: Oid,
    pub objectSubId: int32,
}
#[test]
fn bindgen_test_layout_ObjectAddress() {
    assert_eq!(::std::mem::size_of::<ObjectAddress>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ObjectAddress ) ));
    assert_eq! (::std::mem::align_of::<ObjectAddress>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ObjectAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectAddress ) ) . classId as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectAddress ) , "::"
                , stringify ! ( classId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectAddress ) ) . objectId as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectAddress ) , "::"
                , stringify ! ( objectId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ObjectAddress ) ) . objectSubId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ObjectAddress ) , "::"
                , stringify ! ( objectSubId ) ));
}
impl Clone for ObjectAddress {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "InvalidObjectAddress"]
    pub static InvalidObjectAddress: ObjectAddress;
}
extern "C" {
    pub fn get_object_address(objtype: ObjectType, object: *mut Node,
                              relp: *mut Relation, lockmode: LOCKMODE,
                              missing_ok: bool_) -> ObjectAddress;
}
extern "C" {
    pub fn get_object_address_rv(objtype: ObjectType, rel: *mut RangeVar,
                                 object: *mut List, relp: *mut Relation,
                                 lockmode: LOCKMODE, missing_ok: bool_)
     -> ObjectAddress;
}
extern "C" {
    pub fn check_object_ownership(roleid: Oid, objtype: ObjectType,
                                  address: ObjectAddress, object: *mut Node,
                                  relation: Relation);
}
extern "C" {
    pub fn get_object_namespace(address: *const ObjectAddress) -> Oid;
}
extern "C" {
    pub fn is_objectclass_supported(class_id: Oid) -> bool_;
}
extern "C" {
    pub fn get_object_oid_index(class_id: Oid) -> Oid;
}
extern "C" {
    pub fn get_object_catcache_oid(class_id: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_object_catcache_name(class_id: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_object_attnum_name(class_id: Oid) -> AttrNumber;
}
extern "C" {
    pub fn get_object_attnum_namespace(class_id: Oid) -> AttrNumber;
}
extern "C" {
    pub fn get_object_attnum_owner(class_id: Oid) -> AttrNumber;
}
extern "C" {
    pub fn get_object_attnum_acl(class_id: Oid) -> AttrNumber;
}
extern "C" {
    pub fn get_object_aclkind(class_id: Oid) -> AclObjectKind;
}
extern "C" {
    pub fn get_object_namensp_unique(class_id: Oid) -> bool_;
}
extern "C" {
    pub fn get_catalog_object_by_oid(catalog: Relation, objectId: Oid)
     -> HeapTuple;
}
extern "C" {
    pub fn getObjectDescription(object: *const ObjectAddress)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getObjectDescriptionOids(classid: Oid, objid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn read_objtype_from_string(objtype: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getObjectTypeDescription(object: *const ObjectAddress)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getObjectIdentity(address: *const ObjectAddress)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getObjectIdentityParts(address: *const ObjectAddress,
                                  objname: *mut *mut List,
                                  objargs: *mut *mut List)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlist_to_textarray(list: *mut List) -> *mut ArrayType;
}
#[repr(C)]
#[derive(Copy)]
pub struct FormData_pg_publication {
    pub pubname: NameData,
    pub pubowner: Oid,
    pub puballtables: bool_,
    pub pubinsert: bool_,
    pub pubupdate: bool_,
    pub pubdelete: bool_,
}
#[test]
fn bindgen_test_layout_FormData_pg_publication() {
    assert_eq!(::std::mem::size_of::<FormData_pg_publication>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( FormData_pg_publication ) ));
    assert_eq! (::std::mem::align_of::<FormData_pg_publication>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( FormData_pg_publication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_publication ) ) . pubname as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_publication
                ) , "::" , stringify ! ( pubname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_publication ) ) . pubowner as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_publication
                ) , "::" , stringify ! ( pubowner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_publication ) ) .
                puballtables as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_publication
                ) , "::" , stringify ! ( puballtables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_publication ) ) . pubinsert
                as * const _ as usize } , 69usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_publication
                ) , "::" , stringify ! ( pubinsert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_publication ) ) . pubupdate
                as * const _ as usize } , 70usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_publication
                ) , "::" , stringify ! ( pubupdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FormData_pg_publication ) ) . pubdelete
                as * const _ as usize } , 71usize , concat ! (
                "Alignment of field: " , stringify ! ( FormData_pg_publication
                ) , "::" , stringify ! ( pubdelete ) ));
}
impl Clone for FormData_pg_publication {
    fn clone(&self) -> Self { *self }
}
pub type Form_pg_publication = *mut FormData_pg_publication;
#[repr(C)]
#[derive(Copy)]
pub struct Publication {
    pub oid: Oid,
    pub name: *mut ::std::os::raw::c_char,
    pub alltables: bool_,
    pub pubactions: PublicationActions,
}
#[test]
fn bindgen_test_layout_Publication() {
    assert_eq!(::std::mem::size_of::<Publication>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Publication ) ));
    assert_eq! (::std::mem::align_of::<Publication>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Publication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Publication ) ) . oid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Publication ) , "::" ,
                stringify ! ( oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Publication ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Publication ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Publication ) ) . alltables as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Publication ) , "::" ,
                stringify ! ( alltables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Publication ) ) . pubactions as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( Publication ) , "::" ,
                stringify ! ( pubactions ) ));
}
impl Clone for Publication {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetPublication(pubid: Oid) -> *mut Publication;
}
extern "C" {
    pub fn GetPublicationByName(pubname: *const ::std::os::raw::c_char,
                                missing_ok: bool_) -> *mut Publication;
}
extern "C" {
    pub fn GetRelationPublications(relid: Oid) -> *mut List;
}
extern "C" {
    pub fn GetPublicationRelations(pubid: Oid) -> *mut List;
}
extern "C" {
    pub fn GetAllTablesPublications() -> *mut List;
}
extern "C" {
    pub fn GetAllTablesPublicationRelations() -> *mut List;
}
extern "C" {
    pub fn publication_add_relation(pubid: Oid, targetrel: Relation,
                                    if_not_exists: bool_) -> ObjectAddress;
}
extern "C" {
    pub fn get_publication_oid(pubname: *const ::std::os::raw::c_char,
                               missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn get_publication_name(pubid: Oid) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: bool_,
}
#[test]
fn bindgen_test_layout_RewriteRule() {
    assert_eq!(::std::mem::size_of::<RewriteRule>() , 32usize , concat ! (
               "Size of: " , stringify ! ( RewriteRule ) ));
    assert_eq! (::std::mem::align_of::<RewriteRule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RewriteRule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RewriteRule ) ) . ruleId as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RewriteRule ) , "::" ,
                stringify ! ( ruleId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RewriteRule ) ) . event as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RewriteRule ) , "::" ,
                stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RewriteRule ) ) . qual as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RewriteRule ) , "::" ,
                stringify ! ( qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RewriteRule ) ) . actions as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RewriteRule ) , "::" ,
                stringify ! ( actions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RewriteRule ) ) . enabled as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RewriteRule ) , "::" ,
                stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RewriteRule ) ) . isInstead as * const _
                as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( RewriteRule ) , "::" ,
                stringify ! ( isInstead ) ));
}
impl Clone for RewriteRule {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
#[test]
fn bindgen_test_layout_RuleLock() {
    assert_eq!(::std::mem::size_of::<RuleLock>() , 16usize , concat ! (
               "Size of: " , stringify ! ( RuleLock ) ));
    assert_eq! (::std::mem::align_of::<RuleLock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RuleLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleLock ) ) . numLocks as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleLock ) , "::" ,
                stringify ! ( numLocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RuleLock ) ) . rules as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RuleLock ) , "::" ,
                stringify ! ( rules ) ));
}
impl Clone for RuleLock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
#[test]
fn bindgen_test_layout_LockRelId() {
    assert_eq!(::std::mem::size_of::<LockRelId>() , 8usize , concat ! (
               "Size of: " , stringify ! ( LockRelId ) ));
    assert_eq! (::std::mem::align_of::<LockRelId>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( LockRelId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRelId ) ) . relId as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRelId ) , "::" ,
                stringify ! ( relId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockRelId ) ) . dbId as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( LockRelId ) , "::" ,
                stringify ! ( dbId ) ));
}
impl Clone for LockRelId {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
#[test]
fn bindgen_test_layout_LockInfoData() {
    assert_eq!(::std::mem::size_of::<LockInfoData>() , 8usize , concat ! (
               "Size of: " , stringify ! ( LockInfoData ) ));
    assert_eq! (::std::mem::align_of::<LockInfoData>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( LockInfoData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LockInfoData ) ) . lockRelId as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LockInfoData ) , "::" ,
                stringify ! ( lockRelId ) ));
}
impl Clone for LockInfoData {
    fn clone(&self) -> Self { *self }
}
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct PartitionKeyData {
    pub strategy: ::std::os::raw::c_char,
    pub partnatts: int16,
    pub partattrs: *mut AttrNumber,
    pub partexprs: *mut List,
    pub partopfamily: *mut Oid,
    pub partopcintype: *mut Oid,
    pub partsupfunc: *mut FmgrInfo,
    pub partcollation: *mut Oid,
    pub parttypid: *mut Oid,
    pub parttypmod: *mut int32,
    pub parttyplen: *mut int16,
    pub parttypbyval: *mut bool_,
    pub parttypalign: *mut ::std::os::raw::c_char,
    pub parttypcoll: *mut Oid,
}
#[test]
fn bindgen_test_layout_PartitionKeyData() {
    assert_eq!(::std::mem::size_of::<PartitionKeyData>() , 104usize , concat !
               ( "Size of: " , stringify ! ( PartitionKeyData ) ));
    assert_eq! (::std::mem::align_of::<PartitionKeyData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( PartitionKeyData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . strategy as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partnatts as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partnatts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partattrs as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partattrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partexprs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partexprs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partopfamily as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partopfamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partopcintype as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partopcintype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partsupfunc as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partsupfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . partcollation as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( partcollation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . parttypid as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( parttypid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . parttypmod as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( parttypmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . parttyplen as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( parttyplen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . parttypbyval as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( parttypbyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . parttypalign as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( parttypalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PartitionKeyData ) ) . parttypcoll as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( PartitionKeyData ) ,
                "::" , stringify ! ( parttypcoll ) ));
}
impl Clone for PartitionKeyData {
    fn clone(&self) -> Self { *self }
}
pub type PartitionKey = *mut PartitionKeyData;
#[repr(C)]
#[derive(Copy)]
pub struct ForeignKeyCacheInfo {
    pub type_: NodeTag,
    pub conrelid: Oid,
    pub confrelid: Oid,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
}
#[test]
fn bindgen_test_layout_ForeignKeyCacheInfo() {
    assert_eq!(::std::mem::size_of::<ForeignKeyCacheInfo>() , 272usize ,
               concat ! ( "Size of: " , stringify ! ( ForeignKeyCacheInfo )
               ));
    assert_eq! (::std::mem::align_of::<ForeignKeyCacheInfo>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ForeignKeyCacheInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . conrelid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( conrelid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . confrelid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( confrelid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . nkeys as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( nkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . conkey as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( conkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . confkey as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( confkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ForeignKeyCacheInfo ) ) . conpfeqop as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ForeignKeyCacheInfo ) ,
                "::" , stringify ! ( conpfeqop ) ));
}
impl Clone for ForeignKeyCacheInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AutoVacOpts {
    pub enabled: bool_,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_delay: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub log_min_duration: ::std::os::raw::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
#[test]
fn bindgen_test_layout_AutoVacOpts() {
    assert_eq!(::std::mem::size_of::<AutoVacOpts>() , 64usize , concat ! (
               "Size of: " , stringify ! ( AutoVacOpts ) ));
    assert_eq! (::std::mem::align_of::<AutoVacOpts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AutoVacOpts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . enabled as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . vacuum_threshold as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( vacuum_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . analyze_threshold as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( analyze_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . vacuum_cost_delay as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( vacuum_cost_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . vacuum_cost_limit as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( vacuum_cost_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . freeze_min_age as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( freeze_min_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . freeze_max_age as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( freeze_max_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . freeze_table_age as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( freeze_table_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) .
                multixact_freeze_min_age as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( multixact_freeze_min_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) .
                multixact_freeze_max_age as * const _ as usize } , 36usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( multixact_freeze_max_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) .
                multixact_freeze_table_age as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( multixact_freeze_table_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . log_min_duration as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( log_min_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . vacuum_scale_factor as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( vacuum_scale_factor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AutoVacOpts ) ) . analyze_scale_factor as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AutoVacOpts ) , "::" ,
                stringify ! ( analyze_scale_factor ) ));
}
impl Clone for AutoVacOpts {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: bool_,
    pub parallel_workers: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StdRdOptions() {
    assert_eq!(::std::mem::size_of::<StdRdOptions>() , 80usize , concat ! (
               "Size of: " , stringify ! ( StdRdOptions ) ));
    assert_eq! (::std::mem::align_of::<StdRdOptions>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( StdRdOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StdRdOptions ) ) . vl_len_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( StdRdOptions ) , "::" ,
                stringify ! ( vl_len_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StdRdOptions ) ) . fillfactor as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( StdRdOptions ) , "::" ,
                stringify ! ( fillfactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StdRdOptions ) ) . autovacuum as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( StdRdOptions ) , "::" ,
                stringify ! ( autovacuum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StdRdOptions ) ) . user_catalog_table as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( StdRdOptions ) , "::" ,
                stringify ! ( user_catalog_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StdRdOptions ) ) . parallel_workers as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( StdRdOptions ) , "::" ,
                stringify ! ( parallel_workers ) ));
}
impl Clone for StdRdOptions {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: bool_,
    pub check_option_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ViewOptions() {
    assert_eq!(::std::mem::size_of::<ViewOptions>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ViewOptions ) ));
    assert_eq! (::std::mem::align_of::<ViewOptions>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ViewOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewOptions ) ) . vl_len_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewOptions ) , "::" ,
                stringify ! ( vl_len_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewOptions ) ) . security_barrier as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewOptions ) , "::" ,
                stringify ! ( security_barrier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ViewOptions ) ) . check_option_offset as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ViewOptions ) , "::" ,
                stringify ! ( check_option_offset ) ));
}
impl Clone for ViewOptions {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn RelationIncrementReferenceCount(rel: Relation);
}
extern "C" {
    pub fn RelationDecrementReferenceCount(rel: Relation);
}
extern "C" {
    pub fn RelationHasUnloggedIndex(rel: Relation) -> bool_;
}
extern "C" {
    pub fn RelationGetRepsetList(rel: Relation) -> *mut List;
}
#[repr(C)]
#[derive(Copy)]
pub struct VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: TransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub oldestClogXid: TransactionId,
}
#[test]
fn bindgen_test_layout_VariableCacheData() {
    assert_eq!(::std::mem::size_of::<VariableCacheData>() , 52usize , concat !
               ( "Size of: " , stringify ! ( VariableCacheData ) ));
    assert_eq! (::std::mem::align_of::<VariableCacheData>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VariableCacheData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . nextOid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( nextOid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . oidCount as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( oidCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . nextXid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( nextXid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . oldestXid as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( oldestXid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . xidVacLimit as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( xidVacLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . xidWarnLimit as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( xidWarnLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . xidStopLimit as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( xidStopLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . xidWrapLimit as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( xidWrapLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . oldestXidDB as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( oldestXidDB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . oldestCommitTsXid
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( oldestCommitTsXid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . newestCommitTsXid
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( newestCommitTsXid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) .
                latestCompletedXid as * const _ as usize } , 44usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( latestCompletedXid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VariableCacheData ) ) . oldestClogXid as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VariableCacheData ) ,
                "::" , stringify ! ( oldestClogXid ) ));
}
impl Clone for VariableCacheData {
    fn clone(&self) -> Self { *self }
}
pub type VariableCache = *mut VariableCacheData;
extern "C" {
    pub fn TransactionStartedDuringRecovery() -> bool_;
}
extern "C" {
    #[link_name = "ShmemVariableCache"]
    pub static mut ShmemVariableCache: VariableCache;
}
extern "C" {
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> bool_;
}
extern "C" {
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> bool_;
}
extern "C" {
    pub fn TransactionIdIsKnownCompleted(transactionId: TransactionId)
     -> bool_;
}
extern "C" {
    pub fn TransactionIdAbort(transactionId: TransactionId);
}
extern "C" {
    pub fn TransactionIdCommitTree(xid: TransactionId,
                                   nxids: ::std::os::raw::c_int,
                                   xids: *mut TransactionId);
}
extern "C" {
    pub fn TransactionIdAsyncCommitTree(xid: TransactionId,
                                        nxids: ::std::os::raw::c_int,
                                        xids: *mut TransactionId,
                                        lsn: XLogRecPtr);
}
extern "C" {
    pub fn TransactionIdAbortTree(xid: TransactionId,
                                  nxids: ::std::os::raw::c_int,
                                  xids: *mut TransactionId);
}
extern "C" {
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId)
     -> bool_;
}
extern "C" {
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId,
                                         id2: TransactionId) -> bool_;
}
extern "C" {
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId)
     -> bool_;
}
extern "C" {
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId,
                                        id2: TransactionId) -> bool_;
}
extern "C" {
    pub fn TransactionIdLatest(mainxid: TransactionId,
                               nxids: ::std::os::raw::c_int,
                               xids: *const TransactionId) -> TransactionId;
}
extern "C" {
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
}
extern "C" {
    pub fn GetNewTransactionId(isSubXact: bool_) -> TransactionId;
}
extern "C" {
    pub fn ReadNewTransactionId() -> TransactionId;
}
extern "C" {
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId,
                                 oldest_datoid: Oid);
}
extern "C" {
    pub fn AdvanceOldestClogXid(oldest_datfrozenxid: TransactionId);
}
extern "C" {
    pub fn ForceTransactionIdLimitUpdate() -> bool_;
}
extern "C" {
    pub fn GetNewObjectId() -> Oid;
}
#[repr(C)]
#[derive(Copy)]
pub struct HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: HeapTupleFields__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union HeapTupleFields__bindgen_ty_1 {
    pub t_cid: CommandId,
    pub t_xvac: TransactionId,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_HeapTupleFields__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<HeapTupleFields__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( HeapTupleFields__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<HeapTupleFields__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( HeapTupleFields__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleFields__bindgen_ty_1 ) ) . t_cid
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                HeapTupleFields__bindgen_ty_1 ) , "::" , stringify ! ( t_cid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleFields__bindgen_ty_1 ) ) .
                t_xvac as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                HeapTupleFields__bindgen_ty_1 ) , "::" , stringify ! ( t_xvac
                ) ));
}
impl Clone for HeapTupleFields__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_HeapTupleFields() {
    assert_eq!(::std::mem::size_of::<HeapTupleFields>() , 12usize , concat ! (
               "Size of: " , stringify ! ( HeapTupleFields ) ));
    assert_eq! (::std::mem::align_of::<HeapTupleFields>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( HeapTupleFields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleFields ) ) . t_xmin as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleFields ) ,
                "::" , stringify ! ( t_xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleFields ) ) . t_xmax as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleFields ) ,
                "::" , stringify ! ( t_xmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HeapTupleFields ) ) . t_field3 as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HeapTupleFields ) ,
                "::" , stringify ! ( t_field3 ) ));
}
impl Clone for HeapTupleFields {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
#[test]
fn bindgen_test_layout_DatumTupleFields() {
    assert_eq!(::std::mem::size_of::<DatumTupleFields>() , 12usize , concat !
               ( "Size of: " , stringify ! ( DatumTupleFields ) ));
    assert_eq! (::std::mem::align_of::<DatumTupleFields>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( DatumTupleFields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DatumTupleFields ) ) . datum_len_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DatumTupleFields ) ,
                "::" , stringify ! ( datum_len_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DatumTupleFields ) ) . datum_typmod as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( DatumTupleFields ) ,
                "::" , stringify ! ( datum_typmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DatumTupleFields ) ) . datum_typeid as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DatumTupleFields ) ,
                "::" , stringify ! ( datum_typeid ) ));
}
impl Clone for DatumTupleFields {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn heap_compute_data_size(tupleDesc: TupleDesc, values: *mut Datum,
                                  isnull: *mut bool_) -> Size;
}
extern "C" {
    pub fn heap_fill_tuple(tupleDesc: TupleDesc, values: *mut Datum,
                           isnull: *mut bool_,
                           data: *mut ::std::os::raw::c_char, data_size: Size,
                           infomask: *mut uint16, bit: *mut bits8);
}
extern "C" {
    pub fn heap_attisnull(tup: HeapTuple, attnum: ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn nocachegetattr(tup: HeapTuple, attnum: ::std::os::raw::c_int,
                          att: TupleDesc) -> Datum;
}
extern "C" {
    pub fn heap_getsysattr(tup: HeapTuple, attnum: ::std::os::raw::c_int,
                           tupleDesc: TupleDesc, isnull: *mut bool_) -> Datum;
}
extern "C" {
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
}
extern "C" {
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple);
}
extern "C" {
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc)
     -> Datum;
}
extern "C" {
    pub fn heap_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                           isnull: *mut bool_) -> HeapTuple;
}
extern "C" {
    pub fn heap_modify_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             replValues: *mut Datum, replIsnull: *mut bool_,
                             doReplace: *mut bool_) -> HeapTuple;
}
extern "C" {
    pub fn heap_modify_tuple_by_cols(tuple: HeapTuple, tupleDesc: TupleDesc,
                                     nCols: ::std::os::raw::c_int,
                                     replCols: *mut ::std::os::raw::c_int,
                                     replValues: *mut Datum,
                                     replIsnull: *mut bool_) -> HeapTuple;
}
extern "C" {
    pub fn heap_deform_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             values: *mut Datum, isnull: *mut bool_);
}
extern "C" {
    pub fn heap_freetuple(htup: HeapTuple);
}
extern "C" {
    pub fn heap_form_minimal_tuple(tupleDescriptor: TupleDesc,
                                   values: *mut Datum, isnull: *mut bool_)
     -> MinimalTuple;
}
extern "C" {
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple);
}
extern "C" {
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
}
extern "C" {
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
}
extern "C" {
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
}
#[repr(C)]
#[derive(Copy)]
pub struct SharedInvalCatcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
#[test]
fn bindgen_test_layout_SharedInvalCatcacheMsg() {
    assert_eq!(::std::mem::size_of::<SharedInvalCatcacheMsg>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( SharedInvalCatcacheMsg )
               ));
    assert_eq! (::std::mem::align_of::<SharedInvalCatcacheMsg>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SharedInvalCatcacheMsg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalCatcacheMsg ) ) . id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalCatcacheMsg
                ) , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalCatcacheMsg ) ) . dbId as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalCatcacheMsg
                ) , "::" , stringify ! ( dbId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalCatcacheMsg ) ) . hashValue as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalCatcacheMsg
                ) , "::" , stringify ! ( hashValue ) ));
}
impl Clone for SharedInvalCatcacheMsg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SharedInvalCatalogMsg {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
#[test]
fn bindgen_test_layout_SharedInvalCatalogMsg() {
    assert_eq!(::std::mem::size_of::<SharedInvalCatalogMsg>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( SharedInvalCatalogMsg )
               ));
    assert_eq! (::std::mem::align_of::<SharedInvalCatalogMsg>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SharedInvalCatalogMsg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalCatalogMsg ) ) . id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalCatalogMsg )
                , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalCatalogMsg ) ) . dbId as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalCatalogMsg )
                , "::" , stringify ! ( dbId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalCatalogMsg ) ) . catId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalCatalogMsg )
                , "::" , stringify ! ( catId ) ));
}
impl Clone for SharedInvalCatalogMsg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SharedInvalRelcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
#[test]
fn bindgen_test_layout_SharedInvalRelcacheMsg() {
    assert_eq!(::std::mem::size_of::<SharedInvalRelcacheMsg>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( SharedInvalRelcacheMsg )
               ));
    assert_eq! (::std::mem::align_of::<SharedInvalRelcacheMsg>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SharedInvalRelcacheMsg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalRelcacheMsg ) ) . id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalRelcacheMsg
                ) , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalRelcacheMsg ) ) . dbId as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalRelcacheMsg
                ) , "::" , stringify ! ( dbId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalRelcacheMsg ) ) . relId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalRelcacheMsg
                ) , "::" , stringify ! ( relId ) ));
}
impl Clone for SharedInvalRelcacheMsg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SharedInvalSmgrMsg {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
#[test]
fn bindgen_test_layout_SharedInvalSmgrMsg() {
    assert_eq!(::std::mem::size_of::<SharedInvalSmgrMsg>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( SharedInvalSmgrMsg ) ));
    assert_eq! (::std::mem::align_of::<SharedInvalSmgrMsg>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SharedInvalSmgrMsg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSmgrMsg ) ) . id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSmgrMsg ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSmgrMsg ) ) . backend_hi as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSmgrMsg ) ,
                "::" , stringify ! ( backend_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSmgrMsg ) ) . backend_lo as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSmgrMsg ) ,
                "::" , stringify ! ( backend_lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSmgrMsg ) ) . rnode as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSmgrMsg ) ,
                "::" , stringify ! ( rnode ) ));
}
impl Clone for SharedInvalSmgrMsg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SharedInvalRelmapMsg {
    pub id: int8,
    pub dbId: Oid,
}
#[test]
fn bindgen_test_layout_SharedInvalRelmapMsg() {
    assert_eq!(::std::mem::size_of::<SharedInvalRelmapMsg>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( SharedInvalRelmapMsg ) ));
    assert_eq! (::std::mem::align_of::<SharedInvalRelmapMsg>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SharedInvalRelmapMsg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalRelmapMsg ) ) . id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalRelmapMsg )
                , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalRelmapMsg ) ) . dbId as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalRelmapMsg )
                , "::" , stringify ! ( dbId ) ));
}
impl Clone for SharedInvalRelmapMsg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SharedInvalSnapshotMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
#[test]
fn bindgen_test_layout_SharedInvalSnapshotMsg() {
    assert_eq!(::std::mem::size_of::<SharedInvalSnapshotMsg>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( SharedInvalSnapshotMsg )
               ));
    assert_eq! (::std::mem::align_of::<SharedInvalSnapshotMsg>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SharedInvalSnapshotMsg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSnapshotMsg ) ) . id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSnapshotMsg
                ) , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSnapshotMsg ) ) . dbId as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSnapshotMsg
                ) , "::" , stringify ! ( dbId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalSnapshotMsg ) ) . relId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SharedInvalSnapshotMsg
                ) , "::" , stringify ! ( relId ) ));
}
impl Clone for SharedInvalSnapshotMsg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union SharedInvalidationMessage {
    pub id: int8,
    pub cc: SharedInvalCatcacheMsg,
    pub cat: SharedInvalCatalogMsg,
    pub rc: SharedInvalRelcacheMsg,
    pub sm: SharedInvalSmgrMsg,
    pub rm: SharedInvalRelmapMsg,
    pub sn: SharedInvalSnapshotMsg,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_SharedInvalidationMessage() {
    assert_eq!(::std::mem::size_of::<SharedInvalidationMessage>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( SharedInvalidationMessage ) ));
    assert_eq! (::std::mem::align_of::<SharedInvalidationMessage>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SharedInvalidationMessage )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . cc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( cc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . cat as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( cat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . rc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . sm as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( sm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . rm as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( rm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SharedInvalidationMessage ) ) . sn as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SharedInvalidationMessage ) , "::" , stringify ! ( sn ) ));
}
impl Clone for SharedInvalidationMessage {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "SharedInvalidMessageCounter"]
    pub static mut SharedInvalidMessageCounter: uint64;
}
extern "C" {
    #[link_name = "catchupInterruptPending"]
    pub static mut catchupInterruptPending: sig_atomic_t;
}
extern "C" {
    pub fn SendSharedInvalidMessages(msgs: *const SharedInvalidationMessage,
                                     n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ReceiveSharedInvalidMessages(invalFunction:
                                            ::std::option::Option<unsafe extern "C" fn(msg:
                                                                                           *mut SharedInvalidationMessage)>,
                                        resetFunction:
                                            ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn HandleCatchupInterrupt();
}
extern "C" {
    pub fn ProcessCatchupInterrupt();
}
extern "C" {
    pub fn xactGetCommittedInvalidationMessages(msgs:
                                                    *mut *mut SharedInvalidationMessage,
                                                RelcacheInitFileInval:
                                                    *mut bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ProcessCommittedInvalidationMessages(msgs:
                                                    *mut SharedInvalidationMessage,
                                                nmsgs: ::std::os::raw::c_int,
                                                RelcacheInitFileInval: bool_,
                                                dbid: Oid, tsid: Oid);
}
extern "C" {
    pub fn LocalExecuteInvalidationMessage(msg:
                                               *mut SharedInvalidationMessage);
}
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Copy)]
pub struct pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pg_tm() {
    assert_eq!(::std::mem::size_of::<pg_tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pg_tm ) ));
    assert_eq! (::std::mem::align_of::<pg_tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pg_tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_sec as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_min as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_hour as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_mday as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_mon as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_year as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_wday as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_yday as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_isdst as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_gmtoff as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pg_tm ) ) . tm_zone as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pg_tm ) , "::" ,
                stringify ! ( tm_zone ) ));
}
impl Clone for pg_tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tzenum {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz)
     -> *mut pg_tm;
}
extern "C" {
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut pg_tm;
}
extern "C" {
    pub fn pg_next_dst_boundary(timep: *const pg_time_t,
                                before_gmtoff: *mut ::std::os::raw::c_long,
                                before_isdst: *mut ::std::os::raw::c_int,
                                boundary: *mut pg_time_t,
                                after_gmtoff: *mut ::std::os::raw::c_long,
                                after_isdst: *mut ::std::os::raw::c_int,
                                tz: *const pg_tz) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_interpret_timezone_abbrev(abbrev: *const ::std::os::raw::c_char,
                                        timep: *const pg_time_t,
                                        gmtoff: *mut ::std::os::raw::c_long,
                                        isdst: *mut ::std::os::raw::c_int,
                                        tz: *const pg_tz) -> bool_;
}
extern "C" {
    pub fn pg_get_timezone_offset(tz: *const pg_tz,
                                  gmtoff: *mut ::std::os::raw::c_long)
     -> bool_;
}
extern "C" {
    pub fn pg_get_timezone_name(tz: *mut pg_tz)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> bool_;
}
extern "C" {
    pub fn pg_strftime(s: *mut ::std::os::raw::c_char, max: usize,
                       format: *const ::std::os::raw::c_char,
                       tm: *const pg_tm) -> usize;
}
extern "C" {
    #[link_name = "session_timezone"]
    pub static mut session_timezone: *mut pg_tz;
}
extern "C" {
    #[link_name = "log_timezone"]
    pub static mut log_timezone: *mut pg_tz;
}
extern "C" {
    pub fn pg_timezone_initialize();
}
extern "C" {
    pub fn pg_tzset(tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
}
extern "C" {
    pub fn pg_tzset_offset(gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz;
}
extern "C" {
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
}
extern "C" {
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
}
extern "C" {
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum);
}
extern "C" {
    #[link_name = "PgStartTime"]
    pub static mut PgStartTime: TimestampTz;
}
extern "C" {
    #[link_name = "PgReloadTime"]
    pub static mut PgReloadTime: TimestampTz;
}
extern "C" {
    pub fn anytimestamp_typmod_check(istz: bool_, typmod: int32) -> int32;
}
extern "C" {
    pub fn GetCurrentTimestamp() -> TimestampTz;
}
extern "C" {
    pub fn GetSQLCurrentTimestamp(typmod: int32) -> TimestampTz;
}
extern "C" {
    pub fn GetSQLLocalTimestamp(typmod: int32) -> Timestamp;
}
extern "C" {
    pub fn TimestampDifference(start_time: TimestampTz,
                               stop_time: TimestampTz,
                               secs: *mut ::std::os::raw::c_long,
                               microsecs: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn TimestampDifferenceExceeds(start_time: TimestampTz,
                                      stop_time: TimestampTz,
                                      msec: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
}
extern "C" {
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
}
extern "C" {
    pub fn timestamptz_to_str(t: TimestampTz)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn tm2timestamp(tm: *mut pg_tm, fsec: fsec_t,
                        tzp: *mut ::std::os::raw::c_int, dt: *mut Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timestamp2tm(dt: Timestamp, tzp: *mut ::std::os::raw::c_int,
                        tm: *mut pg_tm, fsec: *mut fsec_t,
                        tzn: *mut *const ::std::os::raw::c_char,
                        attimezone: *mut pg_tz) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dt2time(dt: Timestamp, hour: *mut ::std::os::raw::c_int,
                   min: *mut ::std::os::raw::c_int,
                   sec: *mut ::std::os::raw::c_int, fsec: *mut fsec_t);
}
extern "C" {
    pub fn interval2tm(span: Interval, tm: *mut pg_tm, fsec: *mut fsec_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tm2interval(tm: *mut pg_tm, fsec: fsec_t, span: *mut Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetEpochTimestamp() -> Timestamp;
}
extern "C" {
    pub fn GetEpochTime(tm: *mut pg_tm);
}
extern "C" {
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isoweek2j(year: ::std::os::raw::c_int, week: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isoweek2date(woy: ::std::os::raw::c_int,
                        year: *mut ::std::os::raw::c_int,
                        mon: *mut ::std::os::raw::c_int,
                        mday: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn isoweekdate2date(isoweek: ::std::os::raw::c_int,
                            wday: ::std::os::raw::c_int,
                            year: *mut ::std::os::raw::c_int,
                            mon: *mut ::std::os::raw::c_int,
                            mday: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn date2isoweek(year: ::std::os::raw::c_int,
                        mon: ::std::os::raw::c_int,
                        mday: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn date2isoyear(year: ::std::os::raw::c_int,
                        mon: ::std::os::raw::c_int,
                        mday: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn date2isoyearday(year: ::std::os::raw::c_int,
                           mon: ::std::os::raw::c_int,
                           mday: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub alloc_tuple_size: Size,
}
#[test]
fn bindgen_test_layout_ReorderBufferTupleBuf() {
    assert_eq!(::std::mem::size_of::<ReorderBufferTupleBuf>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( ReorderBufferTupleBuf )
               ));
    assert_eq! (::std::mem::align_of::<ReorderBufferTupleBuf>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ReorderBufferTupleBuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTupleBuf ) ) . node as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTupleBuf )
                , "::" , stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTupleBuf ) ) . tuple as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTupleBuf )
                , "::" , stringify ! ( tuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTupleBuf ) ) .
                alloc_tuple_size as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( ReorderBufferTupleBuf )
                , "::" , stringify ! ( alloc_tuple_size ) ));
}
impl Clone for ReorderBufferTupleBuf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ReorderBufferChangeType {
    REORDER_BUFFER_CHANGE_INSERT = 0,
    REORDER_BUFFER_CHANGE_UPDATE = 1,
    REORDER_BUFFER_CHANGE_DELETE = 2,
    REORDER_BUFFER_CHANGE_MESSAGE = 3,
    REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT = 4,
    REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID = 5,
    REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID = 6,
    REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT = 7,
    REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM = 8,
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: ReorderBufferChangeType,
    pub origin_id: RepOriginId,
    pub data: ReorderBufferChange__bindgen_ty_1,
    pub node: dlist_node,
}
#[repr(C)]
#[derive(Copy)]
pub union ReorderBufferChange__bindgen_ty_1 {
    pub tp: ReorderBufferChange__bindgen_ty_1__bindgen_ty_1,
    pub msg: ReorderBufferChange__bindgen_ty_1__bindgen_ty_2,
    pub snapshot: Snapshot,
    pub command_id: CommandId,
    pub tuplecid: ReorderBufferChange__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    pub relnode: RelFileNode,
    pub clear_toast_afterwards: bool_,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
#[test]
fn bindgen_test_layout_ReorderBufferChange__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ReorderBufferChange__bindgen_ty_1__bindgen_ty_1>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ReorderBufferChange__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 )
                ) . relnode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( relnode ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 )
                ) . clear_toast_afterwards as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( clear_toast_afterwards ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 )
                ) . oldtuple as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( oldtuple ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 )
                ) . newtuple as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( newtuple ) ));
}
impl Clone for ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    pub prefix: *mut ::std::os::raw::c_char,
    pub message_size: Size,
    pub message: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ReorderBufferChange__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<ReorderBufferChange__bindgen_ty_1__bindgen_ty_2>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<ReorderBufferChange__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 )
                ) . prefix as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( prefix ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 )
                ) . message_size as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( message_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 )
                ) . message as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( message ) ));
}
impl Clone for ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    pub node: RelFileNode,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
#[test]
fn bindgen_test_layout_ReorderBufferChange__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<ReorderBufferChange__bindgen_ty_1__bindgen_ty_3>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<ReorderBufferChange__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 )
                ) . node as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( node ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 )
                ) . tid as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( tid ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 )
                ) . cmin as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( cmin ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 )
                ) . cmax as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( cmax ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 )
                ) . combocid as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( combocid ) ));
}
impl Clone for ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ReorderBufferChange__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ReorderBufferChange__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( ReorderBufferChange__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ReorderBufferChange__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                ReorderBufferChange__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange__bindgen_ty_1 ) ) .
                tp as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1 ) , "::" , stringify ! ( tp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange__bindgen_ty_1 ) ) .
                msg as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1 ) , "::" , stringify ! ( msg
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange__bindgen_ty_1 ) ) .
                snapshot as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1 ) , "::" , stringify ! (
                snapshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange__bindgen_ty_1 ) ) .
                command_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1 ) , "::" , stringify ! (
                command_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange__bindgen_ty_1 ) ) .
                tuplecid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReorderBufferChange__bindgen_ty_1 ) , "::" , stringify ! (
                tuplecid ) ));
}
impl Clone for ReorderBufferChange__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ReorderBufferChange() {
    assert_eq!(::std::mem::size_of::<ReorderBufferChange>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( ReorderBufferChange ) ));
    assert_eq! (::std::mem::align_of::<ReorderBufferChange>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ReorderBufferChange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange ) ) . lsn as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferChange ) ,
                "::" , stringify ! ( lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange ) ) . action as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferChange ) ,
                "::" , stringify ! ( action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange ) ) . origin_id as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferChange ) ,
                "::" , stringify ! ( origin_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferChange ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferChange ) ) . node as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferChange ) ,
                "::" , stringify ! ( node ) ));
}
impl Clone for ReorderBufferChange {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBufferTXN {
    pub xid: TransactionId,
    pub has_catalog_changes: bool_,
    pub is_known_as_subxact: bool_,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub restart_decoding_lsn: XLogRecPtr,
    pub origin_id: RepOriginId,
    pub origin_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub serialized: bool_,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
}
#[test]
fn bindgen_test_layout_ReorderBufferTXN() {
    assert_eq!(::std::mem::size_of::<ReorderBufferTXN>() , 208usize , concat !
               ( "Size of: " , stringify ! ( ReorderBufferTXN ) ));
    assert_eq! (::std::mem::align_of::<ReorderBufferTXN>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ReorderBufferTXN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . xid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( xid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) .
                has_catalog_changes as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( has_catalog_changes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) .
                is_known_as_subxact as * const _ as usize } , 5usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( is_known_as_subxact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . first_lsn as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( first_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . final_lsn as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( final_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . end_lsn as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( end_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) .
                restart_decoding_lsn as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( restart_decoding_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . origin_id as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( origin_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . origin_lsn as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( origin_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . commit_time as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( commit_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . base_snapshot as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( base_snapshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . base_snapshot_lsn
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( base_snapshot_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . nentries as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( nentries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . nentries_mem as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( nentries_mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . serialized as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( serialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . changes as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( changes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . tuplecids as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( tuplecids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . ntuplecids as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( ntuplecids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . tuplecid_hash as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( tuplecid_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . toast_hash as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( toast_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . subtxns as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( subtxns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . nsubtxns as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( nsubtxns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . ninvalidations as
                * const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( ninvalidations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . invalidations as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( invalidations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBufferTXN ) ) . node as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBufferTXN ) ,
                "::" , stringify ! ( node ) ));
}
impl Clone for ReorderBufferTXN {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub commit: ReorderBufferCommitCB,
    pub message: ReorderBufferMessageCB,
    pub private_data: *mut ::std::os::raw::c_void,
    pub context: MemoryContext,
    pub change_context: MemoryContext,
    pub txn_context: MemoryContext,
    pub cached_tuplebufs: slist_head,
    pub nr_cached_tuplebufs: Size,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::std::os::raw::c_char,
    pub outbufsize: Size,
}
#[test]
fn bindgen_test_layout_ReorderBuffer() {
    assert_eq!(::std::mem::size_of::<ReorderBuffer>() , 144usize , concat ! (
               "Size of: " , stringify ! ( ReorderBuffer ) ));
    assert_eq! (::std::mem::align_of::<ReorderBuffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ReorderBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . by_txn as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( by_txn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . toplevel_by_lsn as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( toplevel_by_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . by_txn_last_xid as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( by_txn_last_xid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . by_txn_last_txn as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( by_txn_last_txn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . begin as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . apply_change as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( apply_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . commit as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( commit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . message as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . private_data as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( private_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . context as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . change_context as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( change_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . txn_context as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( txn_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . cached_tuplebufs as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( cached_tuplebufs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . nr_cached_tuplebufs
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( nr_cached_tuplebufs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) .
                current_restart_decoding_lsn as * const _ as usize } ,
                120usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( current_restart_decoding_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . outbuf as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( outbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReorderBuffer ) ) . outbufsize as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ReorderBuffer ) , "::"
                , stringify ! ( outbufsize ) ));
}
impl Clone for ReorderBuffer {
    fn clone(&self) -> Self { *self }
}
pub type ReorderBufferApplyChangeCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               relation: Relation,
                                               change:
                                                   *mut ReorderBufferChange)>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN)>;
pub type ReorderBufferCommitCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               commit_lsn: XLogRecPtr)>;
pub type ReorderBufferMessageCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               message_lsn: XLogRecPtr,
                                               transactional: bool_,
                                               prefix:
                                                   *const ::std::os::raw::c_char,
                                               sz: Size,
                                               message:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
}
extern "C" {
    pub fn ReorderBufferFree(arg1: *mut ReorderBuffer);
}
extern "C" {
    pub fn ReorderBufferGetTupleBuf(arg1: *mut ReorderBuffer, tuple_len: Size)
     -> *mut ReorderBufferTupleBuf;
}
extern "C" {
    pub fn ReorderBufferReturnTupleBuf(arg1: *mut ReorderBuffer,
                                       tuple: *mut ReorderBufferTupleBuf);
}
extern "C" {
    pub fn ReorderBufferGetChange(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferChange;
}
extern "C" {
    pub fn ReorderBufferReturnChange(arg1: *mut ReorderBuffer,
                                     arg2: *mut ReorderBufferChange);
}
extern "C" {
    pub fn ReorderBufferQueueChange(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    arg3: *mut ReorderBufferChange);
}
extern "C" {
    pub fn ReorderBufferQueueMessage(arg1: *mut ReorderBuffer,
                                     arg2: TransactionId, snapshot: Snapshot,
                                     lsn: XLogRecPtr, transactional: bool_,
                                     prefix: *const ::std::os::raw::c_char,
                                     message_size: Size,
                                     message: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ReorderBufferCommit(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr,
                               commit_time: TimestampTz,
                               origin_id: RepOriginId,
                               origin_lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferAssignChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferCommitChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr,
                                    end_lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferAbort(arg1: *mut ReorderBuffer, arg2: TransactionId,
                              lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferAbortOld(arg1: *mut ReorderBuffer,
                                 xid: TransactionId);
}
extern "C" {
    pub fn ReorderBufferForget(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferSetBaseSnapshot(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        snap: *mut SnapshotData);
}
extern "C" {
    pub fn ReorderBufferAddSnapshot(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    snap: *mut SnapshotData);
}
extern "C" {
    pub fn ReorderBufferAddNewCommandId(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        cid: CommandId);
}
extern "C" {
    pub fn ReorderBufferAddNewTupleCids(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        node: RelFileNode,
                                        pt: ItemPointerData, cmin: CommandId,
                                        cmax: CommandId, combocid: CommandId);
}
extern "C" {
    pub fn ReorderBufferAddInvalidations(arg1: *mut ReorderBuffer,
                                         arg2: TransactionId, lsn: XLogRecPtr,
                                         nmsgs: Size,
                                         msgs:
                                             *mut SharedInvalidationMessage);
}
extern "C" {
    pub fn ReorderBufferImmediateInvalidation(arg1: *mut ReorderBuffer,
                                              ninvalidations: uint32,
                                              invalidations:
                                                  *mut SharedInvalidationMessage);
}
extern "C" {
    pub fn ReorderBufferProcessXid(arg1: *mut ReorderBuffer,
                                   xid: TransactionId, lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferXidSetCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId,
                                             lsn: XLogRecPtr);
}
extern "C" {
    pub fn ReorderBufferXidHasCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId) -> bool_;
}
extern "C" {
    pub fn ReorderBufferXidHasBaseSnapshot(arg1: *mut ReorderBuffer,
                                           xid: TransactionId) -> bool_;
}
extern "C" {
    pub fn ReorderBufferGetOldestTXN(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTXN;
}
extern "C" {
    pub fn ReorderBufferSetRestartPoint(arg1: *mut ReorderBuffer,
                                        ptr: XLogRecPtr);
}
extern "C" {
    pub fn StartupReorderBuffer();
}
#[repr(C)]
#[derive(Copy)]
pub struct LogicalDecodingContext {
    pub context: MemoryContext,
    pub slot: *mut ReplicationSlot,
    pub reader: *mut XLogReaderState,
    pub reorder: *mut ReorderBuffer,
    pub snapshot_builder: *mut SnapBuild,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub update_progress: LogicalOutputPluginWriterUpdateProgress,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::std::os::raw::c_void,
    pub output_writer_private: *mut ::std::os::raw::c_void,
    pub accept_writes: bool_,
    pub prepared_write: bool_,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
}
#[test]
fn bindgen_test_layout_LogicalDecodingContext() {
    assert_eq!(::std::mem::size_of::<LogicalDecodingContext>() , 184usize ,
               concat ! ( "Size of: " , stringify ! ( LogicalDecodingContext )
               ));
    assert_eq! (::std::mem::align_of::<LogicalDecodingContext>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( LogicalDecodingContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . context as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . slot as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . reader as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( reader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . reorder as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( reorder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                snapshot_builder as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( snapshot_builder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . callbacks as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( callbacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . options as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                output_plugin_options as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( output_plugin_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                prepare_write as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( prepare_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . write as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                update_progress as * const _ as usize } , 128usize , concat !
                (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( update_progress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . out as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                output_plugin_private as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( output_plugin_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                output_writer_private as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( output_writer_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                accept_writes as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( accept_writes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                prepared_write as * const _ as usize } , 161usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( prepared_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) .
                write_location as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( write_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LogicalDecodingContext ) ) . write_xid as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( LogicalDecodingContext
                ) , "::" , stringify ! ( write_xid ) ));
}
impl Clone for LogicalDecodingContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub message_cb: LogicalDecodeMessageCB,
    pub filter_by_origin_cb: LogicalDecodeFilterByOriginCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
}
#[test]
fn bindgen_test_layout_OutputPluginCallbacks() {
    assert_eq!(::std::mem::size_of::<OutputPluginCallbacks>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( OutputPluginCallbacks )
               ));
    assert_eq! (::std::mem::align_of::<OutputPluginCallbacks>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( OutputPluginCallbacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) . startup_cb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( startup_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) . begin_cb as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( begin_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) . change_cb as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( change_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) . commit_cb as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( commit_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) . message_cb as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( message_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) .
                filter_by_origin_cb as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( filter_by_origin_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginCallbacks ) ) . shutdown_cb
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginCallbacks )
                , "::" , stringify ! ( shutdown_cb ) ));
}
impl Clone for OutputPluginCallbacks {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OutputPluginOutputType {
    OUTPUT_PLUGIN_BINARY_OUTPUT = 0,
    OUTPUT_PLUGIN_TEXTUAL_OUTPUT = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
}
#[test]
fn bindgen_test_layout_OutputPluginOptions() {
    assert_eq!(::std::mem::size_of::<OutputPluginOptions>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( OutputPluginOptions ) ));
    assert_eq! (::std::mem::align_of::<OutputPluginOptions>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( OutputPluginOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OutputPluginOptions ) ) . output_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OutputPluginOptions ) ,
                "::" , stringify ! ( output_type ) ));
}
impl Clone for OutputPluginOptions {
    fn clone(&self) -> Self { *self }
}
pub type LogicalOutputPluginInit =
    ::std::option::Option<unsafe extern "C" fn(cb:
                                                   *mut OutputPluginCallbacks)>;
pub type LogicalDecodeStartupCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext,
                                               options:
                                                   *mut OutputPluginOptions,
                                               is_init: bool_)>;
pub type LogicalDecodeBeginCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN)>;
pub type LogicalDecodeChangeCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               relation: Relation,
                                               change:
                                                   *mut ReorderBufferChange)>;
pub type LogicalDecodeCommitCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               commit_lsn: XLogRecPtr)>;
pub type LogicalDecodeMessageCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               message_lsn: XLogRecPtr,
                                               transactional: bool_,
                                               prefix:
                                                   *const ::std::os::raw::c_char,
                                               message_size: Size,
                                               message:
                                                   *const ::std::os::raw::c_char)>;
pub type LogicalDecodeFilterByOriginCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext,
                                               origin_id: RepOriginId)
                              -> bool_>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut LogicalDecodingContext)>;
extern "C" {
    pub fn OutputPluginPrepareWrite(ctx: *mut LogicalDecodingContext,
                                    last_write: bool_);
}
extern "C" {
    pub fn OutputPluginWrite(ctx: *mut LogicalDecodingContext,
                             last_write: bool_);
}
extern "C" {
    pub fn OutputPluginUpdateProgress(ctx: *mut LogicalDecodingContext);
}
extern "C" {
    pub fn SpinlockSemas() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SpinlockSemaSize() -> Size;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ReplicationSlotPersistency {
    RS_PERSISTENT = 0,
    RS_EPHEMERAL = 1,
    RS_TEMPORARY = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub confirmed_flush: XLogRecPtr,
    pub plugin: NameData,
}
#[test]
fn bindgen_test_layout_ReplicationSlotPersistentData() {
    assert_eq!(::std::mem::size_of::<ReplicationSlotPersistentData>() ,
               160usize , concat ! (
               "Size of: " , stringify ! ( ReplicationSlotPersistentData ) ));
    assert_eq! (::std::mem::align_of::<ReplicationSlotPersistentData>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( ReplicationSlotPersistentData
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) . name
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! ( name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) .
                database as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! (
                database ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) .
                persistency as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! (
                persistency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) . xmin
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! ( xmin )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) .
                catalog_xmin as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! (
                catalog_xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) .
                restart_lsn as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! (
                restart_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) .
                confirmed_flush as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! (
                confirmed_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotPersistentData ) ) .
                plugin as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                ReplicationSlotPersistentData ) , "::" , stringify ! ( plugin
                ) ));
}
impl Clone for ReplicationSlotPersistentData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: bool_,
    pub active_pid: pid_t,
    pub just_dirtied: bool_,
    pub dirty: bool_,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: LWLock,
    pub active_cv: ConditionVariable,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
}
#[test]
fn bindgen_test_layout_ReplicationSlot() {
    assert_eq!(::std::mem::size_of::<ReplicationSlot>() , 240usize , concat !
               ( "Size of: " , stringify ! ( ReplicationSlot ) ));
    assert_eq! (::std::mem::align_of::<ReplicationSlot>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ReplicationSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . mutex as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( mutex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . in_use as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( in_use ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . active_pid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( active_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . just_dirtied as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( just_dirtied ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . dirty as * const _
                as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( dirty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . effective_xmin as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( effective_xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) .
                effective_catalog_xmin as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( effective_catalog_xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . io_in_progress_lock
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( io_in_progress_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . active_cv as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( active_cv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) .
                candidate_catalog_xmin as * const _ as usize } , 212usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( candidate_catalog_xmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) . candidate_xmin_lsn
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( candidate_xmin_lsn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) .
                candidate_restart_valid as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( candidate_restart_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlot ) ) .
                candidate_restart_lsn as * const _ as usize } , 232usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ReplicationSlot ) ,
                "::" , stringify ! ( candidate_restart_lsn ) ));
}
impl Clone for ReplicationSlot {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
#[test]
fn bindgen_test_layout_ReplicationSlotCtlData() {
    assert_eq!(::std::mem::size_of::<ReplicationSlotCtlData>() , 240usize ,
               concat ! ( "Size of: " , stringify ! ( ReplicationSlotCtlData )
               ));
    assert_eq! (::std::mem::align_of::<ReplicationSlotCtlData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ReplicationSlotCtlData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ReplicationSlotCtlData ) ) .
                replication_slots as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( ReplicationSlotCtlData
                ) , "::" , stringify ! ( replication_slots ) ));
}
impl Clone for ReplicationSlotCtlData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ReplicationSlotCtl"]
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
}
extern "C" {
    #[link_name = "MyReplicationSlot"]
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
}
extern "C" {
    #[link_name = "max_replication_slots"]
    pub static mut max_replication_slots: ::std::os::raw::c_int;
}
extern "C" {
    pub fn ReplicationSlotsShmemSize() -> Size;
}
extern "C" {
    pub fn ReplicationSlotsShmemInit();
}
extern "C" {
    pub fn ReplicationSlotCreate(name: *const ::std::os::raw::c_char,
                                 db_specific: bool_,
                                 p: ReplicationSlotPersistency);
}
extern "C" {
    pub fn ReplicationSlotPersist();
}
extern "C" {
    pub fn ReplicationSlotDrop(name: *const ::std::os::raw::c_char,
                               nowait: bool_);
}
extern "C" {
    pub fn ReplicationSlotAcquire(name: *const ::std::os::raw::c_char,
                                  nowait: bool_);
}
extern "C" {
    pub fn ReplicationSlotRelease();
}
extern "C" {
    pub fn ReplicationSlotCleanup();
}
extern "C" {
    pub fn ReplicationSlotSave();
}
extern "C" {
    pub fn ReplicationSlotMarkDirty();
}
extern "C" {
    pub fn ReplicationSlotValidateName(name: *const ::std::os::raw::c_char,
                                       elevel: ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn ReplicationSlotReserveWal();
}
extern "C" {
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: bool_);
}
extern "C" {
    pub fn ReplicationSlotsComputeRequiredLSN();
}
extern "C" {
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
}
extern "C" {
    pub fn ReplicationSlotsCountDBSlots(dboid: Oid,
                                        nslots: *mut ::std::os::raw::c_int,
                                        nactive: *mut ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn ReplicationSlotsDropDBSlots(dboid: Oid);
}
extern "C" {
    pub fn StartupReplicationSlots();
}
extern "C" {
    pub fn CheckPointReplicationSlots();
}
extern "C" {
    pub fn CheckSlotRequirements();
}
pub type LogicalOutputPluginWriterWrite =
    ::std::option::Option<unsafe extern "C" fn(lr:
                                                   *mut LogicalDecodingContext,
                                               Ptr: XLogRecPtr,
                                               xid: TransactionId,
                                               last_write: bool_)>;
pub type LogicalOutputPluginWriterPrepareWrite =
    LogicalOutputPluginWriterWrite;
pub type LogicalOutputPluginWriterUpdateProgress =
    ::std::option::Option<unsafe extern "C" fn(lr:
                                                   *mut LogicalDecodingContext,
                                               Ptr: XLogRecPtr,
                                               xid: TransactionId)>;
extern "C" {
    pub fn CheckLogicalDecodingRequirements();
}
extern "C" {
    pub fn CreateInitDecodingContext(plugin: *mut ::std::os::raw::c_char,
                                     output_plugin_options: *mut List,
                                     need_full_snapshot: bool_,
                                     read_page: XLogPageReadCB,
                                     prepare_write:
                                         LogicalOutputPluginWriterPrepareWrite,
                                     do_write: LogicalOutputPluginWriterWrite,
                                     update_progress:
                                         LogicalOutputPluginWriterUpdateProgress)
     -> *mut LogicalDecodingContext;
}
extern "C" {
    pub fn CreateDecodingContext(start_lsn: XLogRecPtr,
                                 output_plugin_options: *mut List,
                                 read_page: XLogPageReadCB,
                                 prepare_write:
                                     LogicalOutputPluginWriterPrepareWrite,
                                 do_write: LogicalOutputPluginWriterWrite,
                                 update_progress:
                                     LogicalOutputPluginWriterUpdateProgress)
     -> *mut LogicalDecodingContext;
}
extern "C" {
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext);
}
extern "C" {
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> bool_;
}
extern "C" {
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext);
}
extern "C" {
    pub fn LogicalIncreaseXminForSlot(lsn: XLogRecPtr, xmin: TransactionId);
}
extern "C" {
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr,
                                                 restart_lsn: XLogRecPtr);
}
extern "C" {
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr);
}
extern "C" {
    pub fn filter_by_origin_cb_wrapper(ctx: *mut LogicalDecodingContext,
                                       origin_id: RepOriginId) -> bool_;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MemoryContextData {
    pub _address: u8,
}
impl Clone for MemoryContextData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SMgrRelationData {
    pub _address: u8,
}
impl Clone for SMgrRelationData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct RowSecurityDesc {
    pub _address: u8,
}
impl Clone for RowSecurityDesc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionDescData {
    pub _address: u8,
}
impl Clone for PartitionDescData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PgStat_TableStatus {
    pub _address: u8,
}
impl Clone for PgStat_TableStatus {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ResourceOwnerData {
    pub _address: u8,
}
impl Clone for ResourceOwnerData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PartitionDispatchData {
    pub _address: u8,
}
impl Clone for PartitionDispatchData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TransitionCaptureState {
    pub _address: u8,
}
impl Clone for TransitionCaptureState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct binaryheap {
    pub _address: u8,
}
impl Clone for binaryheap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TsmRoutine {
    pub _address: u8,
}
impl Clone for TsmRoutine {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TableFuncRoutine {
    pub _address: u8,
}
impl Clone for TableFuncRoutine {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WindowObjectData {
    pub _address: u8,
}
impl Clone for WindowObjectData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ParallelExecutorInfo {
    pub _address: u8,
}
impl Clone for ParallelExecutorInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TupleQueueReader {
    pub _address: u8,
}
impl Clone for TupleQueueReader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SnapBuild {
    pub _address: u8,
}
impl Clone for SnapBuild {
    fn clone(&self) -> Self { *self }
}
